---
- :name: Bundler/DuplicatedGem
  :department_name: Bundler
  :description: A Gem's requirements should be listed only once in a Gemfile.
  :examples_description: |
    ```ruby
    # bad
    gem 'rubocop'
    gem 'rubocop'

    # bad
    group :development do
      gem 'rubocop'
    end

    group :test do
      gem 'rubocop'
    end

    # good
    group :development, :test do
      gem 'rubocop'
    end

    # good
    gem 'rubocop', groups: [:development, :test]
    ```
  :configuration:
    Description: Checks for duplicate gem entries in Gemfile.
    Enabled: true
  :configurable_attributes:
    Include:
    - "**/*.gemfile"
    - "**/Gemfile"
    - "**/gems.rb"
- :name: Bundler/InsecureProtocolSource
  :department_name: Bundler
  :description: |-
    The symbol argument `:gemcutter`, `:rubygems` and `:rubyforge`
    are deprecated. So please change your source to URL string that
    'https://rubygems.org' if possible, or 'http://rubygems.org' if not.

    This autocorrect will replace these symbols with 'https://rubygems.org'.
    Because it is secure, HTTPS request is strongly recommended. And in
    most use cases HTTPS will be fine.

    However, it don't replace all `sources` of `http://` with `https://`.
    For example, when specifying an internal gem server using HTTP on the
    intranet, a use case where HTTPS can not be specified was considered.
    Consider using HTTP only if you can not use HTTPS.
  :examples_description: |
    ```ruby
    # bad
    source :gemcutter
    source :rubygems
    source :rubyforge

    # good
    source 'https://rubygems.org' # strongly recommended
    source 'http://rubygems.org'
    ```
  :configuration:
    Description: The source `:gemcutter`, `:rubygems` and `:rubyforge` are deprecated
      because HTTP requests are insecure. Please change your source to 'https://rubygems.org'
      if possible, or 'http://rubygems.org' if not.
    Enabled: true
  :configurable_attributes:
    Include:
    - "**/*.gemfile"
    - "**/Gemfile"
    - "**/gems.rb"
- :name: Bundler/OrderedGems
  :department_name: Bundler
  :description: Gems should be alphabetically sorted within groups.
  :examples_description: |
    ```ruby
    # bad
    gem 'rubocop'
    gem 'rspec'

    # good
    gem 'rspec'
    gem 'rubocop'

    # good
    gem 'rubocop'

    gem 'rspec'

    # good only if TreatCommentsAsGroupSeparators is true
    # For code quality
    gem 'rubocop'
    # For tests
    gem 'rspec'
    ```
  :configuration:
    Description: Gems within groups in the Gemfile should be alphabetically sorted.
    Enabled: true
  :configurable_attributes:
    Include:
    - "**/*.gemfile"
    - "**/Gemfile"
    - "**/gems.rb"
    TreatCommentsAsGroupSeparators: 'true'
- :name: Gemspec/DuplicatedAssignment
  :department_name: Gemspec
  :description: |-
    An attribute assignment method calls should be listed only once
    in a gemspec.

    Assigning to an attribute with the same name using `spec.foo =` will be
    an unintended usage. On the other hand, duplication of methods such
    as `spec.requirements`, `spec.add_runtime_dependency` and others are
    permitted because it is the intended use of appending values.
  :examples_description: |
    ```ruby
    # bad
    Gem::Specification.new do |spec|
      spec.name = 'rubocop'
      spec.name = 'rubocop2'
    end

    # good
    Gem::Specification.new do |spec|
      spec.name = 'rubocop'
    end

    # good
    Gem::Specification.new do |spec|
      spec.requirements << 'libmagick, v6.0'
      spec.requirements << 'A good graphics card'
    end

    # good
    Gem::Specification.new do |spec|
      spec.add_runtime_dependency('parallel', '~> 1.10')
      spec.add_runtime_dependency('parser', '>= 2.3.3.1', '< 3.0')
    end
    ```
  :configuration:
    Description: An attribute assignment method calls should be listed only once in
      a gemspec.
    Enabled: true
  :configurable_attributes:
    Include:
    - "**/*.gemspec"
- :name: Gemspec/OrderedDependencies
  :department_name: Gemspec
  :description: Dependencies in the gemspec should be alphabetically sorted.
  :examples_description: |
    ```ruby
    # bad
    spec.add_dependency 'rubocop'
    spec.add_dependency 'rspec'

    # good
    spec.add_dependency 'rspec'
    spec.add_dependency 'rubocop'

    # good
    spec.add_dependency 'rubocop'

    spec.add_dependency 'rspec'

    # bad
    spec.add_development_dependency 'rubocop'
    spec.add_development_dependency 'rspec'

    # good
    spec.add_development_dependency 'rspec'
    spec.add_development_dependency 'rubocop'

    # good
    spec.add_development_dependency 'rubocop'

    spec.add_development_dependency 'rspec'

    # bad
    spec.add_runtime_dependency 'rubocop'
    spec.add_runtime_dependency 'rspec'

    # good
    spec.add_runtime_dependency 'rspec'
    spec.add_runtime_dependency 'rubocop'

    # good
    spec.add_runtime_dependency 'rubocop'

    spec.add_runtime_dependency 'rspec'

    # good only if TreatCommentsAsGroupSeparators is true
    # For code quality
    spec.add_dependency 'rubocop'
    # For tests
    spec.add_dependency 'rspec'
    ```
  :configuration:
    Description: Dependencies in the gemspec should be alphabetically sorted.
    Enabled: true
  :configurable_attributes:
    Include:
    - "**/*.gemspec"
    TreatCommentsAsGroupSeparators: 'true'
- :name: Gemspec/RequiredRubyVersion
  :department_name: Gemspec
  :description: |-
    Checks that `required_ruby_version` of gemspec and `TargetRubyVersion`
    of .rubocop.yml are equal.
    Thereby, RuboCop to perform static analysis working on the version
    required by gemspec.
  :examples_description: |
    ```ruby
    # When `TargetRubyVersion` of .rubocop.yml is `2.3`.

    # bad
    Gem::Specification.new do |spec|
      spec.required_ruby_version = '>= 2.2.0'
    end

    # bad
    Gem::Specification.new do |spec|
      spec.required_ruby_version = '>= 2.4.0'
    end

    # good
    Gem::Specification.new do |spec|
      spec.required_ruby_version = '>= 2.3.0'
    end

    # good
    Gem::Specification.new do |spec|
      spec.required_ruby_version = '>= 2.3'
    end

    # good
    Gem::Specification.new do |spec|
      spec.required_ruby_version = ['>= 2.3.0', '< 2.5.0']
    end
    ```
  :configuration:
    Description: Checks that `required_ruby_version` of gemspec and `TargetRubyVersion`
      of .rubocop.yml are equal.
    Enabled: true
  :configurable_attributes:
    Include:
    - "**/*.gemspec"
- :name: Layout/AccessModifierIndentation
  :department_name: Layout
  :description: |-
    Modifiers should be indented as deep as method definitions, or as deep
    as the class/module keyword, depending on configuration.
  :examples_description: |
    ```ruby
    # bad
    class Plumbus
    private
      def smooth; end
    end

    # good
    class Plumbus
      private
      def smooth; end
    end# bad
    class Plumbus
      private
      def smooth; end
    end

    # good
    class Plumbus
    private
      def smooth; end
    end
    ```
  :configuration:
    Description: Check indentation of private/protected visibility modifiers.
    StyleGuide: "#indent-public-private-protected"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: indent
    SupportedStyles:
    - outdent
    - indent
    IndentationWidth: ''
- :name: Layout/AlignArray
  :department_name: Layout
  :description: |-
    Here we check if the elements of a multi-line array literal are
    aligned.
  :examples_description: |
    ```ruby
    # bad
    a = [1, 2, 3,
      4, 5, 6]
    array = ['run',
         'forrest',
         'run']

    # good
    a = [1, 2, 3,
         4, 5, 6]
    a = ['run',
         'forrest',
         'run']
    ```
  :configuration:
    Description: Align the elements of an array literal if they span more than one
      line.
    StyleGuide: "#align-multiline-arrays"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/AlignHash
  :department_name: Layout
  :description: |-
    Check that the keys, separators, and values of a multi-line hash
    literal are aligned according to configuration. The configuration
    options are:

      - key (left align keys)
      - separator (align hash rockets and colons, right align keys)
      - table (left align keys, hash rockets, and values)

    The treatment of hashes passed as the last argument to a method call
    can also be configured. The options are:

      - always_inspect
      - always_ignore
      - ignore_implicit (without curly braces)
      - ignore_explicit (with curly braces)
  :examples_description: |
    ```ruby
    # bad
    {
      :foo => bar,
       :ba => baz
    }

    # good
    {
      :foo => bar,
      :ba => baz
    }# bad
    {
      :foo => bar,
      :ba => baz
    }
    {
      :foo => bar,
      :ba  => baz
    }

    # good
    {
      :foo => bar,
       :ba => baz
    }# bad
    {
      :foo => bar,
       :ba => baz
    }

    # good
    {
      :foo => bar,
      :ba  => baz
    }# bad
    {
      foo: bar,
       ba: baz
    }

    # good
    {
      foo: bar,
      ba: baz
    }# bad
    {
      foo: bar,
      ba: baz
    }

    # good
    {
      foo: bar,
       ba: baz
    }# bad
    {
      foo: bar,
      ba: baz
    }

    # good
    {
      foo: bar,
      ba:  baz
    }# Inspect both implicit and explicit hashes.

    # bad
    do_something(foo: 1,
      bar: 2)

    # bad
    do_something({foo: 1,
      bar: 2})

    # good
    do_something(foo: 1,
                 bar: 2)

    # good
    do_something(
      foo: 1,
      bar: 2
    )

    # good
    do_something({foo: 1,
                  bar: 2})

    # good
    do_something({
      foo: 1,
      bar: 2
    })# Ignore both implicit and explicit hashes.

    # good
    do_something(foo: 1,
      bar: 2)

    # good
    do_something({foo: 1,
      bar: 2})# Ignore only implicit hashes.

    # bad
    do_something({foo: 1,
      bar: 2})

    # good
    do_something(foo: 1,
      bar: 2)# Ignore only explicit hashes.

    # bad
    do_something(foo: 1,
      bar: 2)

    # good
    do_something({foo: 1,
      bar: 2})
    ```
  :configuration:
    Description: Align the elements of a hash literal if they span more than one line.
    Enabled: true
  :configurable_attributes:
    EnforcedHashRocketStyle: key
    SupportedHashRocketStyles:
    - key
    - separator
    - table
    EnforcedColonStyle: key
    SupportedColonStyles:
    - key
    - separator
    - table
    EnforcedLastArgumentHashStyle: always_inspect
    SupportedLastArgumentHashStyles:
    - always_inspect
    - always_ignore
    - ignore_implicit
    - ignore_explicit
- :name: Layout/AlignParameters
  :department_name: Layout
  :description: |-
    Here we check if the parameters on a multi-line method call or
    definition are aligned.
  :examples_description: |
    ```ruby
    # good

    foo :bar,
        :baz

    # bad

    foo :bar,
      :baz# good

    foo :bar,
      :baz

    # bad

    foo :bar,
        :baz
    ```
  :configuration:
    Description: Align the parameters of a method call if they span more than one
      line.
    StyleGuide: "#no-double-indent"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: with_first_parameter
    SupportedStyles:
    - with_first_parameter
    - with_fixed_indentation
    IndentationWidth: ''
- :name: Layout/BlockAlignment
  :department_name: Layout
  :description: |-
    This cop checks whether the end keywords are aligned properly for do
    end blocks.

    Three modes are supported through the `EnforcedStyleAlignWith`
    configuration parameter:

    `start_of_block` : the `end` shall be aligned with the
    start of the line where the `do` appeared.

    `start_of_line` : the `end` shall be aligned with the
    start of the line where the expression started.

    `either` (which is the default) : the `end` is allowed to be in either
    location. The autofixer will default to `start_of_line`.
  :examples_description: |
    ```ruby
    # bad

    foo.bar
       .each do
         baz
           end

    # good

    variable = lambda do |i|
      i
    end# bad

    foo.bar
       .each do
         baz
           end

    # good

    foo.bar
      .each do
         baz
       end# bad

    foo.bar
       .each do
         baz
           end

    # good

    foo.bar
      .each do
         baz
    end
    ```
  :configuration:
    Description: Align block ends correctly.
    Enabled: true
  :configurable_attributes:
    EnforcedStyleAlignWith: either
    SupportedStylesAlignWith:
    - either
    - start_of_block
    - start_of_line
- :name: Layout/BlockEndNewline
  :department_name: Layout
  :description: |-
    This cop checks whether the end statement of a do..end block
    is on its own line.
  :examples_description: |
    ```ruby
    # bad
    blah do |i|
      foo(i) end

    # good
    blah do |i|
      foo(i)
    end

    # bad
    blah { |i|
      foo(i) }

    # good
    blah { |i|
      foo(i)
    }
    ```
  :configuration:
    Description: Put end statement of multiline block on its own line.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/CaseIndentation
  :department_name: Layout
  :description: |-
    This cop checks how the *when*s of a *case* expression
    are indented in relation to its *case* or *end* keyword.

    It will register a separate offense for each misaligned *when*.
  :examples_description: |
    ```ruby
    # If Layout/EndAlignment is set to keyword style (default)
    # *case* and *end* should always be aligned to same depth,
    # and therefore *when* should always be aligned to both -
    # regardless of configuration.

    # bad for all styles
    case n
      when 0
        x * 2
      else
        y / 3
    end

    # good for all styles
    case n
    when 0
      x * 2
    else
      y / 3
    end# if EndAlignment is set to other style such as
    # start_of_line (as shown below), then *when* alignment
    # configuration does have an effect.

    # bad
    a = case n
    when 0
      x * 2
    else
      y / 3
    end

    # good
    a = case n
        when 0
          x * 2
        else
          y / 3
    end# bad
    a = case n
        when 0
          x * 2
        else
          y / 3
    end

    # good
    a = case n
    when 0
      x * 2
    else
      y / 3
    end
    ```
  :configuration:
    Description: Indentation of when in a case/when/[else/]end.
    StyleGuide: "#indent-when-to-case"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: case
    SupportedStyles:
    - case
    - end
    IndentOneStep: 'false'
    IndentationWidth: ''
- :name: Layout/ClassStructure
  :department_name: Layout
  :description: |-
    Checks if the code style follows the ExpectedOrder configuration:

    `Categories` allows us to map macro names into a category.

    Consider an example of code style that covers the following order:
    - Constants
    - Associations (has_one, has_many)
    - Attributes (attr_accessor, attr_writer, attr_reader)
    - Initializer
    - Instance methods
    - Protected methods
    - Private methods

    You can configure the following order:

    ```yaml
     Layout/ClassStructure:
       Categories:
         module_inclusion:
           - include
           - prepend
           - extend
       ExpectedOrder:
           - module_inclusion
           - constants
           - public_class_methods
           - initializer
           - public_methods
           - protected_methods
           - private_methods

    ```
    Instead of putting all literals in the expected order, is also
    possible to group categories of macros.

    ```yaml
     Layout/ClassStructure:
       Categories:
         association:
           - has_many
           - has_one
         attribute:
           - attr_accessor
           - attr_reader
           - attr_writer
    ```
  :examples_description: |
    ```ruby
    # bad
    # Expect extend be before constant
    class Person < ApplicationRecord
      has_many :orders
      ANSWER = 42

      extend SomeModule
      include AnotherModule
    end

    # good
    class Person
      # extend and include go first
      extend SomeModule
      include AnotherModule

      # inner classes
      CustomError = Class.new(StandardError)

      # constants are next
      SOME_CONSTANT = 20

      # afterwards we have attribute macros
      attr_reader :name

      # followed by other macros (if any)
      validates :name

      # public class methods are next in line
      def self.some_method
      end

      # initialization goes between class methods and instance methods
      def initialize
      end

      # followed by other public instance methods
      def some_method
      end

      # protected and private methods are grouped near the end
      protected

      def some_protected_method
      end

      private

      def some_private_method
      end
    end
    ```
  :configuration:
    Description: Enforces a configured order of definitions within a class body.
    StyleGuide: https://github.com/bbatsov/ruby-style-guide#consistent-classes
    Enabled: false
  :configurable_attributes:
    Categories: '{"module_inclusion"=>["include", "prepend", "extend"]}'
    ExpectedOrder:
    - module_inclusion
    - constants
    - public_class_methods
    - initializer
    - public_methods
    - protected_methods
    - private_methods
- :name: Layout/ClosingParenthesisIndentation
  :department_name: Layout
  :description: |-
    This cops checks the indentation of hanging closing parentheses in
    method calls, method definitions, and grouped expressions. A hanging
    closing parenthesis means `)` preceded by a line break.
  :examples_description: |
    ```ruby

    # bad
    some_method(
      a,
      b
      )

    some_method(
      a, b
      )

    some_method(a, b, c
      )

    some_method(a,
                b,
                c
      )

    some_method(a,
      x: 1,
      y: 2
      )

    # Scenario 1: When First Parameter Is On Its Own Line

    # good: when first param is on a new line, right paren is *always*
    #       outdented by IndentationWidth
    some_method(
      a,
      b
    )

    # good
    some_method(
      a, b
    )

    # Scenario 2: When First Parameter Is On The Same Line

    # good: when all other params are also on the same line, outdent
    #       right paren by IndentationWidth
    some_method(a, b, c
               )

    # good: when all other params are on multiple lines, but are lined
    #       up, align right paren with left paren
    some_method(a,
                b,
                c
               )

    # good: when other params are not lined up on multiple lines, outdent
    #       right paren by IndentationWidth
    some_method(a,
      x: 1,
      y: 2
    )
    ```
  :configuration:
    Description: Checks the indentation of hanging closing parentheses.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/CommentIndentation
  :department_name: Layout
  :description: This cops checks the indentation of comments.
  :examples_description: |
    ```ruby
    # bad
      # comment here
    def method_name
    end

      # comment here
    a = 'hello'

    # yet another comment
      if true
        true
      end

    # good
    # comment here
    def method_name
    end

    # comment here
    a = 'hello'

    # yet another comment
    if true
      true
    end
    ```
  :configuration:
    Description: Indentation of comments.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/ConditionPosition
  :department_name: Layout
  :description: |-
    This cop checks for conditions that are not on the same line as
    if/while/until.
  :examples_description: |
    ```ruby

    # bad

    if
      some_condition
      do_something
    end
    # good

    if some_condition
      do_something
    end
    ```
  :configuration:
    Description: Checks for condition placed in a confusing position relative to the
      keyword.
    StyleGuide: "#same-line-condition"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/DefEndAlignment
  :department_name: Layout
  :description: |-
    This cop checks whether the end keywords of method definitions are
    aligned properly.

    Two modes are supported through the EnforcedStyleAlignWith configuration
    parameter. If it's set to `start_of_line` (which is the default), the
    `end` shall be aligned with the start of the line where the `def`
    keyword is. If it's set to `def`, the `end` shall be aligned with the
    `def` keyword.
  :examples_description: |
    ```ruby
    # bad

    private def foo
                end

    # good

    private def foo
    end# bad

    private def foo
                end

    # good

    private def foo
            end
    ```
  :configuration:
    Description: Align ends corresponding to defs correctly.
    Enabled: true
  :configurable_attributes:
    EnforcedStyleAlignWith: start_of_line
    SupportedStylesAlignWith:
    - start_of_line
    - def
    AutoCorrect: 'false'
    Severity: warning
- :name: Layout/DotPosition
  :department_name: Layout
  :description: This cop checks the . position in multi-line method calls.
  :examples_description: |
    ```ruby
    # bad
    something.
      mehod

    # good
    something
      .method# bad
    something
      .method

    # good
    something.
      mehod
    ```
  :configuration:
    Description: Checks the position of the dot in multi-line method calls.
    StyleGuide: "#consistent-multi-line-chains"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: leading
    SupportedStyles:
    - leading
    - trailing
- :name: Layout/ElseAlignment
  :department_name: Layout
  :description: |-
    This cops checks the alignment of else keywords. Normally they should
    be aligned with an if/unless/while/until/begin/def keyword, but there
    are special cases when they should follow the same rules as the
    alignment of end.
  :examples_description: |
    ```ruby
    # bad
    if something
      code
     else
      code
    end

    # bad
    if something
      code
     elsif something
      code
    end

    # good
    if something
      code
    else
      code
    end
    ```
  :configuration:
    Description: Align elses and elsifs correctly.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/EmptyComment
  :department_name: Layout
  :description: This cop checks empty comment.
  :examples_description: |
    ```ruby
    # bad

    #
    class Foo
    end

    # good

    #
    # Description of `Foo` class.
    #
    class Foo
    end# good

    def foo
    end

    #################

    def bar
    end# bad

    def foo
    end

    #################

    def bar
    end# good

    #
    # Description of `Foo` class.
    #
    class Foo
    end# bad

    #
    # Description of `Foo` class.
    #
    class Foo
    end
    ```
  :configuration:
    Description: Checks empty comment.
    Enabled: true
  :configurable_attributes:
    AllowBorderComment: 'true'
    AllowMarginComment: 'true'
- :name: Layout/EmptyLineAfterMagicComment
  :department_name: Layout
  :description: Checks for a newline after the final magic comment.
  :examples_description: |
    ```ruby
    # good
    # frozen_string_literal: true

    # Some documentation for Person
    class Person
      # Some code
    end

    # bad
    # frozen_string_literal: true
    # Some documentation for Person
    class Person
      # Some code
    end
    ```
  :configuration:
    Description: Add an empty line after magic comments to separate them from code.
    StyleGuide: "#separate-magic-comments-from-code"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/EmptyLineBetweenDefs
  :department_name: Layout
  :description: |-
    This cop checks whether method definitions are
    separated by one empty line.

    `NumberOfEmptyLines` can be and integer (e.g. 1 by default) or
    an array (e.g. [1, 2]) to specificy a minimum and a maximum of
    empty lines.

    `AllowAdjacentOneLineDefs` can be used to configure is adjacent
    one line methods definitions are an offense
  :examples_description: |
    ```ruby

    # bad
    def a
    end
    def b
    end
    # good
    def a
    end

    def b
    end
    ```
  :configuration:
    Description: Use empty lines between defs.
    StyleGuide: "#empty-lines-between-methods"
    Enabled: true
  :configurable_attributes:
    AllowAdjacentOneLineDefs: 'false'
    NumberOfEmptyLines: '1'
- :name: Layout/EmptyLinesAroundAccessModifier
  :department_name: Layout
  :description: Access modifiers should be surrounded by blank lines.
  :examples_description: |
    ```ruby

    # bad
    class Foo
      def bar; end
      private
      def baz; end
    end

    # good
    class Foo
      def bar; end

      private

      def baz; end
    end
    ```
  :configuration:
    Description: Keep blank lines around access modifiers.
    StyleGuide: "#empty-lines-around-access-modifier"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/EmptyLinesAroundArguments
  :department_name: Layout
  :description: |-
    This cops checks if empty lines exist around the arguments
    of a method invocation.
  :examples_description: |
    ```ruby
    # bad
    do_something(
      foo

    )

    process(bar,

            baz: qux,
            thud: fred)

    some_method(

      [1,2,3],
      x: y
    )

    # good
    do_something(
      foo
    )

    process(bar,
            baz: qux,
            thud: fred)

    some_method(
      [1,2,3],
      x: y
    )
    ```
  :configuration:
    Description: Keeps track of empty lines around method arguments.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/EmptyLinesAroundBeginBody
  :department_name: Layout
  :description: |-
    This cops checks if empty lines exist around the bodies of begin-end
    blocks.
  :examples_description: |
    ```ruby

    # good

    begin
      # ...
    end

    # bad

    begin

      # ...

    end
    ```
  :configuration:
    Description: Keeps track of empty lines around begin-end bodies.
    StyleGuide: "#empty-lines-around-bodies"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/EmptyLinesAroundBlockBody
  :department_name: Layout
  :description: |-
    This cops checks if empty lines around the bodies of blocks match
    the configuration.
  :examples_description: |
    ```ruby
    # good

    foo do |bar|

      # ...

    end# good

    foo do |bar|
      # ...
    end
    ```
  :configuration:
    Description: Keeps track of empty lines around block bodies.
    StyleGuide: "#empty-lines-around-bodies"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: no_empty_lines
    SupportedStyles:
    - empty_lines
    - no_empty_lines
- :name: Layout/EmptyLinesAroundClassBody
  :department_name: Layout
  :description: |-
    This cops checks if empty lines around the bodies of classes match
    the configuration.
  :examples_description: |
    ```ruby
    # good

    class Foo

      def bar
        # ...
      end

    end# good

    class Foo
      class Bar

        # ...

      end
    end# good
    class Foo

      def bar; end

    end# good

    class Foo

      def bar
        # ...
      end
    end# good

    class Foo
      def bar
        # ...
      end

    end# good

    class Foo
      def bar
        # ...
      end
    end
    ```
  :configuration:
    Description: Keeps track of empty lines around class bodies.
    StyleGuide: "#empty-lines-around-bodies"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: no_empty_lines
    SupportedStyles:
    - empty_lines
    - empty_lines_except_namespace
    - empty_lines_special
    - no_empty_lines
    - beginning_only
    - ending_only
- :name: Layout/EmptyLinesAroundExceptionHandlingKeywords
  :department_name: Layout
  :description: |-
    This cops checks if empty lines exist around the bodies of `begin`
    sections. This cop doesn't check empty lines at `begin` body
    beginning/end and around method definition body.
    `Style/EmptyLinesAroundBeginBody` or `Style/EmptyLinesAroundMethodBody`
    can be used for this purpose.
  :examples_description: |
    ```ruby

    # good

    begin
      do_something
    rescue
      do_something2
    else
      do_something3
    ensure
      do_something4
    end

    # good

    def foo
      do_something
    rescue
      do_something2
    end

    # bad

    begin
      do_something

    rescue

      do_something2

    else

      do_something3

    ensure

      do_something4
    end

    # bad

    def foo
      do_something

    rescue

      do_something2
    end
    ```
  :configuration:
    Description: Keeps track of empty lines around exception handling keywords.
    StyleGuide: "#empty-lines-around-bodies"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/EmptyLinesAroundMethodBody
  :department_name: Layout
  :description: This cops checks if empty lines exist around the bodies of methods.
  :examples_description: |
    ```ruby

    # good

    def foo
      # ...
    end

    # bad

    def bar

      # ...

    end
    ```
  :configuration:
    Description: Keeps track of empty lines around method bodies.
    StyleGuide: "#empty-lines-around-bodies"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/EmptyLinesAroundModuleBody
  :department_name: Layout
  :description: |-
    This cops checks if empty lines around the bodies of modules match
    the configuration.
  :examples_description: |
    ```ruby
    # good

    module Foo

      def bar
        # ...
      end

    end# good

    module Foo
      module Bar

        # ...

      end
    end# good
    module Foo

      def bar; end

    end# good

    module Foo
      def bar
        # ...
      end
    end
    ```
  :configuration:
    Description: Keeps track of empty lines around module bodies.
    StyleGuide: "#empty-lines-around-bodies"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: no_empty_lines
    SupportedStyles:
    - empty_lines
    - empty_lines_except_namespace
    - empty_lines_special
    - no_empty_lines
- :name: Layout/EmptyLines
  :department_name: Layout
  :description: This cops checks for two or more consecutive blank lines.
  :examples_description: |
    ```ruby

    # bad - It has two empty lines.
    some_method
    # one empty line
    # two empty lines
    some_method

    # good
    some_method
    # one empty line
    some_method
    ```
  :configuration:
    Description: Don't use several empty lines in a row.
    StyleGuide: "#two-or-more-empty-lines"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/EndAlignment
  :department_name: Layout
  :description: |-
    This cop checks whether the end keywords are aligned properly.

    Three modes are supported through the `EnforcedStyleAlignWith`
    configuration parameter:

    If it's set to `keyword` (which is the default), the `end`
    shall be aligned with the start of the keyword (if, class, etc.).

    If it's set to `variable` the `end` shall be aligned with the
    left-hand-side of the variable assignment, if there is one.

    If it's set to `start_of_line`, the `end` shall be aligned with the
    start of the line where the matching keyword appears.
  :examples_description: |
    ```ruby
    # bad

    variable = if true
        end

    # good

    variable = if true
               end

    variable =
      if true
      end# bad

    variable = if true
        end

    # good

    variable = if true
    end

    variable =
      if true
      end# bad

    variable = if true
        end

    puts(if true
         end)

    # good

    variable = if true
    end

    puts(if true
    end)

    variable =
      if true
      end
    ```
  :configuration:
    Description: Align ends correctly.
    Enabled: true
  :configurable_attributes:
    EnforcedStyleAlignWith: keyword
    SupportedStylesAlignWith:
    - keyword
    - variable
    - start_of_line
    AutoCorrect: 'false'
    Severity: warning
- :name: Layout/EndOfLine
  :department_name: Layout
  :description: This cop checks for Windows-style line endings in the source code.
  :examples_description: |
    ```ruby
    # The `native` style means that CR+LF (Carriage Return + Line Feed) is
    # enforced on Windows, and LF is enforced on other platforms.

    # bad
    puts 'Hello' # Return character is LF on Windows.
    puts 'Hello' # Return character is CR+LF on other than Windows.

    # good
    puts 'Hello' # Return character is CR+LF on Windows.
    puts 'Hello' # Return character is LF on other than Windows.# The `lf` style means that LF (Line Feed) is enforced on
    # all platforms.

    # bad
    puts 'Hello' # Return character is CR+LF on all platfoms.

    # good
    puts 'Hello' # Return character is LF on all platfoms.# The `crlf` style means that CR+LF (Carriage Return + Line Feed) is
    # enforced on all platforms.

    # bad
    puts 'Hello' # Return character is LF on all platfoms.

    # good
    puts 'Hello' # Return character is CR+LF on all platfoms.
    ```
  :configuration:
    Description: Use Unix-style line endings.
    StyleGuide: "#crlf"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: native
    SupportedStyles:
    - native
    - lf
    - crlf
- :name: Layout/ExtraSpacing
  :department_name: Layout
  :description: This cop checks for extra/unnecessary whitespace.
  :examples_description: |
    ```ruby

    # good if AllowForAlignment is true
    name      = "RuboCop"
    # Some comment and an empty line

    website  += "/bbatsov/rubocop" unless cond
    puts        "rubocop"          if     debug

    # bad for any configuration
    set_app("RuboCop")
    website  = "https://github.com/bbatsov/rubocop"
    ```
  :configuration:
    Description: Do not use unnecessary spacing.
    Enabled: true
  :configurable_attributes:
    AllowForAlignment: 'true'
    ForceEqualSignAlignment: 'false'
- :name: Layout/FirstArrayElementLineBreak
  :department_name: Layout
  :description: |-
    This cop checks for a line break before the first element in a
    multi-line array.
  :examples_description: |
    ```ruby

    # bad
    [ :a,
      :b]

    # good
    [
      :a,
      :b]
    ```
  :configuration:
    Description: Checks for a line break before the first element in a multi-line
      array.
    Enabled: false
  :configurable_attributes: {}
- :name: Layout/FirstHashElementLineBreak
  :department_name: Layout
  :description: |-
    This cop checks for a line break before the first element in a
    multi-line hash.
  :examples_description: |
    ```ruby

    # bad
    { a: 1,
      b: 2}

    # good
    {
      a: 1,
      b: 2 }
    ```
  :configuration:
    Description: Checks for a line break before the first element in a multi-line
      hash.
    Enabled: false
  :configurable_attributes: {}
- :name: Layout/FirstMethodArgumentLineBreak
  :department_name: Layout
  :description: |-
    This cop checks for a line break before the first argument in a
    multi-line method call.
  :examples_description: |
    ```ruby

    # bad
    method(foo, bar,
      baz)

    # good
    method(
      foo, bar,
      baz)

    # ignored
    method foo, bar,
      baz
    ```
  :configuration:
    Description: Checks for a line break before the first argument in a multi-line
      method call.
    Enabled: false
  :configurable_attributes: {}
- :name: Layout/FirstMethodParameterLineBreak
  :department_name: Layout
  :description: |-
    This cop checks for a line break before the first parameter in a
    multi-line method parameter definition.
  :examples_description: |
    ```ruby

    # bad
    def method(foo, bar,
        baz)
      do_something
    end

    # good
    def method(
        foo, bar,
        baz)
      do_something
    end

    # ignored
    def method foo,
        bar
      do_something
    end
    ```
  :configuration:
    Description: Checks for a line break before the first parameter in a multi-line
      method parameter definition.
    Enabled: false
  :configurable_attributes: {}
- :name: Layout/FirstParameterIndentation
  :department_name: Layout
  :description: |-
    This cop checks the indentation of the first parameter in a method call.
    Parameters after the first one are checked by Style/AlignParameters, not
    by this cop.
  :examples_description: |
    ```ruby

    # bad
    some_method(
    first_param,
    second_param)

    # good
    some_method(
      first_param,
    second_param)
    ```
  :configuration:
    Description: Checks the indentation of the first parameter in a method call.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: special_for_inner_method_call_in_parentheses
    SupportedStyles:
    - consistent
    - special_for_inner_method_call
    - special_for_inner_method_call_in_parentheses
    IndentationWidth: ''
- :name: Layout/IndentArray
  :department_name: Layout
  :description: |-
    This cop checks the indentation of the first element in an array literal
    where the opening bracket and the first element are on separate lines.
    The other elements' indentations are handled by the AlignArray cop.

    By default, array literals that are arguments in a method call with
    parentheses, and where the opening square bracket of the array is on the
    same line as the opening parenthesis of the method call, shall have
    their first element indented one step (two spaces) more than the
    position inside the opening parenthesis.

    Other array literals shall have their first element indented one step
    more than the start of the line where the opening square bracket is.

    This default style is called 'special_inside_parentheses'. Alternative
    styles are 'consistent' and 'align_brackets'. Here are examples:
  :examples_description: |
    ```ruby
    # The `special_inside_parentheses` style enforces that the first
    # element in an array literal where the opening bracket and first
    # element are on seprate lines is indented one step (two spaces) more
    # than the position inside the opening parenthesis.

    #bad
    array = [
      :value
    ]
    and_in_a_method_call([
      :no_difference
                         ])

    #good
    array = [
      :value
    ]
    but_in_a_method_call([
                           :its_like_this
                         ])# The `consistent` style enforces that the first element in an array
    # literal where the opening bracket and the first element are on
    # seprate lines is indented the same as an array literal which is not
    # defined inside a method call.

    #bad
    # consistent
    array = [
      :value
    ]
    but_in_a_method_call([
                           :its_like_this
    ])

    #good
    array = [
      :value
    ]
    and_in_a_method_call([
      :no_difference
    ])# The `align_brackets` style enforces that the opening and closing
    # brackets are indented to the same position.

    #bad
    # align_brackets
    and_now_for_something = [
                              :completely_different
    ]

    #good
    # align_brackets
    and_now_for_something = [
                              :completely_different
                            ]
    ```
  :configuration:
    Description: Checks the indentation of the first element in an array literal.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: special_inside_parentheses
    SupportedStyles:
    - special_inside_parentheses
    - consistent
    - align_brackets
    IndentationWidth: ''
- :name: Layout/IndentAssignment
  :department_name: Layout
  :description: |-
    This cop checks the indentation of the first line of the
    right-hand-side of a multi-line assignment.

    The indentation of the remaining lines can be corrected with
    other cops such as `IndentationConsistency` and `EndAlignment`.
  :examples_description: |
    ```ruby
    # bad
    value =
    if foo
      'bar'
    end

    # good
    value =
      if foo
        'bar'
      end
    ```
  :configuration:
    Description: Checks the indentation of the first line of the right-hand-side of
      a multi-line assignment.
    Enabled: true
  :configurable_attributes:
    IndentationWidth: ''
- :name: Layout/IndentationConsistency
  :department_name: Layout
  :description: |-
    This cops checks for inconsistent indentation.

    The difference between `rails` and `normal` is that the `rails` style
    prescribes that in classes and modules the `protected` and `private`
    modifier keywords shall be indented the same as public methods and that
    protected and private members shall be indented one step more than the
    modifiers. Other than that, both styles mean that entities on the same
    logical depth shall have the same indentation.
  :examples_description: |
    ```ruby
    # bad
    class A
      def test
        puts 'hello'
         puts 'world'
      end
    end

    # bad
    class A
      def test
        puts 'hello'
        puts 'world'
      end

      protected

        def foo
        end

      private

        def bar
        end
    end

    # good
    class A
      def test
        puts 'hello'
        puts 'world'
      end
    end

    # good
    class A
      def test
        puts 'hello'
        puts 'world'
      end

      protected

      def foo
      end

      private

      def bar
      end
    end# bad
    class A
      def test
        puts 'hello'
         puts 'world'
      end
    end

    # bad
    class A
      def test
        puts 'hello'
        puts 'world'
      end

      protected

      def foo
      end

      private

      def bar
      end
    end

    # good
    class A
      def test
        puts 'hello'
        puts 'world'
      end
    end

    # good
    class A
      def test
        puts 'hello'
        puts 'world'
      end

      protected

        def foo
        end

      private

        def bar
        end
    end
    ```
  :configuration:
    Description: Keep indentation straight.
    StyleGuide: "#spaces-indentation"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: normal
    SupportedStyles:
    - normal
    - rails
- :name: Layout/IndentationWidth
  :department_name: Layout
  :description: |-
    This cops checks for indentation that doesn't use the specified number
    of spaces.

    See also the IndentationConsistency cop which is the companion to this
    one.
  :examples_description: |
    ```ruby
    # bad
    class A
     def test
      puts 'hello'
     end
    end

    # good
    class A
      def test
        puts 'hello'
      end
    end# bad
    module A
    class B
      def test
      puts 'hello'
      end
    end
    end

    # good
    module A
    class B
      def test
        puts 'hello'
      end
    end
    end
    ```
  :configuration:
    Description: Use 2 spaces for indentation.
    StyleGuide: "#spaces-indentation"
    Enabled: true
  :configurable_attributes:
    Width: '2'
    IgnoredPatterns: []
- :name: Layout/IndentHash
  :department_name: Layout
  :description: |-
    This cops checks the indentation of the first key in a hash literal
    where the opening brace and the first key are on separate lines. The
    other keys' indentations are handled by the AlignHash cop.

    By default, Hash literals that are arguments in a method call with
    parentheses, and where the opening curly brace of the hash is on the
    same line as the opening parenthesis of the method call, shall have
    their first key indented one step (two spaces) more than the position
    inside the opening parenthesis.

    Other hash literals shall have their first key indented one step more
    than the start of the line where the opening curly brace is.

    This default style is called 'special_inside_parentheses'. Alternative
    styles are 'consistent' and 'align_braces'. Here are examples:
  :examples_description: |
    ```ruby
    # The `special_inside_parentheses` style enforces that the first key
    # in a hash literal where the opening brace and the first key are on
    # separate lines is indented one step (two spaces) more than the
    # position inside the opening parentheses.

    # bad
    hash = {
      key: :value
    }
    and_in_a_method_call({
      no: :difference
                         })

    # good
    special_inside_parentheses
    hash = {
      key: :value
    }
    but_in_a_method_call({
                           its_like: :this
                         })# The `consistent` style enforces that the first key in a hash
    # literal where the opening brace and the first key are on
    # seprate lines is indented the same as a hash literal which is not
    # defined inside a method call.

    # bad
    hash = {
      key: :value
    }
    but_in_a_method_call({
                           its_like: :this
                          })

    # good
    hash = {
      key: :value
    }
    and_in_a_method_call({
      no: :difference
    })# The `align_brackets` style enforces that the opening and closing
    # braces are indented to the same position.

    # bad
    and_now_for_something = {
                              completely: :different
    }

    # good
    and_now_for_something = {
                              completely: :different
                            }
    ```
  :configuration:
    Description: Checks the indentation of the first key in a hash literal.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: special_inside_parentheses
    SupportedStyles:
    - special_inside_parentheses
    - consistent
    - align_braces
    IndentationWidth: ''
- :name: Layout/IndentHeredoc
  :department_name: Layout
  :description: |-
    This cops checks the indentation of the here document bodies. The bodies
    are indented one step.
    In Ruby 2.3 or newer, squiggly heredocs (`<<~`) should be used. If you
    use the older rubies, you should introduce some library to your project
    (e.g. ActiveSupport, Powerpack or Unindent).
    Note: When `Metrics/LineLength`'s `AllowHeredoc` is false(not default),
          this cop does not add any offenses for long here documents to
          avoid `Metrics/LineLength`'s offenses.
  :examples_description: |
    ```ruby
    # bad
    <<-RUBY
    something
    RUBY

    # good
    # When using Ruby 2.3 or higher.
    <<~RUBY
      something
    RUBY

    # good
    # When using Ruby 2.2 or lower and enabled Rails department.
    # The following is possible to enable Rails department by
    # adding for example:
    #
    # Rails:
    #   Enabled: true
    #
    <<-RUBY.strip_heredoc
      something
    RUBY# good
    # When EnforcedStyle is squiggly, bad code is auto-corrected to the
    # following code.
    <<~RUBY
      something
    RUBY# good
    # When EnforcedStyle is active_support, bad code is auto-corrected to
    # the following code.
    <<-RUBY.strip_heredoc
      something
    RUBY# good
    # When EnforcedStyle is powerpack, bad code is auto-corrected to
    # the following code.
    <<-RUBY.strip_indent
      something
    RUBY# good
    # When EnforcedStyle is unindent, bad code is auto-corrected to
    # the following code.
    <<-RUBY.unindent
      something
    RUBY
    ```
  :configuration:
    Description: This cops checks the indentation of the here document bodies.
    StyleGuide: "#squiggly-heredocs"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: auto_detection
    SupportedStyles:
    - auto_detection
    - squiggly
    - active_support
    - powerpack
    - unindent
- :name: Layout/InitialIndentation
  :department_name: Layout
  :description: |-
    This cops checks for indentation of the first non-blank non-comment
    line in a file.
  :examples_description: |
    ```ruby
    # bad
       class A
         def foo; end
       end

    # good
    class A
      def foo; end
    end
    ```
  :configuration:
    Description: Checks the indentation of the first non-blank non-comment line in
      a file.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/LeadingCommentSpace
  :department_name: Layout
  :description: |-
    This cop checks whether comments have a leading space after the
    `#` denoting the start of the comment. The leading space is not
    required for some RDoc special syntax, like `#++`, `#--`,
    `#:nodoc`, `=begin`- and `=end` comments, "shebang" directives,
    or rackup options.
  :examples_description: |
    ```ruby

    # bad
    #Some comment

    # good
    # Some comment
    ```
  :configuration:
    Description: Comments should start with a space.
    StyleGuide: "#hash-space"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/MultilineArrayBraceLayout
  :department_name: Layout
  :description: |-
    This cop checks that the closing brace in an array literal is either
    on the same line as the last array element, or a new line.

    When using the `symmetrical` (default) style:

    If an array's opening brace is on the same line as the first element
    of the array, then the closing brace should be on the same line as
    the last element of the array.

    If an array's opening brace is on the line above the first element
    of the array, then the closing brace should be on the line below
    the last element of the array.

    When using the `new_line` style:

    The closing brace of a multi-line array literal must be on the line
    after the last element of the array.

    When using the `same_line` style:

    The closing brace of a multi-line array literal must be on the same
    line as the last element of the array.
  :examples_description: |
    ```ruby
    # bad
    [ :a,
      :b
    ]

    # bad
    [
      :a,
      :b ]

    # good
    [ :a,
      :b ]

    # good
    [
      :a,
      :b
    ]# bad
    [
      :a,
      :b ]

    # bad
    [ :a,
      :b ]

    # good
    [ :a,
      :b
    ]

    # good
    [
      :a,
      :b
    ]# bad
    [ :a,
      :b
    ]

    # bad
    [
      :a,
      :b
    ]

    # good
    [
      :a,
      :b ]

    # good
    [ :a,
      :b ]
    ```
  :configuration:
    Description: Checks that the closing brace in an array literal is either on the
      same line as the last array element, or a new line.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: symmetrical
    SupportedStyles:
    - symmetrical
    - new_line
    - same_line
- :name: Layout/MultilineAssignmentLayout
  :department_name: Layout
  :description: |-
    This cop checks whether the multiline assignments have a newline
    after the assignment operator.
  :examples_description: |
    ```ruby
    # bad
    foo = if expression
      'bar'
    end

    # good
    foo =
      if expression
        'bar'
      end

    # good
    foo =
      begin
        compute
      rescue => e
        nil
      end# good
    foo = if expression
      'bar'
    end
    ```
  :configuration:
    Description: Check for a newline after the assignment operator in multi-line assignments.
    StyleGuide: "#indent-conditional-assignment"
    Enabled: false
  :configurable_attributes:
    SupportedTypes:
    - block
    - case
    - class
    - if
    - kwbegin
    - module
    EnforcedStyle: new_line
    SupportedStyles:
    - same_line
    - new_line
- :name: Layout/MultilineBlockLayout
  :department_name: Layout
  :description: |-
    This cop checks whether the multiline do end blocks have a newline
    after the start of the block. Additionally, it checks whether the block
    arguments, if any, are on the same line as the start of the block.
  :examples_description: |
    ```ruby
    # bad
    blah do |i| foo(i)
      bar(i)
    end

    # bad
    blah do
      |i| foo(i)
      bar(i)
    end

    # good
    blah do |i|
      foo(i)
      bar(i)
    end

    # bad
    blah { |i| foo(i)
      bar(i)
    }

    # good
    blah { |i|
      foo(i)
      bar(i)
    }
    ```
  :configuration:
    Description: Ensures newlines after multiline block do statements.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/MultilineHashBraceLayout
  :department_name: Layout
  :description: |-
    This cop checks that the closing brace in a hash literal is either
    on the same line as the last hash element, or a new line.

    When using the `symmetrical` (default) style:

    If a hash's opening brace is on the same line as the first element
    of the hash, then the closing brace should be on the same line as
    the last element of the hash.

    If a hash's opening brace is on the line above the first element
    of the hash, then the closing brace should be on the line below
    the last element of the hash.

    When using the `new_line` style:

    The closing brace of a multi-line hash literal must be on the line
    after the last element of the hash.

    When using the `same_line` style:

    The closing brace of a multi-line hash literal must be on the same
    line as the last element of the hash.
  :examples_description: |
    ```ruby

    # bad
    { a: 1,
      b: 2
    }
    # bad
    {
      a: 1,
      b: 2 }

    # good
    { a: 1,
      b: 2 }

    # good
    {
      a: 1,
      b: 2
    }# bad
    {
      a: 1,
      b: 2 }

    # bad
    { a: 1,
      b: 2 }

    # good
    { a: 1,
      b: 2
    }

    # good
    {
      a: 1,
      b: 2
    }# bad
    { a: 1,
      b: 2
    }

    # bad
    {
      a: 1,
      b: 2
    }

    # good
    {
      a: 1,
      b: 2 }

    # good
    { a: 1,
      b: 2 }
    ```
  :configuration:
    Description: Checks that the closing brace in a hash literal is either on the
      same line as the last hash element, or a new line.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: symmetrical
    SupportedStyles:
    - symmetrical
    - new_line
    - same_line
- :name: Layout/MultilineMethodCallBraceLayout
  :department_name: Layout
  :description: |-
    This cop checks that the closing brace in a method call is either
    on the same line as the last method argument, or a new line.

    When using the `symmetrical` (default) style:

    If a method call's opening brace is on the same line as the first
    argument of the call, then the closing brace should be on the same
    line as the last argument of the call.

    If an method call's opening brace is on the line above the first
    argument of the call, then the closing brace should be on the line
    below the last argument of the call.

    When using the `new_line` style:

    The closing brace of a multi-line method call must be on the line
    after the last argument of the call.

    When using the `same_line` style:

    The closing brace of a multi-line method call must be on the same
    line as the last argument of the call.
  :examples_description: |
    ```ruby
    # bad
    foo(a,
      b
    )

    # bad
    foo(
      a,
      b)

    # good
    foo(a,
      b)

    # good
    foo(
      a,
      b
    )# bad
    foo(
      a,
      b)

    # bad
    foo(a,
      b)

    # good
    foo(a,
      b
    )

    # good
    foo(
      a,
      b
    )# bad
    foo(a,
      b
    )

    # bad
    foo(
      a,
      b
    )

    # good
    foo(
      a,
      b)

    # good
    foo(a,
      b)
    ```
  :configuration:
    Description: Checks that the closing brace in a method call is either on the same
      line as the last method argument, or a new line.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: symmetrical
    SupportedStyles:
    - symmetrical
    - new_line
    - same_line
- :name: Layout/MultilineMethodCallIndentation
  :department_name: Layout
  :description: |-
    This cop checks the indentation of the method name part in method calls
    that span more than one line.
  :examples_description: |
    ```ruby
    # bad
    while myvariable
    .b
      # do something
    end

    # good
    while myvariable
          .b
      # do something
    end

    # good
    Thing.a
         .b
         .c# good
    while myvariable
      .b

      # do something
    end# good
    while myvariable
            .a
            .b

      # do something
    end

    # good
    myvariable = Thing
                   .a
                   .b
                   .c
    ```
  :configuration:
    Description: Checks indentation of method calls with the dot operator that span
      more than one line.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: aligned
    SupportedStyles:
    - aligned
    - indented
    - indented_relative_to_receiver
    IndentationWidth: ''
- :name: Layout/MultilineMethodDefinitionBraceLayout
  :department_name: Layout
  :description: |-
    This cop checks that the closing brace in a method definition is either
    on the same line as the last method parameter, or a new line.

    When using the `symmetrical` (default) style:

    If a method definition's opening brace is on the same line as the
    first parameter of the definition, then the closing brace should be
    on the same line as the last parameter of the definition.

    If an method definition's opening brace is on the line above the first
    parameter of the definition, then the closing brace should be on the
    line below the last parameter of the definition.

    When using the `new_line` style:

    The closing brace of a multi-line method definition must be on the line
    after the last parameter of the definition.

    When using the `same_line` style:

    The closing brace of a multi-line method definition must be on the same
    line as the last parameter of the definition.
  :examples_description: |
    ```ruby
    # bad
    def foo(a,
      b
    )
    end

    # bad
    def foo(
      a,
      b)
    end

    # good
    def foo(a,
      b)
    end

    # good
    def foo(
      a,
      b
    )
    end# bad
    def foo(
      a,
      b)
    end

    # bad
    def foo(a,
      b)
    end

    # good
    def foo(a,
      b
    )
    end

    # good
    def foo(
      a,
      b
    )
    end# bad
    def foo(a,
      b
    )
    end

    # bad
    def foo(
      a,
      b
    )
    end

    # good
    def foo(
      a,
      b)
    end

    # good
    def foo(a,
      b)
    end
    ```
  :configuration:
    Description: Checks that the closing brace in a method definition is either on
      the same line as the last method parameter, or a new line.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: symmetrical
    SupportedStyles:
    - symmetrical
    - new_line
    - same_line
- :name: Layout/MultilineOperationIndentation
  :department_name: Layout
  :description: |-
    This cop checks the indentation of the right hand side operand in
    binary operations that span more than one line.
  :examples_description: |
    ```ruby
    # bad
    if a +
        b
      something
    end

    # good
    if a +
       b
      something
    end# bad
    if a +
       b
      something
    end

    # good
    if a +
        b
      something
    end
    ```
  :configuration:
    Description: Checks indentation of binary operations that span more than one line.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: aligned
    SupportedStyles:
    - aligned
    - indented
    IndentationWidth: ''
- :name: Layout/RescueEnsureAlignment
  :department_name: Layout
  :description: |-
    This cop checks whether the rescue and ensure keywords are aligned
    properly.
  :examples_description: |
    ```ruby

    # bad
    begin
      something
      rescue
      puts 'error'
    end

    # good
    begin
      something
    rescue
      puts 'error'
    end
    ```
  :configuration:
    Description: Align rescues and ensures correctly.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceAfterColon
  :department_name: Layout
  :description: |-
    Checks for colon (:) not followed by some kind of space.
    N.B. this cop does not handle spaces after a ternary operator, which are
    instead handled by Layout/SpaceAroundOperators.
  :examples_description: |
    ```ruby
    # bad
    def f(a:, b:2); {a:3}; end

    # good
    def f(a:, b: 2); {a: 3}; end
    ```
  :configuration:
    Description: Use spaces after colons.
    StyleGuide: "#spaces-operators"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceAfterComma
  :department_name: Layout
  :description: Checks for comma (,) not followed by some kind of space.
  :examples_description: |
    ```ruby

    # bad
    [1,2]
    { foo:bar,}

    # good
    [1, 2]
    { foo:bar, }
    ```
  :configuration:
    Description: Use spaces after commas.
    StyleGuide: "#spaces-operators"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceAfterMethodName
  :department_name: Layout
  :description: Checks for space between a method name and a left parenthesis in defs.
  :examples_description: |
    ```ruby

    # bad
    def func (x) end
    def method= (y) end

    # good
    def func(x) end
    def method=(y) end
    ```
  :configuration:
    Description: Do not put a space between a method name and the opening parenthesis
      in a method definition.
    StyleGuide: "#parens-no-spaces"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceAfterNot
  :department_name: Layout
  :description: This cop checks for space after `!`.
  :examples_description: |
    ```ruby
    # bad
    ! something

    # good
    !something
    ```
  :configuration:
    Description: Tracks redundant space after the ! operator.
    StyleGuide: "#no-space-bang"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceAfterSemicolon
  :department_name: Layout
  :description: Checks for semicolon (;) not followed by some kind of space.
  :examples_description: |
    ```ruby
    # bad
    x = 1;y = 2

    # good
    x = 1; y = 2
    ```
  :configuration:
    Description: Use spaces after semicolons.
    StyleGuide: "#spaces-operators"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceAroundBlockParameters
  :department_name: Layout
  :description: Checks the spacing inside and after block parameters pipes.
  :examples_description: |
    ```ruby
    # bad
    {}.each { | x,  y |puts x }
    ->( x,  y ) { puts x }

    # good
    {}.each { |x, y| puts x }
    ->(x, y) { puts x }# bad
    {}.each { |x,  y| puts x }
    ->(x,  y) { puts x }

    # good
    {}.each { | x, y | puts x }
    ->( x, y ) { puts x }
    ```
  :configuration:
    Description: Checks the spacing inside and after block parameters pipes.
    Enabled: true
  :configurable_attributes:
    EnforcedStyleInsidePipes: no_space
    SupportedStylesInsidePipes:
    - space
    - no_space
- :name: Layout/SpaceAroundEqualsInParameterDefault
  :department_name: Layout
  :description: |-
    Checks that the equals signs in parameter default assignments
    have or don't have surrounding space depending on configuration.
  :examples_description: |
    ```ruby
    # bad
    def some_method(arg1=:default, arg2=nil, arg3=[])
      # do something...
    end

    # good
    def some_method(arg1 = :default, arg2 = nil, arg3 = [])
      # do something...
    end# bad
    def some_method(arg1 = :default, arg2 = nil, arg3 = [])
      # do something...
    end

    # good
    def some_method(arg1=:default, arg2=nil, arg3=[])
      # do something...
    end
    ```
  :configuration:
    Description: Checks that the equals signs in parameter default assignments have
      or don't have surrounding space depending on configuration.
    StyleGuide: "#spaces-around-equals"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: space
    SupportedStyles:
    - space
    - no_space
- :name: Layout/SpaceAroundKeyword
  :department_name: Layout
  :description: Checks the spacing around the keywords.
  :examples_description: |
    ```ruby

    # bad
    something 'test'do|x|
    end

    while(something)
    end

    something = 123if test

    # good
    something 'test' do |x|
    end

    while (something)
    end

    something = 123 if test
    ```
  :configuration:
    Description: Use a space around keywords if appropriate.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceAroundOperators
  :department_name: Layout
  :description: |-
    Checks that operators have space around them, except for **
    which should not have surrounding space.
  :examples_description: |
    ```ruby
    # bad
    total = 3*4
    "apple"+"juice"
    my_number = 38/4
    a ** b

    # good
    total = 3 * 4
    "apple" + "juice"
    my_number = 38 / 4
    a**b
    ```
  :configuration:
    Description: Use a single space around operators.
    StyleGuide: "#spaces-operators"
    Enabled: true
  :configurable_attributes:
    AllowForAlignment: 'true'
- :name: Layout/SpaceBeforeBlockBraces
  :department_name: Layout
  :description: |-
    Checks that block braces have or don't have a space before the opening
    brace depending on configuration.
  :examples_description: |
    ```ruby
    # bad
    foo.map{ |a|
      a.bar.to_s
    }

    # good
    foo.map { |a|
      a.bar.to_s
    }# bad
    foo.map { |a|
      a.bar.to_s
    }

    # good
    foo.map{ |a|
      a.bar.to_s
    }
    ```
  :configuration:
    Description: Checks that the left block brace has or doesn't have space before
      it.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: space
    SupportedStyles:
    - space
    - no_space
    EnforcedStyleForEmptyBraces: space
    SupportedStylesForEmptyBraces:
    - space
    - no_space
- :name: Layout/SpaceBeforeComma
  :department_name: Layout
  :description: Checks for comma (,) preceded by space.
  :examples_description: |
    ```ruby
    # bad
    [1 , 2 , 3]
    a(1 , 2)
    each { |a , b| }

    # good
    [1, 2, 3]
    a(1, 2)
    each { |a, b| }
    ```
  :configuration:
    Description: No spaces before commas.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceBeforeComment
  :department_name: Layout
  :description: |-
    This cop checks for missing space between a token and a comment on the
    same line.
  :examples_description: |
    ```ruby
    # bad
    1 + 1# this operation does ...

    # good
    1 + 1 # this operation does ...
    ```
  :configuration:
    Description: Checks for missing space between code and a comment on the same line.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceBeforeFirstArg
  :department_name: Layout
  :description: |-
    Checks that exactly one space is used between a method name and the
    first argument for method calls without parentheses.

    Alternatively, extra spaces can be added to align the argument with
    something on a preceding or following line, if the AllowForAlignment
    config parameter is true.
  :examples_description: |
    ```ruby
    # bad
    something  x
    something   y, z
    something'hello'

    # good
    something x
    something y, z
    something 'hello'
    ```
  :configuration:
    Description: Checks that exactly one space is used between a method name and the
      first argument for method calls without parentheses.
    Enabled: true
  :configurable_attributes:
    AllowForAlignment: 'true'
- :name: Layout/SpaceBeforeSemicolon
  :department_name: Layout
  :description: Checks for semicolon (;) preceded by space.
  :examples_description: |
    ```ruby
    # bad
    x = 1 ; y = 2

    # good
    x = 1; y = 2
    ```
  :configuration:
    Description: No spaces before semicolons.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceInLambdaLiteral
  :department_name: Layout
  :description: |-
    This cop checks for spaces between -> and opening parameter
    brace in lambda literals.
  :examples_description: |
    ```ruby
    # bad
    a = -> (x, y) { x + y }

    # good
    a = ->(x, y) { x + y }# bad
    a = ->(x, y) { x + y }

    # good
    a = -> (x, y) { x + y }
    ```
  :configuration:
    Description: Checks for spaces in lambda literals.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: require_no_space
    SupportedStyles:
    - require_no_space
    - require_space
- :name: Layout/SpaceInsideArrayPercentLiteral
  :department_name: Layout
  :description: |-
    Checks for unnecessary additional spaces inside array percent literals
    (i.e. %i/%w).
  :examples_description: |
    ```ruby

    # bad
    %w(foo  bar  baz)
    # good
    %i(foo bar baz)
    ```
  :configuration:
    Description: No unnecessary additional spaces between elements in %i/%w literals.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceInsideArrayLiteralBrackets
  :department_name: Layout
  :description: |-
    Checks that brackets used for array literals have or don't have
    surrounding space depending on configuration.
  :examples_description: |
    ```ruby
    # The `space` style enforces that array literals have
    # surrounding space.

    # bad
    array = [a, b, c, d]

    # good
    array = [ a, b, c, d ]# The `no_space` style enforces that array literals have
    # no surrounding space.

    # bad
    array = [ a, b, c, d ]

    # good
    array = [a, b, c, d]# The `compact` style normally requires a space inside
    # array brackets, with the exception that successive left
    # or right brackets are collapsed together in nested arrays.

    # bad
    array = [ a, [ b, c ] ]

    # good
    array = [ a, [ b, c ]]# The `no_space` EnforcedStyleForEmptyBrackets style enforces that
    # empty array brackets do not contain spaces.

    # bad
    foo = [ ]
    bar = [     ]

    # good
    foo = []
    bar = []# The `space` EnforcedStyleForEmptyBrackets style enforces that
    # empty array brackets contain exactly one space.

    # bad
    foo = []
    bar = [    ]

    # good
    foo = [ ]
    bar = [ ]
    ```
  :configuration:
    Description: Checks the spacing inside array literal brackets.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: no_space
    SupportedStyles:
    - space
    - no_space
    - compact
    EnforcedStyleForEmptyBrackets: no_space
    SupportedStylesForEmptyBrackets:
    - space
    - no_space
- :name: Layout/SpaceInsideBlockBraces
  :department_name: Layout
  :description: |-
    Checks that block braces have or don't have surrounding space inside
    them on configuration. For blocks taking parameters, it checks that the
    left brace has or doesn't have trailing space depending on
    configuration.
  :examples_description: |
    ```ruby
    # The `space` style enforces that block braces have
    # surrounding space.

    # bad
    some_array.each {puts e}

    # good
    some_array.each { puts e }# The `no_space` style enforces that block braces don't
    # have surrounding space.

    # bad
    some_array.each { puts e }

    # good
    some_array.each {puts e}# The `no_space` EnforcedStyleForEmptyBraces style enforces that
    # block braces don't have a space in between when empty.

    # bad
    some_array.each {   }
    some_array.each {  }
    some_array.each { }

    # good
    some_array.each {}# The `space` EnforcedStyleForEmptyBraces style enforces that
    # block braces have at least a space in between when empty.

    # bad
    some_array.each {}

    # good
    some_array.each { }
    some_array.each {  }
    some_array.each {   }# The SpaceBeforeBlockParameters style set to `true` enforces that
    # there is a space between `{` and `|`. Overrides `EnforcedStyle`
    # if there is a conflict.

    # bad
    [1, 2, 3].each {|n| n * 2 }

    # good
    [1, 2, 3].each { |n| n * 2 }# The SpaceBeforeBlockParameters style set to `false` enforces that
    # there is no space between `{` and `|`. Overrides `EnforcedStyle`
    # if there is a conflict.

    # bad
    [1, 2, 3].each { |n| n * 2 }

    # good
    [1, 2, 3].each {|n| n * 2 }
    ```
  :configuration:
    Description: Checks that block braces have or don't have surrounding space. For
      blocks taking parameters, checks that the left brace has or doesn't have trailing
      space.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: space
    SupportedStyles:
    - space
    - no_space
    EnforcedStyleForEmptyBraces: no_space
    SupportedStylesForEmptyBraces:
    - space
    - no_space
    SpaceBeforeBlockParameters: 'true'
- :name: Layout/SpaceInsideHashLiteralBraces
  :department_name: Layout
  :description: |-
    Checks that braces used for hash literals have or don't have
    surrounding space depending on configuration.
  :examples_description: |
    ```ruby
    # The `space` style enforces that hash literals have
    # surrounding space.

    # bad
    h = {a: 1, b: 2}

    # good
    h = { a: 1, b: 2 }# The `no_space` style enforces that hash literals have
    # no surrounding space.

    # bad
    h = { a: 1, b: 2 }

    # good
    h = {a: 1, b: 2}# The `compact` style normally requires a space inside
    # hash braces, with the exception that successive left
    # braces or right braces are collapsed together in nested hashes.

    # bad
    h = { a: { b: 2 } }

    # good
    h = { a: { b: 2 }}# The `no_space` EnforcedStyleForEmptyBraces style enforces that
    # empty hash braces do not contain spaces.

    # bad
    foo = { }
    bar = {    }

    # good
    foo = {}
    bar = {}# The `space` EnforcedStyleForEmptyBraces style enforces that
    # empty hash braces contain space.

    # bad
    foo = {}

    # good
    foo = { }
    foo = {  }
    foo = {     }
    ```
  :configuration:
    Description: Use spaces inside hash literal braces - or don't.
    StyleGuide: "#spaces-operators"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: space
    SupportedStyles:
    - space
    - no_space
    - compact
    EnforcedStyleForEmptyBraces: no_space
    SupportedStylesForEmptyBraces:
    - space
    - no_space
- :name: Layout/SpaceInsideParens
  :department_name: Layout
  :description: Checks for spaces inside ordinary round parentheses.
  :examples_description: |
    ```ruby
    # The `no_space` style enforces that parentheses do not have spaces.

    # bad
    f( 3)
    g = (a + 3 )

    # good
    f(3)
    g = (a + 3)# The `space` style enforces that parentheses have a space at the
    # beginning and end.
    # Note: Empty parentheses should not have spaces.

    # bad
    f(3)
    g = (a + 3)
    y( )

    # good
    f( 3 )
    g = ( a + 3 )
    y()
    ```
  :configuration:
    Description: No spaces after ( or before ).
    StyleGuide: "#spaces-braces"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: no_space
    SupportedStyles:
    - space
    - no_space
- :name: Layout/SpaceInsidePercentLiteralDelimiters
  :department_name: Layout
  :description: |-
    Checks for unnecessary additional spaces inside the delimiters of
    %i/%w/%x literals.
  :examples_description: |
    ```ruby

    # good
    %i(foo bar baz)

    # bad
    %w( foo bar baz )

    # bad
    %x(  ls -l )
    ```
  :configuration:
    Description: No unnecessary spaces inside delimiters of %i/%w/%x literals.
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceInsideRangeLiteral
  :department_name: Layout
  :description: Checks for spaces inside range literals.
  :examples_description: |
    ```ruby
    # bad
    1 .. 3

    # good
    1..3

    # bad
    'a' .. 'z'

    # good
    'a'..'z'
    ```
  :configuration:
    Description: No spaces inside range literals.
    StyleGuide: "#no-space-inside-range-literals"
    Enabled: true
  :configurable_attributes: {}
- :name: Layout/SpaceInsideReferenceBrackets
  :department_name: Layout
  :description: |-
    Checks that reference brackets have or don't have
    surrounding space depending on configuration.
  :examples_description: |
    ```ruby
    # The `no_space` style enforces that reference brackets have
    # no surrounding space.

    # bad
    hash[ :key ]
    array[ index ]

    # good
    hash[:key]
    array[index]# The `space` style enforces that reference brackets have
    # surrounding space.

    # bad
    hash[:key]
    array[index]

    # good
    hash[ :key ]
    array[ index ]# The `no_space` EnforcedStyleForEmptyBrackets style enforces that
    # empty reference brackets do not contain spaces.

    # bad
    foo[ ]
    foo[     ]

    # good
    foo[]# The `space` EnforcedStyleForEmptyBrackets style enforces that
    # empty reference brackets contain exactly one space.

    # bad
    foo[]
    foo[    ]

    # good
    foo[ ]
    ```
  :configuration:
    Description: Checks the spacing inside referential brackets.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: no_space
    SupportedStyles:
    - space
    - no_space
    EnforcedStyleForEmptyBrackets: no_space
    SupportedStylesForEmptyBrackets:
    - space
    - no_space
- :name: Layout/SpaceInsideStringInterpolation
  :department_name: Layout
  :description: This cop checks for whitespace within string interpolations.
  :examples_description: |
    ```ruby
    # bad
       var = "This is the #{ space } example"

    # good
       var = "This is the #{no_space} example"# bad
       var = "This is the #{no_space} example"

    # good
       var = "This is the #{ space } example"
    ```
  :configuration:
    Description: Checks for padding/surrounding spaces inside string interpolation.
    StyleGuide: "#string-interpolation"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: no_space
    SupportedStyles:
    - space
    - no_space
- :name: Layout/Tab
  :department_name: Layout
  :description: This cop checks for tabs inside the source code.
  :examples_description: |
    ```ruby
    # bad
    # This example uses a tab to indent bar.
    def foo
      bar
    end

    # good
    # This example uses spaces to indent bar.
    def foo
      bar
    end
    ```
  :configuration:
    Description: No hard tabs.
    StyleGuide: "#spaces-indentation"
    Enabled: true
  :configurable_attributes:
    IndentationWidth: ''
- :name: Layout/TrailingBlankLines
  :department_name: Layout
  :description: |-
    This cop looks for trailing blank lines and a final newline in the
    source code.
  :examples_description: |
    ```ruby
    # `final_blank_line` looks for one blank line followed by a new line
    # at the end of files.

    # bad
    class Foo; end
    # EOF

    # bad
    class Foo; end # EOF

    # good
    class Foo; end

    # EOF# `final_newline` looks for one newline at the end of files.

    # bad
    class Foo; end

    # EOF

    # bad
    class Foo; end # EOF

    # good
    class Foo; end
    # EOF
    ```
  :configuration:
    Description: Checks trailing blank lines and final newline.
    StyleGuide: "#newline-eof"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: final_newline
    SupportedStyles:
    - final_newline
    - final_blank_line
- :name: Layout/TrailingWhitespace
  :department_name: Layout
  :description: This cop looks for trailing whitespace in the source code.
  :examples_description: |
    ```ruby
    # The line in this example contains spaces after the 0.
    # bad
    x = 0

    # The line in this example ends directly after the 0.
    # good
    x = 0
    ```
  :configuration:
    Description: Avoid trailing whitespace.
    StyleGuide: "#no-trailing-whitespace"
    Enabled: true
  :configurable_attributes:
    AllowInHeredoc: 'false'
- :name: Lint/AmbiguousBlockAssociation
  :department_name: Lint
  :description: |-
    This cop checks for ambiguous block association with method
    when param passed without parentheses.
  :examples_description: |
    ```ruby

    # bad
    some_method a { |val| puts val }
    # good
    # With parentheses, there's no ambiguity.
    some_method(a) { |val| puts val }

    # good
    # Operator methods require no disambiguation
    foo == bar { |b| b.baz }

    # good
    # Lambda arguments require no disambiguation
    foo = ->(bar) { bar.baz }
    ```
  :configuration:
    Description: Checks for ambiguous block association with method when param passed
      without parentheses.
    StyleGuide: "#syntax"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/AmbiguousOperator
  :department_name: Lint
  :description: |-
    This cop checks for ambiguous operators in the first argument of a
    method invocation without parentheses.
  :examples_description: |
    ```ruby

    # bad

    # The `*` is interpreted as a splat operator but it could possibly be
    # a `*` method invocation (i.e. `do_something.*(some_array)`).
    do_something *some_array
    # good

    # With parentheses, there's no ambiguity.
    do_something(*some_array)
    ```
  :configuration:
    Description: Checks for ambiguous operators in the first argument of a method
      invocation without parentheses.
    StyleGuide: "#method-invocation-parens"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/AmbiguousRegexpLiteral
  :department_name: Lint
  :description: |-
    This cop checks for ambiguous regexp literals in the first argument of
    a method invocation without parentheses.
  :examples_description: |
    ```ruby

    # bad

    # This is interpreted as a method invocation with a regexp literal,
    # but it could possibly be `/` method invocations.
    # (i.e. `do_something./(pattern)./(i)`)
    do_something /pattern/i
    # good

    # With parentheses, there's no ambiguity.
    do_something(/pattern/i)
    ```
  :configuration:
    Description: Checks for ambiguous regexp literals in the first argument of a method
      invocation without parentheses.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/AssignmentInCondition
  :department_name: Lint
  :description: |-
    This cop checks for assignments in the conditions of
    if/while/until.
  :examples_description: |
    ```ruby

    # bad

    if some_var = true
      do_something
    end
    # good

    if some_var == true
      do_something
    end
    ```
  :configuration:
    Description: Don't use assignment in conditions.
    StyleGuide: "#safe-assignment-in-condition"
    Enabled: true
  :configurable_attributes:
    AllowSafeAssignment: 'true'
- :name: Lint/BigDecimalNew
  :department_name: Lint
  :description: |-
    `BigDecimal.new()` is deprecated since BigDecimal 1.3.3.
    This cop identifies places where `BigDecimal.new()`
    can be replaced by `BigDecimal()`.
  :examples_description: |
    ```ruby
    # bad
    BigDecimal.new(123.456, 3)

    # good
    BigDecimal(123.456, 3)
    ```
  :configuration:
    Description: "`BigDecimal.new()` is deprecated. Use `BigDecimal()` instead."
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/BooleanSymbol
  :department_name: Lint
  :description: |-
    This cop checks for `:true` and `:false` symbols.
    In most cases it would be a typo.
  :examples_description: |
    ```ruby

    # bad
    :true

    # good
    true
    # bad
    :false

    # good
    false
    ```
  :configuration:
    Description: Check for `:true` and `:false` symbols.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/CircularArgumentReference
  :department_name: Lint
  :description: |-
    This cop checks for circular argument references in optional keyword
    arguments and optional ordinal arguments.

    This cop mirrors a warning produced by MRI since 2.2.
  :examples_description: |
    ```ruby

    # bad

    def bake(pie: pie)
      pie.heat_up
    end
    # good

    def bake(pie:)
      pie.refrigerate
    end
    # good

    def bake(pie: self.pie)
      pie.feed_to(user)
    end
    # bad

    def cook(dry_ingredients = dry_ingredients)
      dry_ingredients.reduce(&:+)
    end
    # good

    def cook(dry_ingredients = self.dry_ingredients)
      dry_ingredients.combine
    end
    ```
  :configuration:
    Description: Default values in optional keyword arguments and optional ordinal
      arguments should not refer back to the name of the argument.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/Debugger
  :department_name: Lint
  :description: This cop checks for calls to debugger or pry.
  :examples_description: |
    ```ruby

    # bad (ok during development)

    # using pry
    def some_method
      binding.pry
      do_something
    end
    # bad (ok during development)

    # using byebug
    def some_method
      byebug
      do_something
    end
    # good

    def some_method
      do_something
    end
    ```
  :configuration:
    Description: Check for debugger calls.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/DeprecatedClassMethods
  :department_name: Lint
  :description: This cop checks for uses of the deprecated class method usages.
  :examples_description: |
    ```ruby

    # bad

    File.exists?(some_path)
    # good

    File.exist?(some_path)
    ```
  :configuration:
    Description: Check for deprecated class method calls.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/DuplicateCaseCondition
  :department_name: Lint
  :description: |-
    This cop checks that there are no repeated conditions
    used in case 'when' expressions.
  :examples_description: |
    ```ruby

    # bad

    case x
    when 'first'
      do_something
    when 'first'
      do_something_else
    end
    # good

    case x
    when 'first'
      do_something
    when 'second'
      do_something_else
    end
    ```
  :configuration:
    Description: Do not repeat values in case conditionals.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/DuplicateMethods
  :department_name: Lint
  :description: |-
    This cop checks for duplicated instance (or singleton) method
    definitions.
  :examples_description: |
    ```ruby

    # bad

    def foo
      1
    end

    def foo
      2
    end
    # bad

    def foo
      1
    end

    alias foo bar
    # good

    def foo
      1
    end

    def bar
      2
    end
    # good

    def foo
      1
    end

    alias bar foo
    ```
  :configuration:
    Description: Check for duplicate method definitions.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/DuplicatedKey
  :department_name: Lint
  :description: |-
    This cop checks for duplicated keys in hash literals.

    This cop mirrors a warning in Ruby 2.2.
  :examples_description: |
    ```ruby

    # bad

    hash = { food: 'apple', food: 'orange' }
    # good

    hash = { food: 'apple', other_food: 'orange' }
    ```
  :configuration:
    Description: Check for duplicate keys in hash literals.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/EachWithObjectArgument
  :department_name: Lint
  :description: |-
    This cop checks if each_with_object is called with an immutable
    argument. Since the argument is the object that the given block shall
    make calls on to build something based on the enumerable that
    each_with_object iterates over, an immutable argument makes no sense.
    It's definitely a bug.
  :examples_description: |
    ```ruby

    # bad

    sum = numbers.each_with_object(0) { |e, a| a += e }
    # good

    num = 0
    sum = numbers.each_with_object(num) { |e, a| a += e }
    ```
  :configuration:
    Description: Check for immutable argument given to each_with_object.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/ElseLayout
  :department_name: Lint
  :description: |-
    This cop checks for odd else block layout - like
    having an expression on the same line as the else keyword,
    which is usually a mistake.
  :examples_description: |
    ```ruby

    # bad

    if something
      # ...
    else do_this
      do_that
    end
    # good

    if something
      # ...
    else
      do_this
      do_that
    end
    ```
  :configuration:
    Description: Check for odd code arrangement in an else block.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/EmptyEnsure
  :department_name: Lint
  :description: This cop checks for empty `ensure` blocks
  :examples_description: |
    ```ruby

    # bad

    def some_method
      do_something
    ensure
    end
    # bad

    begin
      do_something
    ensure
    end
    # good

    def some_method
      do_something
    ensure
      do_something_else
    end
    # good

    begin
      do_something
    ensure
      do_something_else
    end
    ```
  :configuration:
    Description: Checks for empty ensure block.
    Enabled: true
  :configurable_attributes:
    AutoCorrect: 'false'
- :name: Lint/EmptyExpression
  :department_name: Lint
  :description: This cop checks for the presence of empty expressions.
  :examples_description: |
    ```ruby

    # bad

    foo = ()
    if ()
      bar
    end
    # good

    foo = (some_expression)
    if (some_expression)
      bar
    end
    ```
  :configuration:
    Description: Checks for empty expressions.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/EmptyInterpolation
  :department_name: Lint
  :description: This cop checks for empty interpolation.
  :examples_description: |
    ```ruby

    # bad

    "result is #{}"
    # good

    "result is #{some_result}"
    ```
  :configuration:
    Description: Checks for empty string interpolation.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/EmptyWhen
  :department_name: Lint
  :description: This cop checks for the presence of `when` branches without a body.
  :examples_description: |
    ```ruby

    # bad

    case foo
    when bar then 1
    when baz then # nothing
    end
    # good

    case foo
    when bar then 1
    when baz then 2
    end
    ```
  :configuration:
    Description: Checks for `when` branches with empty bodies.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/EndInMethod
  :department_name: Lint
  :description: This cop checks for END blocks in method definitions.
  :examples_description: |
    ```ruby

    # bad

    def some_method
      END { do_something }
    end
    # good

    def some_method
      at_exit { do_something }
    end
    # good

    # outside defs
    END { do_something }
    ```
  :configuration:
    Description: END blocks should not be placed inside method definitions.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/EnsureReturn
  :department_name: Lint
  :description: This cop checks for *return* from an *ensure* block.
  :examples_description: |
    ```ruby

    # bad

    begin
      do_something
    ensure
      do_something_else
      return
    end
    # good

    begin
      do_something
    ensure
      do_something_else
    end
    ```
  :configuration:
    Description: Do not use return in an ensure block.
    StyleGuide: "#no-return-ensure"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/FloatOutOfRange
  :department_name: Lint
  :description: |-
    This cop identifies Float literals which are, like, really really really
    really really really really really big. Too big. No-one needs Floats
    that big. If you need a float that big, something is wrong with you.
  :examples_description: |
    ```ruby

    # bad

    float = 3.0e400
    # good

    float = 42.9
    ```
  :configuration:
    Description: Catches floating-point literals too large or small for Ruby to represent.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/FormatParameterMismatch
  :department_name: Lint
  :description: |-
    This lint sees if there is a mismatch between the number of
    expected fields for format/sprintf/#% and what is actually
    passed as arguments.
  :examples_description: |
    ```ruby

    # bad

    format('A value: %s and another: %i', a_value)
    # good

    format('A value: %s and another: %i', a_value, another)
    ```
  :configuration:
    Description: The number of parameters to format/sprint must match the fields.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/HandleExceptions
  :department_name: Lint
  :description: This cop checks for *rescue* blocks with no body.
  :examples_description: |
    ```ruby

    # bad

    def some_method
      do_something
    rescue
      # do nothing
    end
    # bad

    begin
      do_something
    rescue
      # do nothing
    end
    # good

    def some_method
      do_something
    rescue
      handle_exception
    end
    # good

    begin
      do_something
    rescue
      handle_exception
    end
    ```
  :configuration:
    Description: Don't suppress exception.
    StyleGuide: "#dont-hide-exceptions"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/ImplicitStringConcatenation
  :department_name: Lint
  :description: |-
    This cop checks for implicit string concatenation of string literals
    which are on the same line.
  :examples_description: |
    ```ruby

    # bad

    array = ['Item 1' 'Item 2']
    # good

    array = ['Item 1Item 2']
    array = ['Item 1' + 'Item 2']
    array = [
      'Item 1' \
      'Item 2'
    ]
    ```
  :configuration:
    Description: Checks for adjacent string literals on the same line, which could
      better be represented as a single string literal.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/InheritException
  :department_name: Lint
  :description: |-
    This cop looks for error classes inheriting from `Exception`
    and its standard library subclasses, excluding subclasses of
    `StandardError`. It is configurable to suggest using either
    `RuntimeError` (default) or `StandardError` instead.
  :examples_description: |
    ```ruby
    # bad

    class C < Exception; end

    # good

    class C < RuntimeError; end# bad

    class C < Exception; end

    # good

    class C < StandardError; end
    ```
  :configuration:
    Description: Avoid inheriting from the `Exception` class.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: runtime_error
    SupportedStyles:
    - runtime_error
    - standard_error
- :name: Lint/IneffectiveAccessModifier
  :department_name: Lint
  :description: |-
    This cop checks for `private` or `protected` access modifiers which are
    applied to a singleton method. These access modifiers do not make
    singleton methods private/protected. `private_class_method` can be
    used for that.
  :examples_description: |
    ```ruby

    # bad

    class C
      private

      def self.method
        puts 'hi'
      end
    end
    # good

    class C
      def self.method
        puts 'hi'
      end

      private_class_method :method
    end
    # good

    class C
      class << self
        private

        def method
          puts 'hi'
        end
      end
    end
    ```
  :configuration:
    Description: Checks for attempts to use `private` or `protected` to set the visibility
      of a class method, which does not work.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/InterpolationCheck
  :department_name: Lint
  :description: This cop checks for interpolation in a single quoted string.
  :examples_description: |
    ```ruby

    # bad

    foo = 'something with #{interpolation} inside'
    # good

    foo = "something with #{interpolation} inside"
    ```
  :configuration:
    Description: Raise warning for interpolation in single q strs
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/LiteralAsCondition
  :department_name: Lint
  :description: |-
    This cop checks for literals used as the conditions or as
    operands in and/or expressions serving as the conditions of
    if/while/until.
  :examples_description: |
    ```ruby

    # bad

    if 20
      do_something
    end
    # bad

    if some_var && true
      do_something
    end
    # good

    if some_var && some_condition
      do_something
    end
    ```
  :configuration:
    Description: Checks of literals used in conditions.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/LiteralInInterpolation
  :department_name: Lint
  :description: This cop checks for interpolated literals.
  :examples_description: |
    ```ruby

    # bad

    "result is #{10}"
    # good

    "result is 10"
    ```
  :configuration:
    Description: Checks for literals used in interpolation.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/Loop
  :department_name: Lint
  :description: This cop checks for uses of *begin...end while/until something*.
  :examples_description: |
    ```ruby

    # bad

    # using while
    begin
      do_something
    end while some_condition
    # bad

    # using until
    begin
      do_something
    end until some_condition
    # good

    # using while
    while some_condition
      do_something
    end
    # good

    # using until
    until some_condition
      do_something
    end
    ```
  :configuration:
    Description: Use Kernel#loop with break rather than begin/end/until or begin/end/while
      for post-loop tests.
    StyleGuide: "#loop-with-break"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/MissingCopEnableDirective
  :department_name: Lint
  :description: |-
    This cop checks that there is an `# rubocop:enable ...` statement
    after a `# rubocop:disable ...` statement. This will prevent leaving
    cop disables on wide ranges of code, that latter contributors to
    a file wouldn't be aware of.
  :examples_description: |
    ```ruby
    # Lint/MissingCopEnableDirective:
    #   MaximumRangeSize: .inf

    # good
    # rubocop:disable Layout/SpaceAroundOperators
    x= 0
    # rubocop:enable Layout/SpaceAroundOperators
    # y = 1
    # EOF

    # bad
    # rubocop:disable Layout/SpaceAroundOperators
    x= 0
    # EOF# Lint/MissingCopEnableDirective:
    #   MaximumRangeSize: 2

    # good
    # rubocop:disable Layout/SpaceAroundOperators
    x= 0
    # With the previous, there are 2 lines on which cop is disabled.
    # rubocop:enable Layout/SpaceAroundOperators

    # bad
    # rubocop:disable Layout/SpaceAroundOperators
    x= 0
    x += 1
    # Including this, that's 3 lines on which the cop is disabled.
    # rubocop:enable Layout/SpaceAroundOperators
    ```
  :configuration:
    Description: Checks for a `# rubocop:enable` after `# rubocop:disable`
    Enabled: true
  :configurable_attributes:
    MaximumRangeSize: Infinity
- :name: Lint/MultipleCompare
  :department_name: Lint
  :description: |-
    In math and Python, we can use `x < y < z` style comparison to compare
    multiple value. However, we can't use the comparison in Ruby. However,
    the comparison is not syntax error. This cop checks the bad usage of
    comparison operators.
  :examples_description: |
    ```ruby

    # bad

    x < y < z
    10 <= x <= 20
    # good

    x < y && y < z
    10 <= x && x <= 20
    ```
  :configuration:
    Description: Use `&&` operator to compare multiple value.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/NestedMethodDefinition
  :department_name: Lint
  :description: This cop checks for nested method definitions.
  :examples_description: |
    ```ruby

    # bad

    # `bar` definition actually produces methods in the same scope
    # as the outer `foo` method. Furthermore, the `bar` method
    # will be redefined every time `foo` is invoked.
    def foo
      def bar
      end
    end
    # good

    def foo
      bar = -> { puts 'hello' }
      bar.call
    end
    # good

    def foo
      self.class_eval do
        def bar
        end
      end
    end

    def foo
      self.module_exec do
        def bar
        end
      end
    end
    # good

    def foo
      class << self
        def bar
        end
      end
    end
    ```
  :configuration:
    Description: Do not use nested method definitions.
    StyleGuide: "#no-nested-methods"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/NestedPercentLiteral
  :department_name: Lint
  :description: This cop checks for nested percent literals.
  :examples_description: |
    ```ruby

    # bad

    # The percent literal for nested_attributes is parsed as four tokens,
    # yielding the array [:name, :content, :"%i[incorrectly", :"nested]"].
    attributes = {
      valid_attributes: %i[name content],
      nested_attributes: %i[name content %i[incorrectly nested]]
    }
    ```
  :configuration:
    Description: Checks for nested percent literals.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/NextWithoutAccumulator
  :department_name: Lint
  :description: Don't omit the accumulator when calling `next` in a `reduce` block.
  :examples_description: |
    ```ruby

    # bad

    result = (1..4).reduce(0) do |acc, i|
      next if i.odd?
      acc + i
    end
    # good

    result = (1..4).reduce(0) do |acc, i|
      next acc if i.odd?
      acc + i
    end
    ```
  :configuration:
    Description: Do not omit the accumulator when calling `next` in a `reduce`/`inject`
      block.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/NonLocalExitFromIterator
  :department_name: Lint
  :description: |-
    This cop checks for non-local exits from iterators without a return
    value. It registers an offense under these conditions:

     - No value is returned,
     - the block is preceded by a method chain,
     - the block has arguments,
     - the method which receives the block is not `define_method`
       or `define_singleton_method`,
     - the return is not contained in an inner scope, e.g. a lambda or a
       method definition.
  :examples_description: |
    ```ruby

    class ItemApi
      rescue_from ValidationError do |e| # non-iteration block with arg
        return { message: 'validation error' } unless e.errors # allowed
        error_array = e.errors.map do |error| # block with method chain
          return if error.suppress? # warned
          return "#{error.param}: invalid" unless error.message # allowed
          "#{error.param}: #{error.message}"
        end
        { message: 'validation error', errors: error_array }
      end

      def update_items
        transaction do # block without arguments
          return unless update_necessary? # allowed
          find_each do |item| # block without method chain
            return if item.stock == 0 # false-negative...
            item.update!(foobar: true)
          end
        end
      end
    end
    ```
  :configuration:
    Description: Do not use return in iterator to cause non-local exit.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/NumberConversion
  :department_name: Lint
  :description: |-
    This cop warns the usage of unsafe number conversions. Unsafe
    number conversion can cause unexpected error if auto type conversion
    fails. Cop prefer parsing with number class instead.
  :examples_description: |
    ```ruby

    # bad

    '10'.to_i
    '10.2'.to_f
    '10'.to_c

    # good

    Integer('10', 10)
    Float('10.2')
    Complex('10')
    ```
  :configuration:
    Description: Checks unsafe usage of number conversion methods.
    Enabled: false
  :configurable_attributes: {}
- :name: Lint/OrderedMagicComments
  :department_name: Lint
  :description: |-
    Checks the proper ordering of magic comments and whether
    a magic comment is not placed before a shebang.
  :examples_description: |
    ```ruby
    # bad

    # frozen_string_literal: true
    # encoding: ascii
    p [''.frozen?, ''.encoding] #=> [true, #<Encoding:UTF-8>]

    # good

    # encoding: ascii
    # frozen_string_literal: true
    p [''.frozen?, ''.encoding] #=> [true, #<Encoding:US-ASCII>]

    # good

    #!/usr/bin/env ruby
    # encoding: ascii
    # frozen_string_literal: true
    p [''.frozen?, ''.encoding] #=> [true, #<Encoding:US-ASCII>]
    ```
  :configuration:
    Description: Checks the proper ordering of magic comments and whether a magic
      comment is not placed before a shebang.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/ParenthesesAsGroupedExpression
  :department_name: Lint
  :description: |-
    Checks for space between the name of a called method and a left
    parenthesis.
  :examples_description: |
    ```ruby

    # bad

    puts (x + y)
    # good

    puts(x + y)
    ```
  :configuration:
    Description: Checks for method calls with a space before the opening parenthesis.
    StyleGuide: "#parens-no-spaces"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/PercentStringArray
  :department_name: Lint
  :description: |-
    This cop checks for quotes and commas in %w, e.g. `%w('foo', "bar")`

    It is more likely that the additional characters are unintended (for
    example, mistranslating an array of literals to percent string notation)
    rather than meant to be part of the resulting strings.
  :examples_description: |
    ```ruby

    # bad

    %w('foo', "bar")
    # good

    %w(foo bar)
    ```
  :configuration:
    Description: Checks for unwanted commas and quotes in %w/%W literals.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/PercentSymbolArray
  :department_name: Lint
  :description: |-
    This cop checks for colons and commas in %i, e.g. `%i(:foo, :bar)`

    It is more likely that the additional characters are unintended (for
    example, mistranslating an array of literals to percent string notation)
    rather than meant to be part of the resulting symbols.
  :examples_description: |
    ```ruby

    # bad

    %i(:foo, :bar)
    # good

    %i(foo bar)
    ```
  :configuration:
    Description: Checks for unwanted commas and colons in %i/%I literals.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/RandOne
  :department_name: Lint
  :description: |-
    This cop checks for `rand(1)` calls.
    Such calls always return `0`.
  :examples_description: |
    ```ruby

    # bad

    rand 1
    Kernel.rand(-1)
    rand 1.0
    rand(-1.0)
    # good

    0 # just use 0 instead
    ```
  :configuration:
    Description: Checks for `rand(1)` calls. Such calls always return `0` and most
      likely a mistake.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/RedundantWithIndex
  :department_name: Lint
  :description: This cop checks for redundant `with_index`.
  :examples_description: |
    ```ruby
    # bad
    ary.each_with_index do |v|
      v
    end

    # good
    ary.each do |v|
      v
    end

    # bad
    ary.each.with_index do |v|
      v
    end

    # good
    ary.each do |v|
      v
    end
    ```
  :configuration:
    Description: Checks for redundant `with_index`.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/RedundantWithObject
  :department_name: Lint
  :description: This cop checks for redundant `with_object`.
  :examples_description: |
    ```ruby
    # bad
    ary.each_with_object([]) do |v|
      v
    end

    # good
    ary.each do |v|
      v
    end

    # bad
    ary.each.with_object([]) do |v|
      v
    end

    # good
    ary.each do |v|
      v
    end
    ```
  :configuration:
    Description: Checks for redundant `with_object`.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/RegexpAsCondition
  :department_name: Lint
  :description: |-
    This cop checks for regexp literals used as `match-current-line`.
    If a regexp literal is in condition, the regexp matches `$_` implicitly.
  :examples_description: |
    ```ruby
    # bad
    if /foo/
      do_something
    end

    # good
    if /foo/ =~ $_
      do_something
    end
    ```
  :configuration:
    Description: Do not use regexp literal as a condition. The regexp literal matches
      `$_` implicitly.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/RequireParentheses
  :department_name: Lint
  :description: |-
    This cop checks for expressions where there is a call to a predicate
    method with at least one argument, where no parentheses are used around
    the parameter list, and a boolean operator, && or ||, is used in the
    last argument.

    The idea behind warning for these constructs is that the user might
    be under the impression that the return value from the method call is
    an operand of &&/||.
  :examples_description: |
    ```ruby

    # bad

    if day.is? :tuesday && month == :jan
      # ...
    end
    # good

    if day.is?(:tuesday) && month == :jan
      # ...
    end
    ```
  :configuration:
    Description: Use parentheses in the method call to avoid confusion about precedence.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/RescueException
  :department_name: Lint
  :description: This cop checks for *rescue* blocks targeting the Exception class.
  :examples_description: |
    ```ruby

    # bad

    begin
      do_something
    rescue Exception
      handle_exception
    end
    # good

    begin
      do_something
    rescue ArgumentError
      handle_exception
    end
    ```
  :configuration:
    Description: Avoid rescuing the Exception class.
    StyleGuide: "#no-blind-rescues"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/RescueType
  :department_name: Lint
  :description: |-
    Check for arguments to `rescue` that will result in a `TypeError`
    if an exception is raised.
  :examples_description: |
    ```ruby
    # bad
    begin
      bar
    rescue nil
      baz
    end

    # bad
    def foo
      bar
    rescue 1, 'a', "#{b}", 0.0, [], {}
      baz
    end

    # good
    begin
      bar
    rescue
      baz
    end

    # good
    def foo
      bar
    rescue NameError
      baz
    end
    ```
  :configuration:
    Description: Avoid rescuing from non constants that could result in a `TypeError`.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/ReturnInVoidContext
  :department_name: Lint
  :description: |-
    This cop checks for the use of a return with a value in a context
    where the value will be ignored. (initialize and setter methods)
  :examples_description: |
    ```ruby

    # bad
    def initialize
      foo
      return :qux if bar?
      baz
    end

    def foo=(bar)
      return 42
    end
    # good
    def initialize
      foo
      return if bar?
      baz
    end

    def foo=(bar)
      return
    end
    ```
  :configuration:
    Description: Checks for return in void context.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/SafeNavigationConsistency
  :department_name: Lint
  :description: |-
    This cop check to make sure that if safe navigation is used for a method
    call in an `&&` or `||` condition that safe navigation is used for all
    method calls on that same object.
  :examples_description: |
    ```ruby
    # bad
    foo&.bar && foo.baz

    # bad
    foo.bar || foo&.baz

    # bad
    foo&.bar && (foobar.baz || foo.baz)

    # good
    foo.bar && foo.baz

    # good
    foo&.bar || foo&.baz

    # good
    foo&.bar && (foobar.baz || foo&.baz)
    ```
  :configuration:
    Description: Check to make sure that if safe navigation is used for a method call
      in an `&&` or `||` condition that safe navigation is used for all method calls
      on that same object.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/SafeNavigationChain
  :department_name: Lint
  :description: |-
    The safe navigation operator returns nil if the receiver is
    nil.  If you chain an ordinary method call after a safe
    navigation operator, it raises NoMethodError.  We should use a
    safe navigation operator after a safe navigation operator.
    This cop checks for the problem outlined above.
  :examples_description: |
    ```ruby

    # bad

    x&.foo.bar
    x&.foo + bar
    x&.foo[bar]
    # good

    x&.foo&.bar
    x&.foo || bar
    ```
  :configuration:
    Description: Do not chain ordinary method call after safe navigation operator.
    Enabled: true
  :configurable_attributes:
    Whitelist:
    - present?
    - blank?
    - presence
    - try
- :name: Lint/ScriptPermission
  :department_name: Lint
  :description: |-
    This cop checks if a file which has a shebang line as
    its first line is granted execute permission.
  :examples_description: |
    ```ruby
    # bad

    # A file which has a shebang line as its first line is not
    # granted execute permission.

    #!/usr/bin/env ruby
    puts 'hello, world'

    # good

    # A file which has a shebang line as its first line is
    # granted execute permission.

    #!/usr/bin/env ruby
    puts 'hello, world'

    # good

    # A file which has not a shebang line as its first line is not
    # granted execute permission.

    puts 'hello, world'
    ```
  :configuration:
    Description: Grant script file execute permission.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/ShadowedArgument
  :department_name: Lint
  :description: This cop checks for shadowed arguments.
  :examples_description: |
    ```ruby

    # bad

    do_something do |foo|
      foo = 42
      puts foo
    end

    def do_something(foo)
      foo = 42
      puts foo
    end
    # good

    do_something do |foo|
      foo = foo + 42
      puts foo
    end

    def do_something(foo)
      foo = foo + 42
      puts foo
    end

    def do_something(foo)
      puts foo
    end
    ```
  :configuration:
    Description: Avoid reassigning arguments before they were used.
    Enabled: true
  :configurable_attributes:
    IgnoreImplicitReferences: 'false'
- :name: Lint/ShadowedException
  :department_name: Lint
  :description: |-
    This cop checks for a rescued exception that get shadowed by a
    less specific exception being rescued before a more specific
    exception is rescued.
  :examples_description: |
    ```ruby

    # bad

    begin
      something
    rescue Exception
      handle_exception
    rescue StandardError
      handle_standard_error
    end

    # good

    begin
      something
    rescue StandardError
      handle_standard_error
    rescue Exception
      handle_exception
    end

    # good, however depending on runtime environment.
    #
    # This is a special case for system call errors.
    # System dependent error code depends on runtime environment.
    # For example, whether `Errno::EAGAIN` and `Errno::EWOULDBLOCK` are
    # the same error code or different error code depends on environment.
    # This good case is for `Errno::EAGAIN` and `Errno::EWOULDBLOCK` with
    # the same error code.
    begin
      something
    rescue Errno::EAGAIN, Errno::EWOULDBLOCK
      handle_standard_error
    end
    ```
  :configuration:
    Description: Avoid rescuing a higher level exception before a lower level exception.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/ShadowingOuterLocalVariable
  :department_name: Lint
  :description: |-
    This cop looks for use of the same name as outer local variables
    for block arguments or block local variables.
    This is a mimic of the warning
    "shadowing outer local variable - foo" from `ruby -cw`.
  :examples_description: |
    ```ruby

    # bad

    def some_method
      foo = 1

      2.times do |foo| # shadowing outer `foo`
        do_something(foo)
      end
    end
    # good

    def some_method
      foo = 1

      2.times do |bar|
        do_something(bar)
      end
    end
    ```
  :configuration:
    Description: Do not use the same name as outer local variable for block arguments
      or block local variables.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/StringConversionInInterpolation
  :department_name: Lint
  :description: |-
    This cop checks for string conversion in string interpolation,
    which is redundant.
  :examples_description: |
    ```ruby

    # bad

    "result is #{something.to_s}"
    # good

    "result is #{something}"
    ```
  :configuration:
    Description: Checks for Object#to_s usage in string interpolation.
    StyleGuide: "#no-to-s"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/Syntax
  :department_name: Lint
  :description: |-
    This is actually not a cop and inspects nothing. It just provides
    methods to repack Parser's diagnostics/errors into RuboCop's offenses.
  :examples_description: ''
  :configuration:
    Description: Checks syntax error
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UnderscorePrefixedVariableName
  :department_name: Lint
  :description: |-
    This cop checks for underscore-prefixed variables that are actually
    used.
  :examples_description: |
    ```ruby

    # bad

    [1, 2, 3].each do |_num|
      do_something(_num)
    end
    # good

    [1, 2, 3].each do |num|
      do_something(num)
    end
    # good

    [1, 2, 3].each do |_num|
      do_something # not using `_num`
    end
    ```
  :configuration:
    Description: Do not use prefix `_` for a variable that is used.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UnifiedInteger
  :department_name: Lint
  :description: This cop checks for using Fixnum or Bignum constant.
  :examples_description: |
    ```ruby

    # bad

    1.is_a?(Fixnum)
    1.is_a?(Bignum)
    # good

    1.is_a?(Integer)
    ```
  :configuration:
    Description: Use Integer instead of Fixnum or Bignum
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UnneededCopDisableDirective
  :department_name: Lint
  :description: |-
    This cop detects instances of rubocop:disable comments that can be
    removed without causing any offenses to be reported. It's implemented
    as a cop in that it inherits from the Cop base class and calls
    add_offense. The unusual part of its implementation is that it doesn't
    have any on_* methods or an investigate method. This means that it
    doesn't take part in the investigation phase when the other cops do
    their work. Instead, it waits until it's called in a later stage of the
    execution. The reason it can't be implemented as a normal cop is that
    it depends on the results of all other cops to do its work.
  :examples_description: |
    ```ruby
    # bad
    # rubocop:disable Metrics/LineLength
    x += 1
    # rubocop:enable Metrics/LineLength

    # good
    x += 1
    ```
  :configuration:
    Description: 'Checks for rubocop:disable comments that can be removed. Note: this
      cop is not disabled when disabling all cops. It must be explicitly disabled.'
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UnneededCopEnableDirective
  :department_name: Lint
  :description: |-
    This cop detects instances of rubocop:enable comments that can be
    removed.
  :examples_description: |
    ```ruby
    # bad
    foo = 1
    # rubocop:enable Metrics/LineLength

    # good
    foo = 1
    ```
  :configuration:
    Description: Checks for rubocop:enable comments that can be removed.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UnneededRequireStatement
  :department_name: Lint
  :description: |-
    Checks for unnecessary `require` statement.

    The following features are unnecessary `require` statement because
    they are already loaded.

    ruby -ve 'p $LOADED_FEATURES.reject { |feature| %r|/| =~ feature }'
    ruby 2.2.8p477 (2017-09-14 revision 59906) [x86_64-darwin13]
    ["enumerator.so", "rational.so", "complex.so", "thread.rb"]

    This cop targets Ruby 2.2 or higher containing these 4 features.
  :examples_description: |
    ```ruby
    # bad
    require 'unloaded_feature'
    require 'thread'

    # good
    require 'unloaded_feature'
    ```
  :configuration:
    Description: Checks for unnecessary `require` statement.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UnneededSplatExpansion
  :department_name: Lint
  :description: This cop checks for unneeded usages of splat expansion
  :examples_description: |
    ```ruby

    # bad

    a = *[1, 2, 3]
    a = *'a'
    a = *1

    begin
      foo
    rescue *[StandardError, ApplicationError]
      bar
    end

    case foo
    when *[1, 2, 3]
      bar
    else
      baz
    end
    # good

    c = [1, 2, 3]
    a = *c
    a, b = *c
    a, *b = *c
    a = *1..10
    a = ['a']

    begin
      foo
    rescue StandardError, ApplicationError
      bar
    end

    case foo
    when *[1, 2, 3]
      bar
    else
      baz
    end
    ```
  :configuration:
    Description: Checks for splat unnecessarily being called on literals
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UnreachableCode
  :department_name: Lint
  :description: |-
    This cop checks for unreachable code.
    The check are based on the presence of flow of control
    statement in non-final position in *begin*(implicit) blocks.
  :examples_description: |
    ```ruby

    # bad

    def some_method
      return
      do_something
    end

    # bad

    def some_method
      if cond
        return
      else
        return
      end
      do_something
    end
    # good

    def some_method
      do_something
    end
    ```
  :configuration:
    Description: Unreachable code.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UnusedBlockArgument
  :department_name: Lint
  :description: This cop checks for unused block arguments.
  :examples_description: |
    ```ruby

    # bad

    do_something do |used, unused|
      puts used
    end

    do_something do |bar|
      puts :foo
    end

    define_method(:foo) do |bar|
      puts :baz
    end
    #good

    do_something do |used, _unused|
      puts used
    end

    do_something do
      puts :foo
    end

    define_method(:foo) do |_bar|
      puts :baz
    end
    ```
  :configuration:
    Description: Checks for unused block arguments.
    StyleGuide: "#underscore-unused-vars"
    Enabled: true
  :configurable_attributes:
    IgnoreEmptyBlocks: 'true'
    AllowUnusedKeywordArguments: 'false'
- :name: Lint/UnusedMethodArgument
  :department_name: Lint
  :description: This cop checks for unused method arguments.
  :examples_description: |
    ```ruby

    # bad

    def some_method(used, unused, _unused_but_allowed)
      puts used
    end
    # good

    def some_method(used, _unused, _unused_but_allowed)
      puts used
    end
    ```
  :configuration:
    Description: Checks for unused method arguments.
    StyleGuide: "#underscore-unused-vars"
    Enabled: true
  :configurable_attributes:
    AllowUnusedKeywordArguments: 'false'
    IgnoreEmptyMethods: 'true'
- :name: Lint/UriEscapeUnescape
  :department_name: Lint
  :description: |-
    This cop identifies places where `URI.escape` can be replaced by
    `CGI.escape`, `URI.encode_www_form` or `URI.encode_www_form_component`
    depending on your specific use case.
    Also this cop identifies places where `URI.unescape` can be replaced by
    `CGI.unescape`, `URI.decode_www_form` or `URI.decode_www_form_component`
    depending on your specific use case.
  :examples_description: |
    ```ruby
    # bad
    URI.escape('http://example.com')
    URI.encode('http://example.com')

    # good
    CGI.escape('http://example.com')
    URI.encode_www_form([['example', 'param'], ['lang', 'en']])
    URI.encode_www_form(page: 10, locale: 'en')
    URI.encode_www_form_component('http://example.com')

    # bad
    URI.unescape(enc_uri)
    URI.decode(enc_uri)

    # good
    CGI.unescape(enc_uri)
    URI.decode_www_form(enc_uri)
    URI.decode_www_form_component(enc_uri)
    ```
  :configuration:
    Description: "`URI.escape` method is obsolete and should not be used. Instead,
      use `CGI.escape`, `URI.encode_www_form` or `URI.encode_www_form_component` depending
      on your specific use case. Also `URI.unescape` method is obsolete and should
      not be used. Instead, use `CGI.unescape`, `URI.decode_www_form` or `URI.decode_www_form_component`
      depending on your specific use case."
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UriRegexp
  :department_name: Lint
  :description: |-
    This cop identifies places where `URI.regexp` is obsolete and should
    not be used. Instead, use `URI::DEFAULT_PARSER.make_regexp`.
  :examples_description: |
    ```ruby
    # bad
    URI.regexp('http://example.com')

    # good
    URI::DEFAULT_PARSER.make_regexp('http://example.com')
    ```
  :configuration:
    Description: Use `URI::DEFAULT_PARSER.make_regexp` instead of `URI.regexp`.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UselessAccessModifier
  :department_name: Lint
  :description: |-
    This cop checks for redundant access modifiers, including those with no
    code, those which are repeated, and leading `public` modifiers in a
    class or module body. Conditionally-defined methods are considered as
    always being defined, and thus access modifiers guarding such methods
    are not redundant.
  :examples_description: |
    ```ruby

    class Foo
      public # this is redundant (default access is public)

      def method
      end

      private # this is not redundant (a method is defined)
      def method2
      end

      private # this is redundant (no following methods are defined)
    end
    class Foo
      # The following is not redundant (conditionally defined methods are
      # considered as always defining a method)
      private

      if condition?
        def method
        end
      end

      protected # this is not redundant (method is defined)

      define_method(:method2) do
      end

      protected # this is redundant (repeated from previous modifier)

      [1,2,3].each do |i|
        define_method("foo#{i}") do
        end
      end

      # The following is redundant (methods defined on the class'
      # singleton class are not affected by the public modifier)
      public

      def self.method3
      end
    end# Lint/UselessAccessModifier:
    #   ContextCreatingMethods:
    #     - concerning
    require 'active_support/concern'
    class Foo
      concerning :Bar do
        def some_public_method
        end

        private

        def some_private_method
        end
      end

      # this is not redundant because `concerning` created its own context
      private

      def some_other_private_method
      end
    end# Lint/UselessAccessModifier:
    #   MethodCreatingMethods:
    #     - delegate
    require 'active_support/core_ext/module/delegation'
    class Foo
      # this is not redundant because `delegate` creates methods
      private

      delegate :method_a, to: :method_b
    end
    ```
  :configuration:
    Description: Checks for useless access modifiers.
    Enabled: true
  :configurable_attributes:
    ContextCreatingMethods: []
    MethodCreatingMethods: []
- :name: Lint/UselessAssignment
  :department_name: Lint
  :description: |-
    This cop checks for every useless assignment to local variable in every
    scope.
    The basic idea for this cop was from the warning of `ruby -cw`:

      assigned but unused variable - foo

    Currently this cop has advanced logic that detects unreferenced
    reassignments and properly handles varied cases such as branch, loop,
    rescue, ensure, etc.
  :examples_description: |
    ```ruby

    # bad

    def some_method
      some_var = 1
      do_something
    end
    # good

    def some_method
      some_var = 1
      do_something(some_var)
    end
    ```
  :configuration:
    Description: Checks for useless assignment to a local variable.
    StyleGuide: "#underscore-unused-vars"
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UselessComparison
  :department_name: Lint
  :description: This cop checks for comparison of something with itself.
  :examples_description: |
    ```ruby

    # bad

    x.top >= x.top
    ```
  :configuration:
    Description: Checks for comparison of something with itself.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UselessElseWithoutRescue
  :department_name: Lint
  :description: This cop checks for useless `else` in `begin..end` without `rescue`.
  :examples_description: |
    ```ruby

    # bad

    begin
      do_something
    else
      do_something_else # This will never be run.
    end
    # good

    begin
      do_something
    rescue
      handle_errors
    else
      do_something_else
    end
    ```
  :configuration:
    Description: Checks for useless `else` in `begin..end` without `rescue`.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/UselessSetterCall
  :department_name: Lint
  :description: |-
    This cop checks for setter call to local variable as the final
    expression of a function definition.
  :examples_description: |
    ```ruby

    # bad

    def something
      x = Something.new
      x.attr = 5
    end
    # good

    def something
      x = Something.new
      x.attr = 5
      x
    end
    ```
  :configuration:
    Description: Checks for useless setter call to a local variable.
    Enabled: true
  :configurable_attributes: {}
- :name: Lint/Void
  :department_name: Lint
  :description: |-
    This cop checks for operators, variables, literals, and nonmutating
    methods used in void context.
  :examples_description: |
    ```ruby

    # bad

    def some_method
      some_num * 10
      do_something
    end
    # bad

    def some_method(some_var)
      some_var
      do_something
    end
    # bad, when CheckForMethodsWithNoSideEffects is set true

    def some_method(some_array)
      some_array.sort
      do_something(some_array)
    end
    # good

    def some_method
      do_something
      some_num * 10
    end
    # good

    def some_method(some_var)
      do_something
      some_var
    end
    # good, when CheckForMethodsWithNoSideEffects is set true

    def some_method(some_array)
      some_array.sort!
      do_something(some_array)
    end
    ```
  :configuration:
    Description: Possible use of operator/literal/variable in void context.
    Enabled: true
  :configurable_attributes:
    CheckForMethodsWithNoSideEffects: 'false'
- :name: Metrics/CyclomaticComplexity
  :department_name: Metrics
  :description: |-
    This cop checks that the cyclomatic complexity of methods is not higher
    than the configured maximum. The cyclomatic complexity is the number of
    linearly independent paths through a method. The algorithm counts
    decision points and adds one.

    An if statement (or unless or ?:) increases the complexity by one. An
    else branch does not, since it doesn't add a decision point. The &&
    operator (or keyword and) can be converted to a nested if statement,
    and ||/or is shorthand for a sequence of ifs, so they also add one.
    Loops can be said to have an exit condition, so they add one.
  :examples_description: ''
  :configuration:
    Description: A complexity metric that is strongly correlated to the number of
      test cases needed to validate a method.
    Enabled: true
  :configurable_attributes:
    Max: '6'
- :name: Metrics/AbcSize
  :department_name: Metrics
  :description: |-
    This cop checks that the ABC size of methods is not higher than the
    configured maximum. The ABC size is based on assignments, branches
    (method calls), and conditions. See http://c2.com/cgi/wiki?AbcMetric
  :examples_description: ''
  :configuration:
    Description: A calculated magnitude based on number of assignments, branches,
      and conditions.
    Reference: http://c2.com/cgi/wiki?AbcMetric
    Enabled: true
  :configurable_attributes:
    Max: '15'
- :name: Metrics/BlockLength
  :department_name: Metrics
  :description: |-
    This cop checks if the length of a block exceeds some maximum value.
    Comment lines can optionally be ignored.
    The maximum allowed length is configurable.
    The cop can be configured to ignore blocks passed to certain methods.
  :examples_description: ''
  :configuration:
    Description: Avoid long blocks with many lines.
    Enabled: true
  :configurable_attributes:
    CountComments: 'false'
    Max: '25'
    ExcludedMethods: []
- :name: Metrics/BlockNesting
  :department_name: Metrics
  :description: |-
    This cop checks for excessive nesting of conditional and looping
    constructs.

    You can configure if blocks are considered using the `CountBlocks`
    option. When set to `false` (the default) blocks are not counted
    towards the nesting level. Set to `true` to count blocks as well.

    The maximum level of nesting allowed is configurable.
  :examples_description: ''
  :configuration:
    Description: Avoid excessive block nesting
    StyleGuide: "#three-is-the-number-thou-shalt-count"
    Enabled: true
  :configurable_attributes:
    CountBlocks: 'false'
    Max: '3'
- :name: Metrics/ClassLength
  :department_name: Metrics
  :description: |-
    This cop checks if the length a class exceeds some maximum value.
    Comment lines can optionally be ignored.
    The maximum allowed length is configurable.
  :examples_description: ''
  :configuration:
    Description: Avoid classes longer than 100 lines of code.
    Enabled: true
  :configurable_attributes:
    CountComments: 'false'
    Max: '100'
- :name: Metrics/LineLength
  :department_name: Metrics
  :description: |-
    This cop checks the length of lines in the source code.
    The maximum length is configurable.
  :examples_description: ''
  :configuration:
    Description: Limit lines to 80 characters.
    StyleGuide: "#80-character-limits"
    Enabled: true
  :configurable_attributes:
    Max: '80'
    AllowHeredoc: 'true'
    AllowURI: 'true'
    URISchemes:
    - http
    - https
    IgnoreCopDirectives: 'false'
    IgnoredPatterns: []
- :name: Metrics/MethodLength
  :department_name: Metrics
  :description: |-
    This cop checks if the length of a method exceeds some maximum value.
    Comment lines can optionally be ignored.
    The maximum allowed length is configurable.
  :examples_description: ''
  :configuration:
    Description: Avoid methods longer than 10 lines of code.
    StyleGuide: "#short-methods"
    Enabled: true
  :configurable_attributes:
    CountComments: 'false'
    Max: '10'
- :name: Metrics/ModuleLength
  :department_name: Metrics
  :description: |-
    This cop checks if the length a module exceeds some maximum value.
    Comment lines can optionally be ignored.
    The maximum allowed length is configurable.
  :examples_description: ''
  :configuration:
    Description: Avoid modules longer than 100 lines of code.
    Enabled: true
  :configurable_attributes:
    CountComments: 'false'
    Max: '100'
- :name: Metrics/ParameterLists
  :department_name: Metrics
  :description: |-
    This cop checks for methods with too many parameters.
    The maximum number of parameters is configurable.
    Keyword arguments can optionally be excluded from the total count.
  :examples_description: ''
  :configuration:
    Description: Avoid parameter lists longer than three or four parameters.
    StyleGuide: "#too-many-params"
    Enabled: true
  :configurable_attributes:
    Max: '5'
    CountKeywordArgs: 'true'
- :name: Metrics/PerceivedComplexity
  :department_name: Metrics
  :description: |-
    This cop tries to produce a complexity score that's a measure of the
    complexity the reader experiences when looking at a method. For that
    reason it considers `when` nodes as something that doesn't add as much
    complexity as an `if` or a `&&`. Except if it's one of those special
    `case`/`when` constructs where there's no expression after `case`. Then
    the cop treats it as an `if`/`elsif`/`elsif`... and lets all the `when`
    nodes count. In contrast to the CyclomaticComplexity cop, this cop
    considers `else` nodes as adding complexity.
  :examples_description: |
    ```ruby

    def my_method                   # 1
      if cond                       # 1
        case var                    # 2 (0.8 + 4 * 0.2, rounded)
        when 1 then func_one
        when 2 then func_two
        when 3 then func_three
        when 4..10 then func_other
        end
      else                          # 1
        do_something until a && b   # 2
      end                           # ===
    end                             # 7 complexity points
    ```
  :configuration:
    Description: A complexity metric geared towards measuring complexity for a human
      reader.
    Enabled: true
  :configurable_attributes:
    Max: '7'
- :name: Naming/AccessorMethodName
  :department_name: Naming
  :description: This cop makes sure that accessor methods are named properly.
  :examples_description: |
    ```ruby
    # bad
    def set_attribute(value)
    end

    # good
    def attribute=(value)
    end

    # bad
    def get_attribute
    end

    # good
    def attribute
    end
    ```
  :configuration:
    Description: Check the naming of accessor methods for get_/set_.
    StyleGuide: "#accessor_mutator_method_names"
    Enabled: true
  :configurable_attributes: {}
- :name: Naming/AsciiIdentifiers
  :department_name: Naming
  :description: This cop checks for non-ascii characters in identifier names.
  :examples_description: "```ruby\n# bad\ndef  # Greek alphabet (non-ascii)\nend\n\n#
    bad\ndef  # Japanese character (non-ascii)\nend\n\n# bad\ndef hello_\U0001F363
    # Emoji (non-ascii)\nend\n\n# good\ndef say_hello\nend\n\n# bad\n = 10 # Hangul
    character (non-ascii)\n\n# good\nheight = 10\n\n# bad\nparams[:_gteq] # Arabic
    character (non-ascii)\n\n# good\nparams[:width_gteq]\n```\n"
  :configuration:
    Description: Use only ascii symbols in identifiers.
    StyleGuide: "#english-identifiers"
    Enabled: true
  :configurable_attributes: {}
- :name: Naming/ClassAndModuleCamelCase
  :department_name: Naming
  :description: |-
    This cops checks for class and module names with
    an underscore in them.
  :examples_description: |
    ```ruby
    # bad
    class My_Class
    end
    module My_Module
    end

    # good
    class MyClass
    end
    module MyModule
    end
    ```
  :configuration:
    Description: Use CamelCase for classes and modules.
    StyleGuide: "#camelcase-classes"
    Enabled: true
  :configurable_attributes: {}
- :name: Naming/ConstantName
  :department_name: Naming
  :description: |-
    This cop checks whether constant names are written using
    SCREAMING_SNAKE_CASE.

    To avoid false positives, it ignores cases in which we cannot know
    for certain the type of value that would be assigned to a constant.
  :examples_description: |
    ```ruby
    # bad
    InchInCm = 2.54
    INCHinCM = 2.54
    Inch_In_Cm = 2.54

    # good
    INCH_IN_CM = 2.54
    ```
  :configuration:
    Description: Constants should use SCREAMING_SNAKE_CASE.
    StyleGuide: "#screaming-snake-case"
    Enabled: true
  :configurable_attributes: {}
- :name: Naming/FileName
  :department_name: Naming
  :description: |-
    This cop makes sure that Ruby source files have snake_case
    names. Ruby scripts (i.e. source files with a shebang in the
    first line) are ignored.
  :examples_description: |
    ```ruby
    # bad
    lib/layoutManager.rb

    anything/usingCamelCase

    # good
    lib/layout_manager.rb

    anything/using_snake_case.rake
    ```
  :configuration:
    Description: Use snake_case for source file names.
    StyleGuide: "#snake-case-files"
    Enabled: true
  :configurable_attributes:
    Exclude: []
    ExpectMatchingDefinition: 'false'
    Regex: ''
    IgnoreExecutableScripts: 'true'
    AllowedAcronyms:
    - CLI
    - DSL
    - ACL
    - API
    - ASCII
    - CPU
    - CSS
    - DNS
    - EOF
    - GUID
    - HTML
    - HTTP
    - HTTPS
    - ID
    - IP
    - JSON
    - LHS
    - QPS
    - RAM
    - RHS
    - RPC
    - SLA
    - SMTP
    - SQL
    - SSH
    - TCP
    - TLS
    - TTL
    - UDP
    - UI
    - UID
    - UUID
    - URI
    - URL
    - UTF8
    - VM
    - XML
    - XMPP
    - XSRF
    - XSS
- :name: Naming/HeredocDelimiterCase
  :department_name: Naming
  :description: |-
    This cop checks that your heredocs are using the configured case.
    By default it is configured to enforce uppercase heredocs.
  :examples_description: |
    ```ruby
    # bad
    <<-sql
      SELECT * FROM foo
    sql

    # good
    <<-SQL
      SELECT * FROM foo
    SQL# bad
    <<-SQL
      SELECT * FROM foo
    SQL

    # good
    <<-sql
      SELECT * FROM foo
    sql
    ```
  :configuration:
    Description: Use configured case for heredoc delimiters.
    StyleGuide: "#heredoc-delimiters"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: uppercase
    SupportedStyles:
    - lowercase
    - uppercase
- :name: Naming/HeredocDelimiterNaming
  :department_name: Naming
  :description: |-
    This cop checks that your heredocs are using meaningful delimiters.
    By default it disallows `END` and `EO*`, and can be configured through
    blacklisting additional delimiters.
  :examples_description: |
    ```ruby

    # good
    <<-SQL
      SELECT * FROM foo
    SQL

    # bad
    <<-END
      SELECT * FROM foo
    END

    # bad
    <<-EOS
      SELECT * FROM foo
    EOS
    ```
  :configuration:
    Description: Use descriptive heredoc delimiters.
    StyleGuide: "#heredoc-delimiters"
    Enabled: true
  :configurable_attributes:
    Blacklist:
    - !ruby/regexp /(^|\s)(EO[A-Z]{1}|END)(\s|$)/
- :name: Naming/MemoizedInstanceVariableName
  :department_name: Naming
  :description: |-
    This cop checks for memoized methods whose instance variable name
    does not match the method name.
  :examples_description: |
    ```ruby
    # bad
    # Method foo is memoized using an instance variable that is
    # not `@foo`. This can cause confusion and bugs.
    def foo
      @something ||= calculate_expensive_thing
    end

    # good
    def foo
      @foo ||= calculate_expensive_thing
    end

    # good
    def foo
      @foo ||= begin
        calculate_expensive_thing
      end
    end

    # good
    def foo
      helper_variable = something_we_need_to_calculate_foo
      @foo ||= calculate_expensive_thing(helper_variable)
    end
    ```
  :configuration:
    Description: Memoized method name should match memo instance variable name.
    Enabled: true
  :configurable_attributes: {}
- :name: Naming/MethodName
  :department_name: Naming
  :description: |-
    This cop makes sure that all methods use the configured style,
    snake_case or camelCase, for their names.
  :examples_description: |
    ```ruby
    # bad
    def fooBar; end

    # good
    def foo_bar; end# bad
    def foo_bar; end

    # good
    def fooBar; end
    ```
  :configuration:
    Description: Use the configured style when naming methods.
    StyleGuide: "#snake-case-symbols-methods-vars"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: snake_case
    SupportedStyles:
    - snake_case
    - camelCase
- :name: Naming/BinaryOperatorParameterName
  :department_name: Naming
  :description: |-
    This cop makes sure that certain binary operator methods have their
    sole  parameter named `other`.
  :examples_description: |
    ```ruby

    # bad
    def +(amount); end

    # good
    def +(other); end
    ```
  :configuration:
    Description: When defining binary operators, name the argument other.
    StyleGuide: "#other-arg"
    Enabled: true
  :configurable_attributes: {}
- :name: Naming/PredicateName
  :department_name: Naming
  :description: This cop makes sure that predicates are named properly.
  :examples_description: |
    ```ruby
    # bad
    def is_even?(value)
    end

    # good
    def even?(value)
    end

    # bad
    def has_value?
    end

    # good
    def value?
    end
    ```
  :configuration:
    Description: Check the names of predicate methods.
    StyleGuide: "#bool-methods-qmark"
    Enabled: true
  :configurable_attributes:
    NamePrefix:
    - is_
    - has_
    - have_
    NamePrefixBlacklist:
    - is_
    - has_
    - have_
    NameWhitelist:
    - is_a?
    MethodDefinitionMacros:
    - define_method
    - define_singleton_method
    Exclude:
    - "/home/miguelsavignano/Developer/Projects/rubocop/spec/**/*"
- :name: Naming/UncommunicativeBlockParamName
  :department_name: Naming
  :description: |-
    This cop checks block parameter names for how descriptive they
    are. It is highly configurable.

    The `MinNameLength` config option takes an integer. It represents
    the minimum amount of characters the name must be. Its default is 1.
    The `AllowNamesEndingInNumbers` config option takes a boolean. When
    set to false, this cop will register offenses for names ending with
    numbers. Its default is false. The `AllowedNames` config option
    takes an array of whitelisted names that will never register an
    offense. The `ForbiddenNames` config option takes an array of
    blacklisted names that will always register an offense.
  :examples_description: |
    ```ruby
    # bad
    bar do |varOne, varTwo|
      varOne + varTwo
    end

    # With `AllowNamesEndingInNumbers` set to false
    foo { |num1, num2| num1 * num2 }

    # With `MinParamNameLength` set to number greater than 1
    baz { |a, b, c| do_stuff(a, b, c) }

    # good
    bar do |thud, fred|
      thud + fred
    end

    foo { |speed, distance| speed * distance }

    baz { |age, height, gender| do_stuff(age, height, gender) }
    ```
  :configuration:
    Description: Checks for block parameter names that contain capital letters, end
      in numbers, or do not meet a minimal length.
    Enabled: true
  :configurable_attributes:
    MinNameLength: '1'
    AllowNamesEndingInNumbers: 'true'
    AllowedNames: []
    ForbiddenNames: []
- :name: Naming/UncommunicativeMethodParamName
  :department_name: Naming
  :description: |-
    This cop checks method parameter names for how descriptive they
    are. It is highly configurable.

    The `MinNameLength` config option takes an integer. It represents
    the minimum amount of characters the name must be. Its default is 3.
    The `AllowNamesEndingInNumbers` config option takes a boolean. When
    set to false, this cop will register offenses for names ending with
    numbers. Its default is false. The `AllowedNames` config option
    takes an array of whitelisted names that will never register an
    offense. The `ForbiddenNames` config option takes an array of
    blacklisted names that will always register an offense.
  :examples_description: |
    ```ruby
    # bad
    def bar(varOne, varTwo)
      varOne + varTwo
    end

    # With `AllowNamesEndingInNumbers` set to false
    def foo(num1, num2)
      num1 * num2
    end

    # With `MinArgNameLength` set to number greater than 1
    def baz(a, b, c)
      do_stuff(a, b, c)
    end

    # good
    def bar(thud, fred)
      thud + fred
    end

    def foo(speed, distance)
      speed * distance
    end

    def baz(age_a, height_b, gender_c)
      do_stuff(age_a, height_b, gender_c)
    end
    ```
  :configuration:
    Description: Checks for method parameter names that contain capital letters, end
      in numbers, or do not meet a minimal length.
    Enabled: true
  :configurable_attributes:
    MinNameLength: '3'
    AllowNamesEndingInNumbers: 'true'
    AllowedNames:
    - io
    - id
    - to
    - by
    - 'on'
    - in
    - at
    ForbiddenNames: []
- :name: Naming/VariableName
  :department_name: Naming
  :description: |-
    This cop makes sure that all variables use the configured style,
    snake_case or camelCase, for their names.
  :examples_description: |
    ```ruby
    # bad
    fooBar = 1

    # good
    foo_bar = 1# bad
    foo_bar = 1

    # good
    fooBar = 1
    ```
  :configuration:
    Description: Use the configured style when naming variables.
    StyleGuide: "#snake-case-symbols-methods-vars"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: snake_case
    SupportedStyles:
    - snake_case
    - camelCase
- :name: Naming/VariableNumber
  :department_name: Naming
  :description: |-
    This cop makes sure that all numbered variables use the
    configured style, snake_case, normalcase or non_integer,
    for their numbering.
  :examples_description: |
    ```ruby
    # bad

    variable1 = 1

    # good

    variable_1 = 1# bad

    variable_1 = 1

    # good

    variable1 = 1# bad

    variable1 = 1

    variable_1 = 1

    # good

    variableone = 1

    variable_one = 1
    ```
  :configuration:
    Description: Use the configured style when numbering variables.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: normalcase
    SupportedStyles:
    - snake_case
    - normalcase
    - non_integer
- :name: Performance/Caller
  :department_name: Performance
  :description: |-
    This cop identifies places where `caller[n]`
    can be replaced by `caller(n..n).first`.
  :examples_description: |
    ```ruby
    # bad
    caller[1]
    caller.first
    caller_locations[1]
    caller_locations.first

    # good
    caller(2..2).first
    caller(1..1).first
    caller_locations(2..2).first
    caller_locations(1..1).first
    ```
  :configuration:
    Description: Use `caller(n..n)` instead of `caller`.
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/CaseWhenSplat
  :department_name: Performance
  :description: |-
    Place `when` conditions that use splat at the end
    of the list of `when` branches.

    Ruby has to allocate memory for the splat expansion every time
    that the `case` `when` statement is run. Since Ruby does not support
    fall through inside of `case` `when`, like some other languages do,
    the order of the `when` branches does not matter. By placing any
    splat expansions at the end of the list of `when` branches we will
    reduce the number of times that memory has to be allocated for
    the expansion.

    This is not a guaranteed performance improvement. If the data being
    processed by the `case` condition is normalized in a manner that favors
    hitting a condition in the splat expansion, it is possible that
    moving the splat condition to the end will use more memory,
    and run slightly slower.
  :examples_description: |
    ```ruby
    # bad
    case foo
    when *condition
      bar
    when baz
      foobar
    end

    case foo
    when *[1, 2, 3, 4]
      bar
    when 5
      baz
    end

    # good
    case foo
    when baz
      foobar
    when *condition
      bar
    end

    case foo
    when 1, 2, 3, 4
      bar
    when 5
      baz
    end
    ```
  :configuration:
    Description: Place `when` conditions that use splat at the end of the list of
      `when` branches.
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/Casecmp
  :department_name: Performance
  :description: |-
    This cop identifies places where a case-insensitive string comparison
    can better be implemented using `casecmp`.
  :examples_description: |
    ```ruby
    # bad
    str.downcase == 'abc'
    str.upcase.eql? 'ABC'
    'abc' == str.downcase
    'ABC'.eql? str.upcase
    str.downcase == str.downcase

    # good
    str.casecmp('ABC').zero?
    'abc'.casecmp(str).zero?
    ```
  :configuration:
    Description: Use `casecmp` rather than `downcase ==`, `upcase ==`, `== downcase`,
      or `== upcase`..
    Reference: https://github.com/JuanitoFatas/fast-ruby#stringcasecmp-vs-stringdowncase---code
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/Count
  :department_name: Performance
  :description: |-
    This cop is used to identify usages of `count` on an `Enumerable` that
    follow calls to `select` or `reject`. Querying logic can instead be
    passed to the `count` call.

    `ActiveRecord` compatibility:
    `ActiveRecord` will ignore the block that is passed to `count`.
    Other methods, such as `select`, will convert the association to an
    array and then run the block on the array. A simple work around to
    make `count` work with a block is to call `to_a.count {...}`.

    Example:
      Model.where(id: [1, 2, 3].select { |m| m.method == true }.size

      becomes:

      Model.where(id: [1, 2, 3]).to_a.count { |m| m.method == true }
  :examples_description: |
    ```ruby
    # bad
    [1, 2, 3].select { |e| e > 2 }.size
    [1, 2, 3].reject { |e| e > 2 }.size
    [1, 2, 3].select { |e| e > 2 }.length
    [1, 2, 3].reject { |e| e > 2 }.length
    [1, 2, 3].select { |e| e > 2 }.count { |e| e.odd? }
    [1, 2, 3].reject { |e| e > 2 }.count { |e| e.even? }
    array.select(&:value).count

    # good
    [1, 2, 3].count { |e| e > 2 }
    [1, 2, 3].count { |e| e < 2 }
    [1, 2, 3].count { |e| e > 2 && e.odd? }
    [1, 2, 3].count { |e| e < 2 && e.even? }
    Model.select('field AS field_one').count
    Model.select(:value).count
    ```
  :configuration:
    Description: Use `count` instead of `select...size`, `reject...size`, `select...count`,
      `reject...count`, `select...length`, and `reject...length`.
    Enabled: true
  :configurable_attributes:
    SafeMode: 'true'
- :name: Performance/Detect
  :department_name: Performance
  :description: |-
    This cop is used to identify usages of
    `select.first`, `select.last`, `find_all.first`, and `find_all.last`
    and change them to use `detect` instead.

    `ActiveRecord` compatibility:
    `ActiveRecord` does not implement a `detect` method and `find` has its
    own meaning. Correcting ActiveRecord methods with this cop should be
    considered unsafe.
  :examples_description: |
    ```ruby
    # bad
    [].select { |item| true }.first
    [].select { |item| true }.last
    [].find_all { |item| true }.first
    [].find_all { |item| true }.last

    # good
    [].detect { |item| true }
    [].reverse.detect { |item| true }
    ```
  :configuration:
    Description: Use `detect` instead of `select.first`, `find_all.first`, `select.last`,
      and `find_all.last`.
    Reference: https://github.com/JuanitoFatas/fast-ruby#enumerabledetect-vs-enumerableselectfirst-code
    Enabled: true
  :configurable_attributes:
    SafeMode: 'true'
- :name: Performance/DoubleStartEndWith
  :department_name: Performance
  :description: |-
    This cop checks for double `#start_with?` or `#end_with?` calls
    separated by `||`. In some cases such calls can be replaced
    with an single `#start_with?`/`#end_with?` call.
  :examples_description: |
    ```ruby
    # bad
    str.start_with?("a") || str.start_with?(Some::CONST)
    str.start_with?("a", "b") || str.start_with?("c")
    str.end_with?(var1) || str.end_with?(var2)

    # good
    str.start_with?("a", Some::CONST)
    str.start_with?("a", "b", "c")
    str.end_with?(var1, var2)
    ```
  :configuration:
    Description: Use `str.{start,end}_with?(x, ..., y, ...)` instead of `str.{start,end}_with?(x,
      ...) || str.{start,end}_with?(y, ...)`.
    Enabled: true
  :configurable_attributes:
    IncludeActiveSupportAliases: 'false'
- :name: Performance/EndWith
  :department_name: Performance
  :description: |-
    This cop identifies unnecessary use of a regex where `String#end_with?`
    would suffice.
  :examples_description: |
    ```ruby
    # bad
    'abc'.match?(/bc\Z/)
    'abc' =~ /bc\Z/
    'abc'.match(/bc\Z/)

    # good
    'abc'.end_with?('bc')
    ```
  :configuration:
    Description: Use `end_with?` instead of a regex match anchored to the end of a
      string.
    Reference: https://github.com/JuanitoFatas/fast-ruby#stringmatch-vs-stringstart_withstringend_with-code-start-code-end
    Enabled: true
  :configurable_attributes:
    AutoCorrect: 'false'
- :name: Performance/FixedSize
  :department_name: Performance
  :description: Do not compute the size of statically sized objects.
  :examples_description: |
    ```ruby
    # String methods
    # bad
    'foo'.size
    %q[bar].count
    %(qux).length

    # Symbol methods
    # bad
    :fred.size
    :'baz'.length

    # Array methods
    # bad
    [1, 2, thud].count
    %W(1, 2, bar).size

    # Hash methods
    # bad
    { a: corge, b: grault }.length

    # good
    foo.size
    bar.count
    qux.length

    # good
    :"#{fred}".size
    CONST = :baz.length

    # good
    [1, 2, *thud].count
    garply = [1, 2, 3]
    garly.size

    # good
    { a: corge, **grault }.length
    waldo = { a: corge, b: grault }
    waldo.size
    ```
  :configuration:
    Description: Do not compute the size of statically sized objects except in constants
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/FlatMap
  :department_name: Performance
  :description: This cop is used to identify usages of
  :examples_description: |
    ```ruby
    # bad
    [1, 2, 3, 4].map { |e| [e, e] }.flatten(1)
    [1, 2, 3, 4].collect { |e| [e, e] }.flatten(1)

    # good
    [1, 2, 3, 4].flat_map { |e| [e, e] }
    [1, 2, 3, 4].map { |e| [e, e] }.flatten
    [1, 2, 3, 4].collect { |e| [e, e] }.flatten
    ```
  :configuration:
    Description: Use `Enumerable#flat_map` instead of `Enumerable#map...Array#flatten(1)`
      or `Enumberable#collect..Array#flatten(1)`
    Reference: https://github.com/JuanitoFatas/fast-ruby#enumerablemaparrayflatten-vs-enumerableflat_map-code
    Enabled: true
  :configurable_attributes:
    EnabledForFlattenWithoutParams: 'false'
- :name: Performance/LstripRstrip
  :department_name: Performance
  :description: |-
    This cop identifies places where `lstrip.rstrip` can be replaced by
    `strip`.
  :examples_description: |
    ```ruby
    # bad
    'abc'.lstrip.rstrip
    'abc'.rstrip.lstrip

    # good
    'abc'.strip
    ```
  :configuration:
    Description: Use `strip` instead of `lstrip.rstrip`.
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/RangeInclude
  :department_name: Performance
  :description: |-
    This cop identifies uses of `Range#include?`, which iterates over each
    item in a `Range` to see if a specified item is there. In contrast,
    `Range#cover?` simply compares the target item with the beginning and
    end points of the `Range`. In a great majority of cases, this is what
    is wanted.

    Here is an example of a case where `Range#cover?` may not provide the
    desired result:

        ('a'..'z').cover?('yellow') # => true
  :examples_description: ''
  :configuration:
    Description: Use `Range#cover?` instead of `Range#include?`.
    Reference: https://github.com/JuanitoFatas/fast-ruby#cover-vs-include-code
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/RedundantBlockCall
  :department_name: Performance
  :description: |-
    This cop identifies the use of a `&block` parameter and `block.call`
    where `yield` would do just as well.
  :examples_description: |
    ```ruby
    # bad
    def method(&block)
      block.call
    end
    def another(&func)
      func.call 1, 2, 3
    end

    # good
    def method
      yield
    end
    def another
      yield 1, 2, 3
    end
    ```
  :configuration:
    Description: Use `yield` instead of `block.call`.
    Reference: https://github.com/JuanitoFatas/fast-ruby#proccall-and-block-arguments-vs-yieldcode
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/RedundantMatch
  :department_name: Performance
  :description: |-
    This cop identifies the use of `Regexp#match` or `String#match`, which
    returns `#<MatchData>`/`nil`. The return value of `=~` is an integral
    index/`nil` and is more performant.
  :examples_description: |
    ```ruby
    # bad
    do_something if str.match(/regex/)
    while regex.match('str')
      do_something
    end

    # good
    method(str =~ /regex/)
    return value unless regex =~ 'str'
    ```
  :configuration:
    Description: Use `=~` instead of `String#match` or `Regexp#match` in a context
      where the returned `MatchData` is not needed.
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/RedundantMerge
  :department_name: Performance
  :description: |-
    This cop identifies places where `Hash#merge!` can be replaced by
    `Hash#[]=`.
  :examples_description: |
    ```ruby
    hash.merge!(a: 1)
    hash.merge!({'key' => 'value'})
    hash.merge!(a: 1, b: 2)
    ```
  :configuration:
    Description: Use Hash#[]=, rather than Hash#merge! with a single key-value pair.
    Reference: https://github.com/JuanitoFatas/fast-ruby#hashmerge-vs-hash-code
    Enabled: true
  :configurable_attributes:
    MaxKeyValuePairs: '2'
- :name: Performance/RedundantSortBy
  :department_name: Performance
  :description: |-
    This cop identifies places where `sort_by { ... }` can be replaced by
    `sort`.
  :examples_description: |
    ```ruby
    # bad
    array.sort_by { |x| x }
    array.sort_by do |var|
      var
    end

    # good
    array.sort
    ```
  :configuration:
    Description: Use `sort` instead of `sort_by { |x| x }`.
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/RegexpMatch
  :department_name: Performance
  :description: |-
    In Ruby 2.4, `String#match?`, `Regexp#match?` and `Symbol#match?`
    have been added. The methods are faster than `match`.
    Because the methods avoid creating a `MatchData` object or saving
    backref.
    So, when `MatchData` is not used, use `match?` instead of `match`.
  :examples_description: |
    ```ruby
    # bad
    def foo
      if x =~ /re/
        do_something
      end
    end

    # bad
    def foo
      if x !~ /re/
        do_something
      end
    end

    # bad
    def foo
      if x.match(/re/)
        do_something
      end
    end

    # bad
    def foo
      if /re/ === x
        do_something
      end
    end

    # good
    def foo
      if x.match?(/re/)
        do_something
      end
    end

    # good
    def foo
      if !x.match?(/re/)
        do_something
      end
    end

    # good
    def foo
      if x =~ /re/
        do_something(Regexp.last_match)
      end
    end

    # good
    def foo
      if x.match(/re/)
        do_something($~)
      end
    end

    # good
    def foo
      if /re/ === x
        do_something($~)
      end
    end
    ```
  :configuration:
    Description: Use `match?` instead of `Regexp#match`, `String#match`, `Symbol#match`,
      `Regexp#===`, or `=~` when `MatchData` is not used.
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/ReverseEach
  :department_name: Performance
  :description: |-
    This cop is used to identify usages of `reverse.each` and
    change them to use `reverse_each` instead.
  :examples_description: |
    ```ruby
    # bad
    [].reverse.each

    # good
    [].reverse_each
    ```
  :configuration:
    Description: Use `reverse_each` instead of `reverse.each`.
    Reference: https://github.com/JuanitoFatas/fast-ruby#enumerablereverseeach-vs-enumerablereverse_each-code
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/Sample
  :department_name: Performance
  :description: |-
    This cop is used to identify usages of `shuffle.first`, `shuffle.last`
    and `shuffle[]` and change them to use `sample` instead.
  :examples_description: |
    ```ruby
    # bad
    [1, 2, 3].shuffle.first
    [1, 2, 3].shuffle.first(2)
    [1, 2, 3].shuffle.last
    [1, 2, 3].shuffle[2]
    [1, 2, 3].shuffle[0, 2]    # sample(2) will do the same
    [1, 2, 3].shuffle[0..2]    # sample(3) will do the same
    [1, 2, 3].shuffle(random: Random.new).first

    # good
    [1, 2, 3].shuffle
    [1, 2, 3].sample
    [1, 2, 3].sample(3)
    [1, 2, 3].shuffle[1, 3]    # sample(3) might return a longer Array
    [1, 2, 3].shuffle[1..3]    # sample(3) might return a longer Array
    [1, 2, 3].shuffle[foo, bar]
    [1, 2, 3].shuffle(random: Random.new)
    ```
  :configuration:
    Description: Use `sample` instead of `shuffle.first`, `shuffle.last`, and `shuffle[Integer]`.
    Reference: https://github.com/JuanitoFatas/fast-ruby#arrayshufflefirst-vs-arraysample-code
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/Size
  :department_name: Performance
  :description: |-
    This cop is used to identify usages of `count` on an
    `Array` and `Hash` and change them to `size`.

    TODO: Add advanced detection of variables that could
    have been assigned to an array or a hash.
  :examples_description: |
    ```ruby
    # bad
    [1, 2, 3].count

    # bad
    {a: 1, b: 2, c: 3}.count

    # good
    [1, 2, 3].size

    # good
    {a: 1, b: 2, c: 3}.size

    # good
    [1, 2, 3].count { |e| e > 2 }
    ```
  :configuration:
    Description: Use `size` instead of `count` for counting the number of elements
      in `Array` and `Hash`.
    Reference: https://github.com/JuanitoFatas/fast-ruby#arraylength-vs-arraysize-vs-arraycount-code
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/CompareWithBlock
  :department_name: Performance
  :description: |-
    This cop identifies places where `sort { |a, b| a.foo <=> b.foo }`
    can be replaced by `sort_by(&:foo)`.
    This cop also checks `max` and `min` methods.
  :examples_description: |
    ```ruby
    # bad
    array.sort { |a, b| a.foo <=> b.foo }
    array.max { |a, b| a.foo <=> b.foo }
    array.min { |a, b| a.foo <=> b.foo }
    array.sort { |a, b| a[:foo] <=> b[:foo] }

    # good
    array.sort_by(&:foo)
    array.sort_by { |v| v.foo }
    array.sort_by do |var|
      var.foo
    end
    array.max_by(&:foo)
    array.min_by(&:foo)
    array.sort_by { |a| a[:foo] }
    ```
  :configuration:
    Description: Use `sort_by(&:foo)` instead of `sort { |a, b| a.foo <=> b.foo }`.
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/StartWith
  :department_name: Performance
  :description: |-
    This cop identifies unnecessary use of a regex where
    `String#start_with?` would suffice.
  :examples_description: |
    ```ruby
    # bad
    'abc'.match?(/\Aab/)
    'abc' =~ /\Aab/
    'abc'.match(/\Aab/)

    # good
    'abc'.start_with?('ab')
    ```
  :configuration:
    Description: Use `start_with?` instead of a regex match anchored to the beginning
      of a string.
    Reference: https://github.com/JuanitoFatas/fast-ruby#stringmatch-vs-stringstart_withstringend_with-code-start-code-end
    Enabled: true
  :configurable_attributes:
    AutoCorrect: 'false'
- :name: Performance/StringReplacement
  :department_name: Performance
  :description: |-
    This cop identifies places where `gsub` can be replaced by
    `tr` or `delete`.
  :examples_description: |
    ```ruby
    # bad
    'abc'.gsub('b', 'd')
    'abc'.gsub('a', '')
    'abc'.gsub(/a/, 'd')
    'abc'.gsub!('a', 'd')

    # good
    'abc'.gsub(/.*/, 'a')
    'abc'.gsub(/a+/, 'd')
    'abc'.tr('b', 'd')
    'a b c'.delete(' ')
    ```
  :configuration:
    Description: Use `tr` instead of `gsub` when you are replacing the same number
      of characters. Use `delete` instead of `gsub` when you are deleting characters.
    Reference: https://github.com/JuanitoFatas/fast-ruby#stringgsub-vs-stringtr-code
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/TimesMap
  :department_name: Performance
  :description: |-
    This cop checks for .times.map calls.
    In most cases such calls can be replaced
    with an explicit array creation.
  :examples_description: |
    ```ruby
    # bad
    9.times.map do |i|
      i.to_s
    end

    # good
    Array.new(9) do |i|
      i.to_s
    end
    ```
  :configuration:
    Description: Checks for .times.map calls.
    Enabled: true
  :configurable_attributes:
    AutoCorrect: 'false'
- :name: Performance/UnfreezeString
  :department_name: Performance
  :description: |-
    In Ruby 2.3 or later, use unary plus operator to unfreeze a string
    literal instead of `String#dup` and `String.new`.
    Unary plus operator is faster than `String#dup`.

    Note: `String.new` (without operator) is not exactly the same as `+''`.
    These differ in encoding. `String.new.encoding` is always `ASCII-8BIT`.
    However, `(+'').encoding` is the same as script encoding(e.g. `UTF-8`).
    So, if you expect `ASCII-8BIT` encoding, disable this cop.
  :examples_description: |
    ```ruby
    # bad
    ''.dup
    "something".dup
    String.new
    String.new('')
    String.new('something')

    # good
    +'something'
    +''
    ```
  :configuration:
    Description: Use unary plus to get an unfrozen string literal.
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/UnneededSort
  :department_name: Performance
  :description: |-
    This cop is used to identify instances of sorting and then
    taking only the first or last element. The same behavior can
    be accomplished without a relatively expensive sort by using
    `Enumerable#min` instead of sorting and taking the first
    element and `Enumerable#max` instead of sorting and taking the
    last element. Similarly, `Enumerable#min_by` and
    `Enumerable#max_by` can replace `Enumerable#sort_by` calls
    after which only the first or last element is used.
  :examples_description: |
    ```ruby
    # bad
    [2, 1, 3].sort.first
    [2, 1, 3].sort[0]
    [2, 1, 3].sort.at(0)
    [2, 1, 3].sort.slice(0)

    # good
    [2, 1, 3].min

    # bad
    [2, 1, 3].sort.last
    [2, 1, 3].sort[-1]
    [2, 1, 3].sort.at(-1)
    [2, 1, 3].sort.slice(-1)

    # good
    [2, 1, 3].max

    # bad
    arr.sort_by(&:foo).first
    arr.sort_by(&:foo)[0]
    arr.sort_by(&:foo).at(0)
    arr.sort_by(&:foo).slice(0)

    # good
    arr.min_by(&:foo)

    # bad
    arr.sort_by(&:foo).last
    arr.sort_by(&:foo)[-1]
    arr.sort_by(&:foo).at(-1)
    arr.sort_by(&:foo).slice(-1)

    # good
    arr.max_by(&:foo)
    ```
  :configuration:
    Description: Use `min` instead of `sort.first`, `max_by` instead of `sort_by...last`,
      etc.
    Enabled: true
  :configurable_attributes: {}
- :name: Performance/UriDefaultParser
  :department_name: Performance
  :description: |-
    This cop identifies places where `URI::Parser.new`
    can be replaced by `URI::DEFAULT_PARSER`.
  :examples_description: |
    ```ruby
    # bad
    URI::Parser.new

    # good
    URI::DEFAULT_PARSER
    ```
  :configuration:
    Description: Use `URI::DEFAULT_PARSER` instead of `URI::Parser.new`.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/Alias
  :department_name: Style
  :description: |-
    This cop enforces the use of either `#alias` or `#alias_method`
    depending on configuration.
    It also flags uses of `alias :symbol` rather than `alias bareword`.
  :examples_description: |
    ```ruby
    # bad
    alias_method :bar, :foo
    alias :bar :foo

    # good
    alias bar foo# bad
    alias :bar :foo
    alias bar foo

    # good
    alias_method :bar, :foo
    ```
  :configuration:
    Description: Use alias instead of alias_method.
    StyleGuide: "#alias-method"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: prefer_alias
    SupportedStyles:
    - prefer_alias
    - prefer_alias_method
- :name: Style/AndOr
  :department_name: Style
  :description: |-
    This cop checks for uses of `and` and `or`, and suggests using `&&` and
    `|| instead`. It can be configured to check only in conditions, or in
    all contexts.
  :examples_description: |
    ```ruby
    # bad
    foo.save and return

    # bad
    if foo and bar
    end

    # good
    foo.save && return

    # good
    if foo && bar
    end# bad
    if foo and bar
    end

    # good
    foo.save && return

    # good
    foo.save and return

    # good
    if foo && bar
    end
    ```
  :configuration:
    Description: Use &&/|| instead of and/or.
    StyleGuide: "#no-and-or-or"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: always
    SupportedStyles:
    - always
    - conditionals
- :name: Style/ArrayJoin
  :department_name: Style
  :description: |-
    This cop checks for uses of "*" as a substitute for *join*.

    Not all cases can reliably checked, due to Ruby's dynamic
    types, so we consider only cases when the first argument is an
    array literal or the second is a string literal.
  :examples_description: |
    ```ruby

    # bad
    %w(foo bar baz) * ","

    # good
    %w(foo bar baz).join(",")
    ```
  :configuration:
    Description: Use Array#join instead of Array#*.
    StyleGuide: "#array-join"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/AsciiComments
  :department_name: Style
  :description: |-
    This cop checks for non-ascii (non-English) characters
    in comments. You could set an array of allowed non-ascii chars in
    AllowedChars attribute (empty by default).
  :examples_description: |
    ```ruby
    # bad
    # Translates from English to 

    # good
    # Translates from English to Japanese
    ```
  :configuration:
    Description: Use only ascii symbols in comments.
    StyleGuide: "#english-comments"
    Enabled: true
  :configurable_attributes:
    AllowedChars: []
- :name: Style/Attr
  :department_name: Style
  :description: This cop checks for uses of Module#attr.
  :examples_description: |
    ```ruby
    # bad - creates a single attribute accessor (deprecated in Ruby 1.9)
    attr :something, true
    attr :one, :two, :three # behaves as attr_reader

    # good
    attr_accessor :something
    attr_reader :one, :two, :three
    ```
  :configuration:
    Description: Checks for uses of Module#attr.
    StyleGuide: "#attr"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/AutoResourceCleanup
  :department_name: Style
  :description: |-
    This cop checks for cases when you could use a block
    accepting version of a method that does automatic
    resource cleanup.
  :examples_description: |
    ```ruby

    # bad
    f = File.open('file')

    # good
    File.open('file') do |f|
      # ...
    end
    ```
  :configuration:
    Description: Suggests the usage of an auto resource cleanup version of a method
      (if available).
    Enabled: false
  :configurable_attributes: {}
- :name: Style/BarePercentLiterals
  :department_name: Style
  :description: This cop checks if usage of %() or %Q() matches configuration.
  :examples_description: |
    ```ruby
    # bad
    %Q(He said: "#{greeting}")
    %q{She said: 'Hi'}

    # good
    %(He said: "#{greeting}")
    %{She said: 'Hi'}# bad
    %|He said: "#{greeting}"|
    %/She said: 'Hi'/

    # good
    %Q|He said: "#{greeting}"|
    %q/She said: 'Hi'/
    ```
  :configuration:
    Description: Checks if usage of %() or %Q() matches configuration.
    StyleGuide: "#percent-q-shorthand"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: bare_percent
    SupportedStyles:
    - percent_q
    - bare_percent
- :name: Style/BeginBlock
  :department_name: Style
  :description: This cop checks for BEGIN blocks.
  :examples_description: ''
  :configuration:
    Description: Avoid the use of BEGIN blocks.
    StyleGuide: "#no-BEGIN-blocks"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/BlockComments
  :department_name: Style
  :description: This cop looks for uses of block comments (=begin...=end).
  :examples_description: |
    ```ruby
    # bad
    =begin
    Multiple lines
    of comments...
    =end

    # good
    # Multiple lines
    # of comments...
    ```
  :configuration:
    Description: Do not use block comments.
    StyleGuide: "#no-block-comments"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/BlockDelimiters
  :department_name: Style
  :description: |-
    Check for uses of braces or do/end around single line or
    multi-line blocks.
  :examples_description: |
    ```ruby
    # bad - single line block
    items.each do |item| item / 5 end

    # good - single line block
    items.each { |item| item / 5 }

    # bad - multi-line block
    things.map { |thing|
      something = thing.some_method
      process(something)
    }

    # good - multi-line block
    things.map do |thing|
      something = thing.some_method
      process(something)
    end# Prefer `do...end` over `{...}` for procedural blocks.

    # return value is used/assigned
    # bad
    foo = map do |x|
      x
    end
    puts (map do |x|
      x
    end)

    # return value is not used out of scope
    # good
    map do |x|
      x
    end

    # Prefer `{...}` over `do...end` for functional blocks.

    # return value is not used out of scope
    # bad
    each { |x|
      x
    }

    # return value is used/assigned
    # good
    foo = map { |x|
      x
    }
    map { |x|
      x
    }.inspect# bad
    words.each do |word|
      word.flip.flop
    end.join("-")

    # good
    words.each { |word|
      word.flip.flop
    }.join("-")
    ```
  :configuration:
    Description: Avoid using {...} for multi-line blocks (multiline chaining is always
      ugly). Prefer {...} over do...end for single-line blocks.
    StyleGuide: "#single-line-blocks"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: line_count_based
    SupportedStyles:
    - line_count_based
    - semantic
    - braces_for_chaining
    ProceduralMethods:
    - benchmark
    - bm
    - bmbm
    - create
    - each_with_object
    - measure
    - new
    - realtime
    - tap
    - with_object
    FunctionalMethods:
    - let
    - let!
    - subject
    - watch
    IgnoredMethods:
    - lambda
    - proc
    - it
- :name: Style/BracesAroundHashParameters
  :department_name: Style
  :description: |-
    This cop checks for braces around the last parameter in a method call
    if the last parameter is a hash.
    It supports `braces`, `no_braces` and `context_dependent` styles.
  :examples_description: |
    ```ruby
    # The `braces` style enforces braces around all method
    # parameters that are hashes.

    # bad
    some_method(x, y, a: 1, b: 2)

    # good
    some_method(x, y, {a: 1, b: 2})# The `no_braces` style checks that the last parameter doesn't
    # have braces around it.

    # bad
    some_method(x, y, {a: 1, b: 2})

    # good
    some_method(x, y, a: 1, b: 2)# The `context_dependent` style checks that the last parameter
    # doesn't have braces around it, but requires braces if the
    # second to last parameter is also a hash literal.

    # bad
    some_method(x, y, {a: 1, b: 2})
    some_method(x, y, {a: 1, b: 2}, a: 1, b: 2)

    # good
    some_method(x, y, a: 1, b: 2)
    some_method(x, y, {a: 1, b: 2}, {a: 1, b: 2})
    ```
  :configuration:
    Description: Enforce braces style around hash parameters.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: no_braces
    SupportedStyles:
    - braces
    - no_braces
    - context_dependent
- :name: Style/CaseEquality
  :department_name: Style
  :description: This cop checks for uses of the case equality operator(===).
  :examples_description: |
    ```ruby
    # bad
    Array === something
    (1..100) === 7
    /something/ === some_string

    # good
    something.is_a?(Array)
    (1..100).include?(7)
    some_string =~ /something/
    ```
  :configuration:
    Description: Avoid explicit use of the case equality operator(===).
    StyleGuide: "#no-case-equality"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/CharacterLiteral
  :department_name: Style
  :description: Checks for uses of the character literal ?x.
  :examples_description: |
    ```ruby
    # bad
    ?x

    # good
    'x'

    # good
    ?\C-\M-d
    ```
  :configuration:
    Description: Checks for uses of character literals.
    StyleGuide: "#no-character-literals"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/ClassAndModuleChildren
  :department_name: Style
  :description: |-
    This cop checks the style of children definitions at classes and
    modules. Basically there are two different styles:

    The compact style is only forced for classes/modules with one child.
  :examples_description: |
    ```ruby
    # good
    # have each child on its own line
    class Foo
      class Bar
      end
    end# good
    # combine definitions as much as possible
    class Foo::Bar
    end
    ```
  :configuration:
    Description: Checks style of children classes and modules.
    StyleGuide: "#namespace-definition"
    Enabled: true
  :configurable_attributes:
    AutoCorrect: 'false'
    EnforcedStyle: nested
    SupportedStyles:
    - nested
    - compact
- :name: Style/ClassCheck
  :department_name: Style
  :description: This cop enforces consistent use of `Object#is_a?` or `Object#kind_of?`.
  :examples_description: |
    ```ruby
    # bad
    var.kind_of?(Date)
    var.kind_of?(Integer)

    # good
    var.is_a?(Date)
    var.is_a?(Integer)# bad
    var.is_a?(Time)
    var.is_a?(String)

    # good
    var.kind_of?(Time)
    var.kind_of?(String)
    ```
  :configuration:
    Description: Enforces consistent use of `Object#is_a?` or `Object#kind_of?`.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: is_a?
    SupportedStyles:
    - is_a?
    - kind_of?
- :name: Style/ClassMethods
  :department_name: Style
  :description: |-
    This cop checks for uses of the class/module name instead of
    self, when defining class/module methods.
  :examples_description: |
    ```ruby
    # bad
    class SomeClass
      def SomeClass.class_method
        # ...
      end
    end

    # good
    class SomeClass
      def self.class_method
        # ...
      end
    end
    ```
  :configuration:
    Description: Use self when defining module/class methods.
    StyleGuide: "#def-self-class-methods"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/ClassVars
  :department_name: Style
  :description: |-
    This cop checks for uses of class variables. Offenses
    are signaled only on assignment to class variables to
    reduce the number of offenses that would be reported.

    You have to be careful when setting a value for a class
    variable; if a class has been inherited, changing the
    value of a class variable also affects the inheriting
    classes. This means that it's almost always better to
    use a class instance variable instead.
  :examples_description: |
    ```ruby
    # bad
    class A
      @@test = 10
    end

    # good
    class A
      @test = 10
    end

    class A
      def test
        @@test # you can access class variable without offence
      end
    end
    ```
  :configuration:
    Description: Avoid the use of class variables.
    StyleGuide: "#no-class-vars"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/CollectionMethods
  :department_name: Style
  :description: |-
    This cop enforces the use of consistent method names
    from the Enumerable module.

    Unfortunately we cannot actually know if a method is from
    Enumerable or not (static analysis limitation), so this cop
    can yield some false positives.
  :examples_description: ''
  :configuration:
    Description: Preferred collection methods.
    StyleGuide: "#map-find-select-reduce-size"
    Enabled: false
  :configurable_attributes:
    PreferredMethods: '{"collect"=>"map", "collect!"=>"map!", "inject"=>"reduce",
      "detect"=>"find", "find_all"=>"select"}'
- :name: Style/ColonMethodCall
  :department_name: Style
  :description: |-
    This cop checks for methods invoked via the :: operator instead
    of the . operator (like FileUtils::rmdir instead of FileUtils.rmdir).
  :examples_description: |
    ```ruby
    # bad
    Timeout::timeout(500) { do_something }
    FileUtils::rmdir(dir)
    Marshal::dump(obj)

    # good
    Timeout.timeout(500) { do_something }
    FileUtils.rmdir(dir)
    Marshal.dump(obj)
    ```
  :configuration:
    Description: 'Do not use :: for method call.'
    StyleGuide: "#double-colons"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/ColonMethodDefinition
  :department_name: Style
  :description: |-
    This cop checks for class methods that are defined using the `::`
    operator instead of the `.` operator.
  :examples_description: |
    ```ruby
    # bad
    class Foo
      def self::bar
      end
    end

    # good
    class Foo
      def self.bar
      end
    end
    ```
  :configuration:
    Description: 'Do not use :: for defining class methods.'
    StyleGuide: "#colon-method-definition"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/CommandLiteral
  :department_name: Style
  :description: This cop enforces using `` or %x around command literals.
  :examples_description: |
    ```ruby
    # bad
    folders = %x(find . -type d).split

    # bad
    %x(
      ln -s foo.example.yml foo.example
      ln -s bar.example.yml bar.example
    )

    # good
    folders = `find . -type d`.split

    # good
    `
      ln -s foo.example.yml foo.example
      ln -s bar.example.yml bar.example
    `# bad
    folders = %x(find . -type d).split

    # bad
    `
      ln -s foo.example.yml foo.example
      ln -s bar.example.yml bar.example
    `

    # good
    folders = `find . -type d`.split

    # good
    %x(
      ln -s foo.example.yml foo.example
      ln -s bar.example.yml bar.example
    )# bad
    folders = `find . -type d`.split

    # bad
    `
      ln -s foo.example.yml foo.example
      ln -s bar.example.yml bar.example
    `

    # good
    folders = %x(find . -type d).split

    # good
    %x(
      ln -s foo.example.yml foo.example
      ln -s bar.example.yml bar.example
    )# If `false`, the cop will always recommend using `%x` if one or more
    # backticks are found in the command string.

    # bad
    `echo \`ls\``

    # good
    %x(echo `ls`)# good
    `echo \`ls\``
    ```
  :configuration:
    Description: Use `` or %x around command literals.
    StyleGuide: "#percent-x"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: backticks
    SupportedStyles:
    - backticks
    - percent_x
    - mixed
    AllowInnerBackticks: 'false'
- :name: Style/CommentAnnotation
  :department_name: Style
  :description: |-
    This cop checks that comment annotation keywords are written according
    to guidelines.
  :examples_description: |
    ```ruby
    # bad
    # TODO make better

    # good
    # TODO: make better

    # bad
    # TODO:make better

    # good
    # TODO: make better

    # bad
    # fixme: does not work

    # good
    # FIXME: does not work

    # bad
    # Optimize does not work

    # good
    # OPTIMIZE: does not work
    ```
  :configuration:
    Description: Checks formatting of special comments (TODO, FIXME, OPTIMIZE, HACK,
      REVIEW).
    StyleGuide: "#annotate-keywords"
    Enabled: true
  :configurable_attributes:
    Keywords:
    - TODO
    - FIXME
    - OPTIMIZE
    - HACK
    - REVIEW
- :name: Style/CommentedKeyword
  :department_name: Style
  :description: |-
    This cop checks for comments put on the same line as some keywords.
    These keywords are: `begin`, `class`, `def`, `end`, `module`.

    Note that some comments (such as `:nodoc:` and `rubocop:disable`) are
    allowed.
  :examples_description: |
    ```ruby
    # bad
    if condition
      statement
    end # end if

    # bad
    class X # comment
      statement
    end

    # bad
    def x; end # comment

    # good
    if condition
      statement
    end

    # good
    class X # :nodoc:
      y
    end
    ```
  :configuration:
    Description: Do not place comments on the same line as certain keywords.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/ConditionalAssignment
  :department_name: Style
  :description: |-
    Check for `if` and `case` statements where each branch is used for
    assignment to the same variable when using the return of the
    condition can be used instead.
  :examples_description: |
    ```ruby
    # bad
    if foo
      bar = 1
    else
      bar = 2
    end

    case foo
    when 'a'
      bar += 1
    else
      bar += 2
    end

    if foo
      some_method
      bar = 1
    else
      some_other_method
      bar = 2
    end

    # good
    bar = if foo
            1
          else
            2
          end

    bar += case foo
           when 'a'
             1
           else
             2
           end

    bar << if foo
             some_method
             1
           else
             some_other_method
             2
           end# bad
    bar = if foo
            1
          else
            2
          end

    bar += case foo
           when 'a'
             1
           else
             2
           end

    bar << if foo
             some_method
             1
           else
             some_other_method
             2
           end

    # good
    if foo
      bar = 1
    else
      bar = 2
    end

    case foo
    when 'a'
      bar += 1
    else
      bar += 2
    end

    if foo
      some_method
      bar = 1
    else
      some_other_method
      bar = 2
    end
    ```
  :configuration:
    Description: Use the return value of `if` and `case` statements for assignment
      to a variable and variable comparison instead of assigning that variable inside
      of each branch.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: assign_to_condition
    SupportedStyles:
    - assign_to_condition
    - assign_inside_condition
    SingleLineConditionsOnly: 'true'
    IncludeTernaryExpressions: 'true'
- :name: Style/Copyright
  :department_name: Style
  :description: |-
    Check that a copyright notice was given in each source file.

    The default regexp for an acceptable copyright notice can be found in
    config/default.yml.  The default can be changed as follows:

        Style/Copyright:
          Notice: '^Copyright (\(c\) )?2\d{3} Acme Inc'

    This regex string is treated as an unanchored regex.  For each file
    that RuboCop scans, a comment that matches this regex must be found or
    an offense is reported.
  :examples_description: ''
  :configuration:
    Description: Include a copyright notice in each file before any code.
    Enabled: false
  :configurable_attributes:
    Notice: "^Copyright (\\(c\\) )?2[0-9]{3} .+"
    AutocorrectNotice: ''
- :name: Style/DateTime
  :department_name: Style
  :description: |-
    This cop checks for uses of `DateTime` that should be replaced by
    `Date` or `Time`.
  :examples_description: |
    ```ruby

    # bad - uses `DateTime` for current time
    DateTime.now

    # good - uses `Time` for current time
    Time.now

    # bad - uses `DateTime` for modern date
    DateTime.iso8601('2016-06-29')

    # good - uses `Date` for modern date
    Date.iso8601('2016-06-29')

    # good - uses `DateTime` with start argument for historical date
    DateTime.iso8601('1751-04-23', Date::ENGLAND)
    ```
  :configuration:
    Description: Use Date or Time over DateTime.
    StyleGuide: "#date--time"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/DefWithParentheses
  :department_name: Style
  :description: |-
    This cop checks for parentheses in the definition of a method,
    that does not take any arguments. Both instance and
    class/singleton methods are checked.
  :examples_description: |
    ```ruby

    # bad
    def foo()
      # does a thing
    end

    # good
    def foo
      # does a thing
    end

    # also good
    def foo() does_a_thing end
    # bad
    def Baz.foo()
      # does a thing
    end

    # good
    def Baz.foo
      # does a thing
    end
    ```
  :configuration:
    Description: Use def with parentheses when there are arguments.
    StyleGuide: "#method-parens"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/Dir
  :department_name: Style
  :description: |-
    This cop checks for places where the `#__dir__` method can replace more
    complex constructs to retrieve a canonicalized absolute path to the
    current file.
  :examples_description: |
    ```ruby
    # bad
    path = File.expand_path(File.dirname(__FILE__))

    # bad
    path = File.dirname(File.realpath(__FILE__))

    # good
    path = __dir__
    ```
  :configuration:
    Description: Use the `__dir__` method to retrieve the canonicalized absolute path
      to the current file.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/DocumentationMethod
  :department_name: Style
  :description: |-
    This cop checks for missing documentation comment for public methods.
    It can optionally be configured to also require documentation for
    non-public methods.
  :examples_description: |
    ```ruby

    # bad

    class Foo
      def bar
        puts baz
      end
    end

    module Foo
      def bar
        puts baz
      end
    end

    def foo.bar
      puts baz
    end

    # good

    class Foo
      # Documentation
      def bar
        puts baz
      end
    end

    module Foo
      # Documentation
      def bar
        puts baz
      end
    end

    # Documentation
    def foo.bar
      puts baz
    end
    ```
  :configuration:
    Description: Public methods.
    Enabled: false
  :configurable_attributes:
    Exclude:
    - "/home/miguelsavignano/Developer/Projects/rubocop/spec/**/*"
    - "/home/miguelsavignano/Developer/Projects/rubocop/test/**/*"
    RequireForNonPublicMethods: 'false'
- :name: Style/Documentation
  :department_name: Style
  :description: |-
    This cop checks for missing top-level documentation of
    classes and modules. Classes with no body are exempt from the
    check and so are namespace modules - modules that have nothing in
    their bodies except classes, other modules, or constant definitions.

    The documentation requirement is annulled if the class or module has
    a "#:nodoc:" comment next to it. Likewise, "#:nodoc: all" does the
    same for all its children.
  :examples_description: |
    ```ruby
    # bad
    class Person
      # ...
    end

    # good
    # Description/Explanation of Person class
    class Person
      # ...
    end
    ```
  :configuration:
    Description: Document classes and non-namespace modules.
    Enabled: true
  :configurable_attributes:
    Exclude:
    - "/home/miguelsavignano/Developer/Projects/rubocop/spec/**/*"
    - "/home/miguelsavignano/Developer/Projects/rubocop/test/**/*"
- :name: Style/DoubleNegation
  :department_name: Style
  :description: |-
    This cop checks for uses of double negation (!!) to convert something
    to a boolean value. As this is both cryptic and usually redundant, it
    should be avoided.

    Please, note that when something is a boolean value
    !!something and !something.nil? are not the same thing.
    As you're unlikely to write code that can accept values of any type
    this is rarely a problem in practice.
  :examples_description: |
    ```ruby

    # bad
    !!something

    # good
    !something.nil?
    ```
  :configuration:
    Description: Checks for uses of double negation (!!).
    StyleGuide: "#no-bang-bang"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EachForSimpleLoop
  :department_name: Style
  :description: |-
    This cop checks for loops which iterate a constant number of times,
    using a Range literal and `#each`. This can be done more readably using
    `Integer#times`.

    This check only applies if the block takes no parameters.
  :examples_description: |
    ```ruby
    # bad
    (1..5).each { }

    # good
    5.times { }# bad
    (0...10).each {}

    # good
    10.times {}
    ```
  :configuration:
    Description: Use `Integer#times` for a simple loop which iterates a fixed number
      of times.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EachWithObject
  :department_name: Style
  :description: |-
    This cop looks for inject / reduce calls where the passed in object is
    returned at the end and so could be replaced by each_with_object without
    the need to return the object at the end.

    However, we can't replace with each_with_object if the accumulator
    parameter is assigned to within the block.
  :examples_description: |
    ```ruby
    # bad
    [1, 2].inject({}) { |a, e| a[e] = e; a }

    # good
    [1, 2].each_with_object({}) { |e, a| a[e] = e }
    ```
  :configuration:
    Description: Prefer `each_with_object` over `inject` or `reduce`.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EmptyBlockParameter
  :department_name: Style
  :description: |-
    This cop checks for pipes for empty block parameters. Pipes for empty
    block parameters do not cause syntax errors, but they are redundant.
  :examples_description: |
    ```ruby
    # bad
    a do ||
      do_something
    end

    # bad
    a { || do_something }

    # good
    a do
    end

    # good
    a { do_something }
    ```
  :configuration:
    Description: Omit pipes for empty block parameters.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EmptyCaseCondition
  :department_name: Style
  :description: This cop checks for case statements with an empty condition.
  :examples_description: |
    ```ruby

    # bad:
    case
    when x == 0
      puts 'x is 0'
    when y == 0
      puts 'y is 0'
    else
      puts 'neither is 0'
    end

    # good:
    if x == 0
      puts 'x is 0'
    elsif y == 0
      puts 'y is 0'
    else
      puts 'neither is 0'
    end

    # good: (the case condition node is not empty)
    case n
    when 0
      puts 'zero'
    when 1
      puts 'one'
    else
      puts 'more'
    end
    ```
  :configuration:
    Description: Avoid empty condition in case statements.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EmptyElse
  :department_name: Style
  :description: |-
    Checks for empty else-clauses, possibly including comments and/or an
    explicit `nil` depending on the EnforcedStyle.
  :examples_description: |
    ```ruby
    # warn only on empty else

    # bad
    if condition
      statement
    else
    end

    # good
    if condition
      statement
    else
      nil
    end

    # good
    if condition
      statement
    else
      statement
    end

    # good
    if condition
      statement
    end# warn on else with nil in it

    # bad
    if condition
      statement
    else
      nil
    end

    # good
    if condition
      statement
    else
    end

    # good
    if condition
      statement
    else
      statement
    end

    # good
    if condition
      statement
    end# warn on empty else and else with nil in it

    # bad
    if condition
      statement
    else
      nil
    end

    # bad
    if condition
      statement
    else
    end

    # good
    if condition
      statement
    else
      statement
    end

    # good
    if condition
      statement
    end
    ```
  :configuration:
    Description: Avoid empty else-clauses.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: both
    SupportedStyles:
    - empty
    - nil
    - both
- :name: Style/EmptyLambdaParameter
  :department_name: Style
  :description: |-
    This cop checks for parentheses for empty lambda parameters. Parentheses
    for empty lambda parameters do not cause syntax errors, but they are
    redundant.
  :examples_description: |
    ```ruby
    # bad
    -> () { do_something }

    # good
    -> { do_something }

    # good
    -> (arg) { do_something(arg) }
    ```
  :configuration:
    Description: Omit parens for empty lambda parameters.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EmptyLineAfterGuardClause
  :department_name: Style
  :description: This cop enforces empty line after guard clause
  :examples_description: |
    ```ruby

    # bad
    def foo
      return if need_return?
      bar
    end

    # good
    def foo
      return if need_return?

      bar
    end

    # good
    def foo
      return if something?
      return if something_different?

      bar
    end

    # also good
    def foo
      if something?
        do_something
        return if need_return?
      end
    end
    ```
  :configuration:
    Description: Add empty line after guard clause.
    Enabled: false
  :configurable_attributes: {}
- :name: Style/EmptyLiteral
  :department_name: Style
  :description: |-
    This cop checks for the use of a method, the result of which
    would be a literal, like an empty array, hash or string.
  :examples_description: |
    ```ruby
    # bad
    a = Array.new
    h = Hash.new
    s = String.new

    # good
    a = []
    h = {}
    s = ''
    ```
  :configuration:
    Description: Prefer literals to Array.new/Hash.new/String.new.
    StyleGuide: "#literal-array-hash"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EmptyMethod
  :department_name: Style
  :description: |-
    This cop checks for the formatting of empty method definitions.
    By default it enforces empty method definitions to go on a single
    line (compact style), but it can be configured to enforce the `end`
    to go on its own line (expanded style).

    Note: A method definition is not considered empty if it contains
          comments.
  :examples_description: |
    ```ruby
    # bad
    def foo(bar)
    end

    def self.foo(bar)
    end

    # good
    def foo(bar); end

    def foo(bar)
      # baz
    end

    def self.foo(bar); end# bad
    def foo(bar); end

    def self.foo(bar); end

    # good
    def foo(bar)
    end

    def self.foo(bar)
    end
    ```
  :configuration:
    Description: Checks the formatting of empty method definitions.
    StyleGuide: "#no-single-line-methods"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: compact
    SupportedStyles:
    - compact
    - expanded
- :name: Style/Encoding
  :department_name: Style
  :description: This cop checks ensures source files have no utf-8 encoding comments.
  :examples_description: ''
  :configuration:
    Description: Use UTF-8 as the source file encoding.
    StyleGuide: "#utf-8"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EndBlock
  :department_name: Style
  :description: This cop checks for END blocks.
  :examples_description: ''
  :configuration:
    Description: Avoid the use of END blocks.
    StyleGuide: "#no-END-blocks"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EvalWithLocation
  :department_name: Style
  :description: |-
    This cop checks `eval` method usage. `eval` can receive source location
    metadata, that are filename and line number. The metadata is used by
    backtraces. This cop recommends to pass the metadata to `eval` method.
  :examples_description: |
    ```ruby
    # bad
    eval <<-RUBY
      def do_something
      end
    RUBY

    # bad
    C.class_eval <<-RUBY
      def do_something
      end
    RUBY

    # good
    eval <<-RUBY, binding, __FILE__, __LINE__ + 1
      def do_something
      end
    RUBY

    # good
    C.class_eval <<-RUBY, __FILE__, __LINE__ + 1
      def do_something
      end
    RUBY
    ```
  :configuration:
    Description: Pass `__FILE__` and `__LINE__` to `eval` method, as they are used
      by backtraces.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/EvenOdd
  :department_name: Style
  :description: |-
    This cop checks for places where Integer#even? or Integer#odd?
    should have been used.
  :examples_description: |
    ```ruby

    # bad
    if x % 2 == 0
    end

    # good
    if x.even?
    end
    ```
  :configuration:
    Description: Favor the use of Integer#even? && Integer#odd?
    StyleGuide: "#predicate-methods"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/ExpandPathArguments
  :department_name: Style
  :description: |-
    This cop checks for use of the `File.expand_path` arguments.
    Likewise, it also checks for the `Pathname.new` argument.

    Contrastive bad case and good case are alternately shown in
    the following examples.
  :examples_description: |
    ```ruby
    # bad
    File.expand_path('..', __FILE__)

    # good
    File.expand_path(__dir__)

    # bad
    File.expand_path('../..', __FILE__)

    # good
    File.expand_path('..', __dir__)

    # bad
    File.expand_path('.', __FILE__)

    # good
    File.expand_path(__FILE__)

    # bad
    Pathname(__FILE__).parent.expand_path

    # good
    Pathname(__dir__).expand_path

    # bad
    Pathname.new(__FILE__).parent.expand_path

    # good
    Pathname.new(__dir__).expand_path
    ```
  :configuration:
    Description: Use `expand_path(__dir__)` instead of `expand_path('..', __FILE__)`.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/FlipFlop
  :department_name: Style
  :description: This cop looks for uses of flip flop operator
  :examples_description: |
    ```ruby
    # bad
    (1..20).each do |x|
      puts x if (x == 5) .. (x == 10)
    end

    # good
    (1..20).each do |x|
      puts x if (x >= 5) && (x <= 10)
    end
    ```
  :configuration:
    Description: Checks for flip flops
    StyleGuide: "#no-flip-flops"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/For
  :department_name: Style
  :description: |-
    This cop looks for uses of the *for* keyword, or *each* method. The
    preferred alternative is set in the EnforcedStyle configuration
    parameter. An *each* call with a block on a single line is always
    allowed, however.
  :examples_description: |
    ```ruby
    # bad
    def foo
      for n in [1, 2, 3] do
        puts n
      end
    end

    # good
    def foo
      [1, 2, 3].each do |n|
        puts n
      end
    end# bad
    def foo
      [1, 2, 3].each do |n|
        puts n
      end
    end

    # good
    def foo
      for n in [1, 2, 3] do
        puts n
      end
    end
    ```
  :configuration:
    Description: Checks use of for or each in multiline loops.
    StyleGuide: "#no-for-loops"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: each
    SupportedStyles:
    - each
    - for
- :name: Style/FormatString
  :department_name: Style
  :description: |-
    This cop enforces the use of a single string formatting utility.
    Valid options include Kernel#format, Kernel#sprintf and String#%.

    The detection of String#% cannot be implemented in a reliable
    manner for all cases, so only two scenarios are considered -
    if the first argument is a string literal and if the second
    argument is an array literal.
  :examples_description: |
    ```ruby
    # bad
    puts sprintf('%10s', 'hoge')
    puts '%10s' % 'hoge'

    # good
    puts format('%10s', 'hoge')# bad
    puts format('%10s', 'hoge')
    puts '%10s' % 'hoge'

    # good
    puts sprintf('%10s', 'hoge')# bad
    puts format('%10s', 'hoge')
    puts sprintf('%10s', 'hoge')

    # good
    puts '%10s' % 'hoge'
    ```
  :configuration:
    Description: Enforce the use of Kernel#sprintf, Kernel#format or String#%.
    StyleGuide: "#sprintf"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: format
    SupportedStyles:
    - format
    - sprintf
    - percent
- :name: Style/FormatStringToken
  :department_name: Style
  :description: |-
    Use a consistent style for named format string tokens.

    **Note:**
    `unannotated` style cop only works for strings
    which are passed as arguments to those methods:
    `sprintf`, `format`, `%`.
    The reason is that *unannotated* format is very similar
    to encoded URLs or Date/Time formatting strings.
  :examples_description: |
    ```ruby

    # bad
    format('%{greeting}', greeting: 'Hello')
    format('%s', 'Hello')

    # good
    format('%<greeting>s', greeting: 'Hello')
    # bad
    format('%<greeting>s', greeting: 'Hello')
    format('%s', 'Hello')

    # good
    format('%{greeting}', greeting: 'Hello')
    # bad
    format('%<greeting>s', greeting: 'Hello')
    format('%{greeting}', 'Hello')

    # good
    format('%s', 'Hello')
    ```
  :configuration:
    Description: Use a consistent style for format string tokens.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: annotated
    SupportedStyles:
    - annotated
    - template
    - unannotated
- :name: Style/FrozenStringLiteralComment
  :department_name: Style
  :description: |-
    This cop is designed to help upgrade to Ruby 3.0. It will add the
    comment `# frozen_string_literal: true` to the top of files to
    enable frozen string literals. Frozen string literals may be default
    in Ruby 3.0. The comment will be added below a shebang and encoding
    comment. The frozen string literal comment is only valid in Ruby 2.3+.
  :examples_description: |
    ```ruby
    # The `when_needed` style will add the frozen string literal comment
    # to files only when the `TargetRubyVersion` is set to 2.3+.
    # bad
    module Foo
      # ...
    end

    # good
    # frozen_string_literal: true

    module Foo
      # ...
    end# The `always` style will always add the frozen string literal comment
    # to a file, regardless of the Ruby version or if `freeze` or `<<` are
    # called on a string literal.
    # bad
    module Bar
      # ...
    end

    # good
    # frozen_string_literal: true

    module Bar
      # ...
    end# The `never` will enforce that the frozen string literal comment does
    # not exist in a file.
    # bad
    # frozen_string_literal: true

    module Baz
      # ...
    end

    # good
    module Baz
      # ...
    end
    ```
  :configuration:
    Description: Add the frozen_string_literal comment to the top of files to help
      transition from Ruby 2.3.0 to Ruby 3.0.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: when_needed
    SupportedStyles:
    - when_needed
    - always
    - never
- :name: Style/GlobalVars
  :department_name: Style
  :description: |-
    This cops looks for uses of global variables.
    It does not report offenses for built-in global variables.
    Built-in global variables are allowed by default. Additionally
    users can allow additional variables via the AllowedVariables option.

    Note that backreferences like $1, $2, etc are not global variables.
  :examples_description: |
    ```ruby
    # bad
    $foo = 2
    bar = $foo + 5

    # good
    FOO = 2
    foo = 2
    $stdin.read
    ```
  :configuration:
    Description: Do not introduce global variables.
    StyleGuide: "#instance-vars"
    Reference: http://www.zenspider.com/Languages/Ruby/QuickRef.html
    Enabled: true
  :configurable_attributes:
    AllowedVariables: []
- :name: Style/GuardClause
  :department_name: Style
  :description: |-
    Use a guard clause instead of wrapping the code inside a conditional
    expression
  :examples_description: |
    ```ruby
    # bad
    def test
      if something
        work
      end
    end

    # good
    def test
      return unless something
      work
    end

    # also good
    def test
      work if something
    end

    # bad
    if something
      raise 'exception'
    else
      ok
    end

    # good
    raise 'exception' if something
    ok
    ```
  :configuration:
    Description: Check for conditionals that can be replaced with guard clauses
    StyleGuide: "#no-nested-conditionals"
    Enabled: true
  :configurable_attributes:
    MinBodyLength: '1'
- :name: Style/HashSyntax
  :department_name: Style
  :description: |-
    This cop checks hash literal syntax.

    It can enforce either the use of the class hash rocket syntax or
    the use of the newer Ruby 1.9 syntax (when applicable).

    A separate offense is registered for each problematic pair.

    The supported styles are:

    * ruby19 - forces use of the 1.9 syntax (e.g. `{a: 1}`) when hashes have
      all symbols for keys
    * hash_rockets - forces use of hash rockets for all hashes
    * no_mixed_keys - simply checks for hashes with mixed syntaxes
    * ruby19_no_mixed_keys - forces use of ruby 1.9 syntax and forbids mixed
      syntax hashes
  :examples_description: |
    ```ruby
    # bad
    {:a => 2}
    {b: 1, :c => 2}

    # good
    {a: 2, b: 1}
    {:c => 2, 'd' => 2} # acceptable since 'd' isn't a symbol
    {d: 1, 'e' => 2} # technically not forbidden# bad
    {a: 1, b: 2}
    {c: 1, 'd' => 5}

    # good
    {:a => 1, :b => 2}# bad
    {:a => 1, b: 2}
    {c: 1, 'd' => 2}

    # good
    {:a => 1, :b => 2}
    {c: 1, d: 2}# bad
    {:a => 1, :b => 2}
    {c: 2, 'd' => 3} # should just use hash rockets

    # good
    {a: 1, b: 2}
    {:c => 3, 'd' => 4}
    ```
  :configuration:
    Description: 'Prefer Ruby 1.9 hash syntax { a: 1, b: 2 } over 1.8 syntax { :a
      => 1, :b => 2 }.'
    StyleGuide: "#hash-literals"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: ruby19
    SupportedStyles:
    - ruby19
    - hash_rockets
    - no_mixed_keys
    - ruby19_no_mixed_keys
    UseHashRocketsWithSymbolValues: 'false'
    PreferHashRocketsForNonAlnumEndingSymbols: 'false'
- :name: Style/IdenticalConditionalBranches
  :department_name: Style
  :description: |-
    This cop checks for identical lines at the beginning or end of
    each branch of a conditional statement.
  :examples_description: |
    ```ruby
    # bad
    if condition
      do_x
      do_z
    else
      do_y
      do_z
    end

    # good
    if condition
      do_x
    else
      do_y
    end
    do_z

    # bad
    if condition
      do_z
      do_x
    else
      do_z
      do_y
    end

    # good
    do_z
    if condition
      do_x
    else
      do_y
    end

    # bad
    case foo
    when 1
      do_x
    when 2
      do_x
    else
      do_x
    end

    # good
    case foo
    when 1
      do_x
      do_y
    when 2
      # nothing
    else
      do_x
      do_z
    end
    ```
  :configuration:
    Description: Checks that conditional statements do not have an identical line
      at the end of each branch, which can validly be moved out of the conditional.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/IfInsideElse
  :department_name: Style
  :description: |-
    If the `else` branch of a conditional consists solely of an `if` node,
    it can be combined with the `else` to become an `elsif`.
    This helps to keep the nesting level from getting too deep.
  :examples_description: |
    ```ruby
    # bad
    if condition_a
      action_a
    else
      if condition_b
        action_b
      else
        action_c
      end
    end

    # good
    if condition_a
      action_a
    elsif condition_b
      action_b
    else
      action_c
    end
    ```
  :configuration:
    Description: Finds if nodes inside else, which can be converted to elsif.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/IfUnlessModifier
  :department_name: Style
  :description: |-
    Checks for if and unless statements that would fit on one line
    if written as a modifier if/unless. The maximum line length is
    configured in the `Metrics/LineLength` cop.
  :examples_description: |
    ```ruby
    # bad
    if condition
      do_stuff(bar)
    end

    unless qux.empty?
      Foo.do_something
    end

    # good
    do_stuff(bar) if condition
    Foo.do_something unless qux.empty?
    ```
  :configuration:
    Description: Favor modifier if/unless usage when you have a single-line body.
    StyleGuide: "#if-as-a-modifier"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/IfUnlessModifierOfIfUnless
  :department_name: Style
  :description: |-
    Checks for if and unless statements used as modifiers of other if or
    unless statements.
  :examples_description: |
    ```ruby

    # bad
    tired? ? 'stop' : 'go faster' if running?

    # bad
    if tired?
      "please stop"
    else
      "keep going"
    end if running?

    # good
    if running?
      tired? ? 'stop' : 'go faster'
    end
    ```
  :configuration:
    Description: Avoid modifier if/unless usage on conditionals.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/IfWithSemicolon
  :department_name: Style
  :description: Checks for uses of semicolon in if statements.
  :examples_description: |
    ```ruby

    # bad
    result = if some_condition; something else another_thing end

    # good
    result = some_condition ? something : another_thing
    ```
  :configuration:
    Description: Do not use if x; .... Use the ternary operator instead.
    StyleGuide: "#no-semicolon-ifs"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/ImplicitRuntimeError
  :department_name: Style
  :description: |-
    This cop checks for `raise` or `fail` statements which do not specify an
    explicit exception class. (This raises a `RuntimeError`. Some projects
    might prefer to use exception classes which more precisely identify the
    nature of the error.)
  :examples_description: |
    ```ruby
    # bad
    raise 'Error message here'

    # good
    raise ArgumentError, 'Error message here'
    ```
  :configuration:
    Description: Use `raise` or `fail` with an explicit exception class and message,
      rather than just a message.
    Enabled: false
  :configurable_attributes: {}
- :name: Style/InfiniteLoop
  :department_name: Style
  :description: Use `Kernel#loop` for infinite loops.
  :examples_description: |
    ```ruby
    # bad
    while true
      work
    end

    # good
    loop do
      work
    end
    ```
  :configuration:
    Description: Use Kernel#loop for infinite loops.
    StyleGuide: "#infinite-loop"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/InverseMethods
  :department_name: Style
  :description: |-
    This cop check for usages of not (`not` or `!`) called on a method
    when an inverse of that method can be used instead.
    Methods that can be inverted by a not (`not` or `!`) should be defined
    in `InverseMethods`
    Methods that are inverted by inverting the return
    of the block that is passed to the method should be defined in
    `InverseBlocks`
  :examples_description: |
    ```ruby
    # bad
    !foo.none?
    !foo.any? { |f| f.even? }
    !foo.blank?
    !(foo == bar)
    foo.select { |f| !f.even? }
    foo.reject { |f| f != 7 }

    # good
    foo.none?
    foo.blank?
    foo.any? { |f| f.even? }
    foo != bar
    foo == bar
    !!('foo' =~ /^\w+$/)
    !(foo.class < Numeric) # Checking class hierarchy is allowed
    ```
  :configuration:
    Description: Use the inverse method instead of `!.method` if an inverse method
      is defined.
    Enabled: true
  :configurable_attributes:
    InverseMethods: "{:any?=>:none?, :even?=>:odd?, :===>:!=, :=~=>:!~, :<=>:>=, :>=>:<=}"
    InverseBlocks: "{:select=>:reject, :select!=>:reject!}"
- :name: Style/InlineComment
  :department_name: Style
  :description: This cop checks for trailing inline comments.
  :examples_description: |
    ```ruby

    # good
    foo.each do |f|
      # Standalone comment
      f.bar
    end

    # bad
    foo.each do |f|
      f.bar # Trailing inline comment
    end
    ```
  :configuration:
    Description: Avoid trailing inline comments.
    Enabled: false
  :configurable_attributes: {}
- :name: Style/Lambda
  :department_name: Style
  :description: |-
    This cop (by default) checks for uses of the lambda literal syntax for
    single line lambdas, and the method call syntax for multiline lambdas.
    It is configurable to enforce one of the styles for both single line
    and multiline lambdas as well.
  :examples_description: |
    ```ruby
    # bad
    f = lambda { |x| x }
    f = ->(x) do
          x
        end

    # good
    f = ->(x) { x }
    f = lambda do |x|
          x
        end# bad
    f = ->(x) { x }
    f = ->(x) do
          x
        end

    # good
    f = lambda { |x| x }
    f = lambda do |x|
          x
        end# bad
    f = lambda { |x| x }
    f = lambda do |x|
          x
        end

    # good
    f = ->(x) { x }
    f = ->(x) do
          x
        end
    ```
  :configuration:
    Description: Use the new lambda literal syntax for single-line blocks.
    StyleGuide: "#lambda-multi-line"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: line_count_dependent
    SupportedStyles:
    - line_count_dependent
    - lambda
    - literal
- :name: Style/LambdaCall
  :department_name: Style
  :description: This cop checks for use of the lambda.(args) syntax.
  :examples_description: |
    ```ruby
    # bad
    lambda.(x, y)

    # good
    lambda.call(x, y)# bad
    lambda.call(x, y)

    # good
    lambda.(x, y)
    ```
  :configuration:
    Description: Use lambda.call(...) instead of lambda.(...).
    StyleGuide: "#proc-call"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: call
    SupportedStyles:
    - call
    - braces
- :name: Style/LineEndConcatenation
  :department_name: Style
  :description: |-
    This cop checks for string literal concatenation at
    the end of a line.
  :examples_description: |
    ```ruby

    # bad
    some_str = 'ala' +
               'bala'

    some_str = 'ala' <<
               'bala'

    # good
    some_str = 'ala' \
               'bala'
    ```
  :configuration:
    Description: Use \ instead of + or << to concatenate two string literals at line
      end.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/MethodCallWithoutArgsParentheses
  :department_name: Style
  :description: This cop checks for unwanted parentheses in parameterless method calls.
  :examples_description: |
    ```ruby
    # bad
    object.some_method()

    # good
    object.some_method
    ```
  :configuration:
    Description: Do not use parentheses for method calls with no arguments.
    StyleGuide: "#method-invocation-parens"
    Enabled: true
  :configurable_attributes:
    IgnoredMethods: []
- :name: Style/MethodCallWithArgsParentheses
  :department_name: Style
  :description: |-
    This cop checks presence of parentheses in method calls containing
    parameters. By default, macro methods are ignored. Additional methods
    can be added to the `IgnoredMethods` list.
  :examples_description: |
    ```ruby

    # bad
    array.delete e

    # good
    array.delete(e)

    # good
    # Operators don't need parens
    foo == bar

    # good
    # Setter methods don't need parens
    foo.bar = baz

    # okay with `puts` listed in `IgnoredMethods`
    puts 'test'

    # IgnoreMacros: true (default)

    # good
    class Foo
      bar :baz
    end

    # IgnoreMacros: false

    # bad
    class Foo
      bar :baz
    end
    ```
  :configuration:
    Description: Use parentheses for method calls with arguments.
    StyleGuide: "#method-invocation-parens"
    Enabled: false
  :configurable_attributes:
    IgnoreMacros: 'true'
    IgnoredMethods: []
- :name: Style/MethodCalledOnDoEndBlock
  :department_name: Style
  :description: |-
    This cop checks for methods called on a do...end block. The point of
    this check is that it's easy to miss the call tacked on to the block
    when reading code.
  :examples_description: |
    ```ruby

    a do
      b
    end.c
    ```
  :configuration:
    Description: Avoid chaining a method call on a do...end block.
    StyleGuide: "#single-line-blocks"
    Enabled: false
  :configurable_attributes: {}
- :name: Style/MethodDefParentheses
  :department_name: Style
  :description: |-
    This cops checks for parentheses around the arguments in method
    definitions. Both instance and class/singleton methods are checked.
  :examples_description: |
    ```ruby
    # The `require_parentheses` style requires method definitions
    # to always use parentheses

    # bad
    def bar num1, num2
      num1 + num2
    end

    def foo descriptive_var_name,
            another_descriptive_var_name,
            last_descriptive_var_name
      do_something
    end

    # good
    def bar(num1, num2)
      num1 + num2
    end

    def foo(descriptive_var_name,
            another_descriptive_var_name,
            last_descriptive_var_name)
      do_something
    end# The `require_no_parentheses` style requires method definitions
    # to never use parentheses

    # bad
    def bar(num1, num2)
      num1 + num2
    end

    def foo(descriptive_var_name,
            another_descriptive_var_name,
            last_descriptive_var_name)
      do_something
    end

    # good
    def bar num1, num2
      num1 + num2
    end

    def foo descriptive_var_name,
            another_descriptive_var_name,
            last_descriptive_var_name
      do_something
    end# The `require_no_parentheses_except_multiline` style prefers no
    # parantheses when method definition arguments fit on single line,
    # but prefers parantheses when arguments span multiple lines.

    # bad
    def bar(num1, num2)
      num1 + num2
    end

    def foo descriptive_var_name,
            another_descriptive_var_name,
            last_descriptive_var_name
      do_something
    end

    # good
    def bar num1, num2
      num1 + num2
    end

    def foo(descriptive_var_name,
            another_descriptive_var_name,
            last_descriptive_var_name)
      do_something
    end
    ```
  :configuration:
    Description: Checks if the method definitions have or don't have parentheses.
    StyleGuide: "#method-parens"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: require_parentheses
    SupportedStyles:
    - require_parentheses
    - require_no_parentheses
    - require_no_parentheses_except_multiline
- :name: Style/MethodMissingSuper
  :department_name: Style
  :description: |-
    This cop checks for the presence of `method_missing` without
    falling back on `super`.
  :examples_description: |
    ```ruby
    #bad
    def method_missing(name, *args)
      # ...
    end

    #good

    def method_missing(name, *args)
      # ...
      super
    end
    ```
  :configuration:
    Description: Checks for `method_missing` to call `super`.
    StyleGuide: "#no-method-missing"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/MinMax
  :department_name: Style
  :description: This cop checks for potential uses of `Enumerable#minmax`.
  :examples_description: |
    ```ruby

    # bad
    bar = [foo.min, foo.max]
    return foo.min, foo.max

    # good
    bar = foo.minmax
    return foo.minmax
    ```
  :configuration:
    Description: Use `Enumerable#minmax` instead of `Enumerable#min` and `Enumerable#max`
      in conjunction.'
    Enabled: true
  :configurable_attributes: {}
- :name: Style/MissingElse
  :department_name: Style
  :description: |-
    Checks for `if` expressions that do not have an `else` branch.

    Supported styles are: if, case, both.
  :examples_description: |
    ```ruby
    # warn when an `if` expression is missing an `else` branch.

    # bad
    if condition
      statement
    end

    # good
    if condition
      statement
    else
      # the content of `else` branch will be determined by Style/EmptyElse
    end

    # good
    case var
    when condition
      statement
    end

    # good
    case var
    when condition
      statement
    else
      # the content of `else` branch will be determined by Style/EmptyElse
    end# warn when a `case` expression is missing an `else` branch.

    # bad
    case var
    when condition
      statement
    end

    # good
    case var
    when condition
      statement
    else
      # the content of `else` branch will be determined by Style/EmptyElse
    end

    # good
    if condition
      statement
    end

    # good
    if condition
      statement
    else
      # the content of `else` branch will be determined by Style/EmptyElse
    end# warn when an `if` or `case` expression is missing an `else` branch.

    # bad
    if condition
      statement
    end

    # bad
    case var
    when condition
      statement
    end

    # good
    if condition
      statement
    else
      # the content of `else` branch will be determined by Style/EmptyElse
    end

    # good
    case var
    when condition
      statement
    else
      # the content of `else` branch will be determined by Style/EmptyElse
    end
    ```
  :configuration:
    Description: Require if/case expressions to have an else branches. If enabled,
      it is recommended that Style/UnlessElse and Style/EmptyElse be enabled. This
      will conflict with Style/EmptyElse if Style/EmptyElse is configured to style
      "both"
    Enabled: false
  :configurable_attributes:
    EnforcedStyle: both
    SupportedStyles:
    - if
    - case
    - both
- :name: Style/MissingRespondToMissing
  :department_name: Style
  :description: |-
    This cop checks for the presence of `method_missing` without also
    defining `respond_to_missing?`.
  :examples_description: |
    ```ruby
    #bad
    def method_missing(name, *args)
      # ...
    end

    #good
    def respond_to_missing?(name, include_private)
      # ...
    end

    def method_missing(name, *args)
      # ...
    end
    ```
  :configuration:
    Description: Checks if `method_missing` is implemented without implementing `respond_to_missing`.
    StyleGuide: "#no-method-missing"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/MixinGrouping
  :department_name: Style
  :description: |-
    This cop checks for grouping of mixins in `class` and `module` bodies.
    By default it enforces mixins to be placed in separate declarations,
    but it can be configured to enforce grouping them in one declaration.
  :examples_description: |
    ```ruby
    # bad
    class Foo
      include Bar, Qox
    end

    # good
    class Foo
      include Qox
      include Bar
    end# bad
    class Foo
      extend Bar
      extend Qox
    end

    # good
    class Foo
      extend Qox, Bar
    end
    ```
  :configuration:
    Description: Checks for grouping of mixins in `class` and `module` bodies.
    StyleGuide: "#mixin-grouping"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: separated
    SupportedStyles:
    - separated
    - grouped
- :name: Style/MixinUsage
  :department_name: Style
  :description: |-
    This cop checks that `include`, `extend` and `prepend` statements appear
    inside classes and modules, not at the top level, so as to not affect
    the behavior of `Object`.
  :examples_description: |
    ```ruby
    # bad
    include M

    class C
    end

    # bad
    extend M

    class C
    end

    # bad
    prepend M

    class C
    end

    # good
    class C
      include M
    end

    # good
    class C
      extend M
    end

    # good
    class C
      prepend M
    end
    ```
  :configuration:
    Description: Checks that `include`, `extend` and `prepend` exists at the top level.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/ModuleFunction
  :department_name: Style
  :description: |-
    This cops checks for use of `extend self` or `module_function` in a
    module.

    Supported styles are: module_function, extend_self.

    These offenses are not auto-corrected since there are different
    implications to each approach.
  :examples_description: |
    ```ruby
    # bad
    module Test
      extend self
      # ...
    end

    # good
    module Test
      module_function
      # ...
    end# bad
    module Test
      module_function
      # ...
    end

    # good
    module Test
      extend self
      # ...
    end
    ```
  :configuration:
    Description: Checks for usage of `extend self` in modules.
    StyleGuide: "#module-function"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: module_function
    SupportedStyles:
    - module_function
    - extend_self
- :name: Style/MultilineBlockChain
  :department_name: Style
  :description: |-
    This cop checks for chaining of a block after another block that spans
    multiple lines.
  :examples_description: |
    ```ruby

    Thread.list.find_all do |t|
      t.alive?
    end.map do |t|
      t.object_id
    end
    ```
  :configuration:
    Description: Avoid multi-line chains of blocks.
    StyleGuide: "#single-line-blocks"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/MultilineIfThen
  :department_name: Style
  :description: Checks for uses of the `then` keyword in multi-line if statements.
  :examples_description: |
    ```ruby
    # bad
    # This is considered bad practice.
    if cond then
    end

    # good
    # If statements can contain `then` on the same line.
    if cond then a
    elsif cond then b
    end
    ```
  :configuration:
    Description: Do not use then for multi-line if/unless.
    StyleGuide: "#no-then"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/MultilineIfModifier
  :department_name: Style
  :description: Checks for uses of if/unless modifiers with multiple-lines bodies.
  :examples_description: |
    ```ruby

    # bad
    {
      result: 'this should not happen'
    } unless cond

    # good
    { result: 'ok' } if cond
    ```
  :configuration:
    Description: Only use if/unless modifiers on single line statements.
    StyleGuide: "#no-multiline-if-modifiers"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/MultilineMemoization
  :department_name: Style
  :description: This cop checks expressions wrapping styles for multiline memoization.
  :examples_description: |
    ```ruby
    # bad
    foo ||= (
      bar
      baz
    )

    # good
    foo ||= begin
      bar
      baz
    end# bad
    foo ||= begin
      bar
      baz
    end

    # good
    foo ||= (
      bar
      baz
    )
    ```
  :configuration:
    Description: Wrap multiline memoizations in a `begin` and `end` block.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: keyword
    SupportedStyles:
    - keyword
    - braces
- :name: Style/MultilineTernaryOperator
  :department_name: Style
  :description: This cop checks for multi-line ternary op expressions.
  :examples_description: |
    ```ruby
    # bad
    a = cond ?
      b : c
    a = cond ? b :
        c
    a = cond ?
        b :
        c

    # good
    a = cond ? b : c
    a =
      if cond
        b
      else
        c
      end
    ```
  :configuration:
    Description: 'Avoid multi-line ?: (the ternary operator); use if/unless instead.'
    StyleGuide: "#no-multiline-ternary"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/MultipleComparison
  :department_name: Style
  :description: |-
    This cop checks against comparing a variable with multiple items, where
    `Array#include?` could be used instead to avoid code repetition.
  :examples_description: |
    ```ruby
    # bad
    a = 'a'
    foo if a == 'a' || a == 'b' || a == 'c'

    # good
    a = 'a'
    foo if ['a', 'b', 'c'].include?(a)
    ```
  :configuration:
    Description: Avoid comparing a variable with multiple items in a conditional,
      use Array#include? instead.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/MutableConstant
  :department_name: Style
  :description: |-
    This cop checks whether some constant value isn't a
    mutable literal (e.g. array or hash).
  :examples_description: |
    ```ruby
    # bad
    CONST = [1, 2, 3]

    # good
    CONST = [1, 2, 3].freeze

    # good
    CONST = <<~TESTING.freeze
    This is a heredoc
    TESTING
    ```
  :configuration:
    Description: Do not assign mutable objects to constants.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/NegatedIf
  :department_name: Style
  :description: |-
    Checks for uses of if with a negated condition. Only ifs
    without else are considered. There are three different styles:

      - both
      - prefix
      - postfix
  :examples_description: |
    ```ruby
    # enforces `unless` for `prefix` and `postfix` conditionals

    # bad

    if !foo
      bar
    end

    # good

    unless foo
      bar
    end

    # bad

    bar if !foo

    # good

    bar unless foo# enforces `unless` for just `prefix` conditionals

    # bad

    if !foo
      bar
    end

    # good

    unless foo
      bar
    end

    # good

    bar if !foo# enforces `unless` for just `postfix` conditionals

    # bad

    bar if !foo

    # good

    bar unless foo

    # good

    if !foo
      bar
    end
    ```
  :configuration:
    Description: Favor unless over if for negative conditions (or control flow or).
    StyleGuide: "#unless-for-negatives"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: both
    SupportedStyles:
    - both
    - prefix
    - postfix
- :name: Style/NegatedWhile
  :department_name: Style
  :description: Checks for uses of while with a negated condition.
  :examples_description: |
    ```ruby
    # bad
    while !foo
      bar
    end

    # good
    until foo
      bar
    end

    # bad
    bar until !foo

    # good
    bar while foo
    bar while !foo && baz
    ```
  :configuration:
    Description: Favor until over while for negative conditions.
    StyleGuide: "#until-for-negatives"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/NestedModifier
  :department_name: Style
  :description: |-
    This cop checks for nested use of if, unless, while and until in their
    modifier form.
  :examples_description: |
    ```ruby

    # bad
    something if a if b

    # good
    something if b && a
    ```
  :configuration:
    Description: Avoid using nested modifiers.
    StyleGuide: "#no-nested-modifiers"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/NestedParenthesizedCalls
  :department_name: Style
  :description: |-
    This cop checks for unparenthesized method calls in the argument list
    of a parenthesized method call.
  :examples_description: |
    ```ruby
    # good
    method1(method2(arg), method3(arg))

    # bad
    method1(method2 arg, method3, arg)
    ```
  :configuration:
    Description: Parenthesize method calls which are nested inside the argument list
      of another parenthesized method call.
    Enabled: true
  :configurable_attributes:
    Whitelist:
    - be
    - be_a
    - be_an
    - be_between
    - be_falsey
    - be_kind_of
    - be_instance_of
    - be_truthy
    - be_within
    - eq
    - eql
    - end_with
    - include
    - match
    - raise_error
    - respond_to
    - start_with
- :name: Style/NestedTernaryOperator
  :department_name: Style
  :description: This cop checks for nested ternary op expressions.
  :examples_description: |
    ```ruby
    # bad
    a ? (b ? b1 : b2) : a2

    # good
    if a
      b ? b1 : b2
    else
      a2
    end
    ```
  :configuration:
    Description: Use one expression per branch in a ternary operator.
    StyleGuide: "#no-nested-ternary"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/Next
  :department_name: Style
  :description: Use `next` to skip iteration instead of a condition at the end.
  :examples_description: |
    ```ruby
    # bad
    [1, 2].each do |a|
      if a == 1
        puts a
      end
    end

    # good
    [1, 2].each do |a|
      next unless a == 1
      puts a
    end

    # good
    [1, 2].each do |o|
      puts o unless o == 1
    end# With `always` all conditions at the end of an iteration needs to be
    # replaced by next - with `skip_modifier_ifs` the modifier if like
    # this one are ignored: `[1, 2].each { |a| return 'yes' if a == 1 }`

    # bad
    [1, 2].each do |o|
      puts o unless o == 1
    end

    # bad
    [1, 2].each do |a|
      if a == 1
        puts a
      end
    end

    # good
    [1, 2].each do |a|
      next unless a == 1
      puts a
    end
    ```
  :configuration:
    Description: Use `next` to skip iteration instead of a condition at the end.
    StyleGuide: "#no-nested-conditionals"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: skip_modifier_ifs
    MinBodyLength: '3'
    SupportedStyles:
    - skip_modifier_ifs
    - always
- :name: Style/NilComparison
  :department_name: Style
  :description: This cop checks for comparison of something with nil using ==.
  :examples_description: |
    ```ruby

    # bad
    if x == nil
    end

    # good
    if x.nil?
    end
    ```
  :configuration:
    Description: Prefer x.nil? to x == nil.
    StyleGuide: "#predicate-methods"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/NonNilCheck
  :department_name: Style
  :description: |-
    This cop checks for non-nil checks, which are usually redundant.

    Non-nil checks are allowed if they are the final nodes of predicate.

      # good
      def signed_in?
        !current_user.nil?
      end
  :examples_description: |
    ```ruby

    # bad
    if x != nil
    end

    # good (when not allowing semantic changes)
    # bad (when allowing semantic changes)
    if !x.nil?
    end

    # good (when allowing semantic changes)
    if x
    end
    ```
  :configuration:
    Description: Checks for redundant nil checks.
    StyleGuide: "#no-non-nil-checks"
    Enabled: true
  :configurable_attributes:
    IncludeSemanticChanges: 'false'
- :name: Style/Not
  :department_name: Style
  :description: This cop checks for uses of the keyword `not` instead of `!`.
  :examples_description: |
    ```ruby

    # bad - parentheses are required because of op precedence
    x = (not something)

    # good
    x = !something
    ```
  :configuration:
    Description: Use ! instead of not.
    StyleGuide: "#bang-not-not"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/NumericLiterals
  :department_name: Style
  :description: |-
    This cop checks for big numeric literals without _ between groups
    of digits in them.
  :examples_description: |
    ```ruby

    # bad

    1000000
    1_00_000
    1_0000

    # good

    1_000_000
    1000

    # good unless Strict is set

    10_000_00 # typical representation of $10,000 in cents
    ```
  :configuration:
    Description: Add underscores to large numeric literals to improve their readability.
    StyleGuide: "#underscores-in-numerics"
    Enabled: true
  :configurable_attributes:
    MinDigits: '5'
    Strict: 'false'
- :name: Style/NumericLiteralPrefix
  :department_name: Style
  :description: |-
    This cop checks for octal, hex, binary and decimal literals using
    uppercase prefixes and corrects them to lowercase prefix
    or no prefix (in case of decimals).
    eg. for octal use `0o` instead of `0` or `0O`.

    Can be configured to use `0` only for octal literals using
    `EnforcedOctalStyle` => `zero_only`
  :examples_description: ''
  :configuration:
    Description: Use smallcase prefixes for numeric literals.
    StyleGuide: "#numeric-literal-prefixes"
    Enabled: true
  :configurable_attributes:
    EnforcedOctalStyle: zero_with_o
    SupportedOctalStyles:
    - zero_with_o
    - zero_only
- :name: Style/NumericPredicate
  :department_name: Style
  :description: |-
    This cop checks for usage of comparison operators (`==`,
    `>`, `<`) to test numbers as zero, positive, or negative.
    These can be replaced by their respective predicate methods.
    The cop can also be configured to do the reverse.

    The cop disregards `#nonzero?` as it its value is truthy or falsey,
    but not `true` and `false`, and thus not always interchangeable with
    `!= 0`.

    The cop ignores comparisons to global variables, since they are often
    populated with objects which can be compared with integers, but are
    not themselves `Integer` polymorphic.
  :examples_description: |
    ```ruby
    # bad

    foo == 0
    0 > foo
    bar.baz > 0

    # good

    foo.zero?
    foo.negative?
    bar.baz.positive?# bad

    foo.zero?
    foo.negative?
    bar.baz.positive?

    # good

    foo == 0
    0 > foo
    bar.baz > 0
    ```
  :configuration:
    Description: Checks for the use of predicate- or comparison methods for numeric
      comparisons.
    StyleGuide: "#predicate-methods"
    Enabled: true
  :configurable_attributes:
    AutoCorrect: 'false'
    EnforcedStyle: predicate
    SupportedStyles:
    - predicate
    - comparison
    Exclude:
    - "/home/miguelsavignano/Developer/Projects/rubocop/spec/**/*"
- :name: Style/OneLineConditional
  :department_name: Style
  :description: |-
    TODO: Make configurable.
    Checks for uses of if/then/else/end on a single line.
  :examples_description: |
    ```ruby
    # bad
    if foo then boo else doo end
    unless foo then boo else goo end

    # good
    foo ? boo : doo
    boo if foo
    if foo then boo end

    # good
    if foo
      boo
    else
      doo
    end
    ```
  :configuration:
    Description: Favor the ternary operator(?:) over if/then/else/end constructs.
    StyleGuide: "#ternary-operator"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/OrAssignment
  :department_name: Style
  :description: This cop checks for potential usage of the `||=` operator.
  :examples_description: |
    ```ruby
    # bad
    name = name ? name : 'Bozhidar'

    # bad
    name = if name
             name
           else
             'Bozhidar'
           end

    # bad
    unless name
      name = 'Bozhidar'
    end

    # bad
    name = 'Bozhidar' unless name

    # good - set name to 'Bozhidar', only if it's nil or false
    name ||= 'Bozhidar'
    ```
  :configuration:
    Description: Recommend usage of double pipe equals (||=) where applicable.
    StyleGuide: "#double-pipe-for-uninit"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/OptionHash
  :department_name: Style
  :description: |-
    This cop checks for options hashes and discourages them if the
    current Ruby version supports keyword arguments.
  :examples_description: |
    ```ruby

    # bad
    def fry(options = {})
      temperature = options.fetch(:temperature, 300)
      # ...
    end

    # good
    def fry(temperature: 300)
      # ...
    end
    ```
  :configuration:
    Description: Don't use option hashes when you can use keyword arguments.
    Enabled: false
  :configurable_attributes:
    SuspiciousParamNames:
    - options
    - opts
    - args
    - params
    - parameters
- :name: Style/OptionalArguments
  :department_name: Style
  :description: |-
    This cop checks for optional arguments to methods
    that do not come at the end of the argument list
  :examples_description: |
    ```ruby
    # bad
    def foo(a = 1, b, c)
    end

    # good
    def baz(a, b, c = 1)
    end

    def foobar(a = 1, b = 2, c = 3)
    end
    ```
  :configuration:
    Description: Checks for optional arguments that do not appear at the end of the
      argument list
    StyleGuide: "#optional-arguments"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/ParallelAssignment
  :department_name: Style
  :description: |-
    Checks for simple usages of parallel assignment.
    This will only complain when the number of variables
    being assigned matched the number of assigning variables.
  :examples_description: |
    ```ruby
    # bad
    a, b, c = 1, 2, 3
    a, b, c = [1, 2, 3]

    # good
    one, two = *foo
    a, b = foo()
    a, b = b, a

    a = 1
    b = 2
    c = 3
    ```
  :configuration:
    Description: Check for simple usages of parallel assignment. It will only warn
      when the number of variables matches on both sides of the assignment.
    StyleGuide: "#parallel-assignment"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/ParenthesesAroundCondition
  :department_name: Style
  :description: |-
    This cop checks for the presence of superfluous parentheses around the
    condition of if/unless/while/until.
  :examples_description: |
    ```ruby
    # bad
    x += 1 while (x < 10)
    foo unless (bar || baz)

    if (x > 10)
    elsif (x < 3)
    end

    # good
    x += 1 while x < 10
    foo unless bar || baz

    if x > 10
    elsif x < 3
    end# bad
    if (x > 10 &&
       y > 10)
    end

    # good
     if x > 10 &&
        y > 10
     end# good
    if (x > 10 &&
       y > 10)
    end
    ```
  :configuration:
    Description: Don't use parentheses around the condition of an if/unless/while.
    StyleGuide: "#no-parens-around-condition"
    Enabled: true
  :configurable_attributes:
    AllowSafeAssignment: 'true'
    AllowInMultilineConditions: 'false'
- :name: Style/PercentLiteralDelimiters
  :department_name: Style
  :description: |-
    This cop enforces the consistent usage of `%`-literal delimiters.

    Specify the 'default' key to set all preferred delimiters at once. You
    can continue to specify individual preferred delimiters to override the
    default.
  :examples_description: |
    ```ruby
    # Style/PercentLiteralDelimiters:
    #   PreferredDelimiters:
    #     default: '[]'
    #     '%i':    '()'

    # good
    %w[alpha beta] + %i(gamma delta)

    # bad
    %W(alpha #{beta})

    # bad
    %I(alpha beta)
    ```
  :configuration:
    Description: Use `%`-literal delimiters consistently
    StyleGuide: "#percent-literal-braces"
    Enabled: true
  :configurable_attributes:
    PreferredDelimiters: '{"default"=>"()", "%i"=>"[]", "%I"=>"[]", "%r"=>"{}", "%w"=>"[]",
      "%W"=>"[]"}'
- :name: Style/PercentQLiterals
  :department_name: Style
  :description: This cop checks for usage of the %Q() syntax when %q() would do.
  :examples_description: |
    ```ruby
    # The `lower_case_q` style prefers `%q` unless
    # interpolation is needed.
    # bad
    %Q[Mix the foo into the baz.]
    %Q(They all said: 'Hooray!')

    # good
    %q[Mix the foo into the baz]
    %q(They all said: 'Hooray!')# The `upper_case_q` style requires the sole use of `%Q`.
    # bad
    %q/Mix the foo into the baz./
    %q{They all said: 'Hooray!'}

    # good
    %Q/Mix the foo into the baz./
    %Q{They all said: 'Hooray!'}
    ```
  :configuration:
    Description: Checks if uses of %Q/%q match the configured preference.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: lower_case_q
    SupportedStyles:
    - lower_case_q
    - upper_case_q
- :name: Style/PerlBackrefs
  :department_name: Style
  :description: |-
    This cop looks for uses of Perl-style regexp match
    backreferences like $1, $2, etc.
  :examples_description: |
    ```ruby
    # bad
    puts $1

    # good
    puts Regexp.last_match(1)
    ```
  :configuration:
    Description: Avoid Perl-style regex back references.
    StyleGuide: "#no-perl-regexp-last-matchers"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/PreferredHashMethods
  :department_name: Style
  :description: |-
    This cop (by default) checks for uses of methods Hash#has_key? and
    Hash#has_value? where it enforces Hash#key? and Hash#value?
    It is configurable to enforce the inverse, using `verbose` method
    names also.
  :examples_description: |
    ```ruby
    # bad
    Hash#has_key?
    Hash#has_value?

    # good
    Hash#key?
    Hash#value?# bad
    Hash#key?
    Hash#value?

    # good
    Hash#has_key?
    Hash#has_value?
    ```
  :configuration:
    Description: Checks use of `has_key?` and `has_value?` Hash methods.
    StyleGuide: "#hash-key"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: short
    SupportedStyles:
    - short
    - verbose
- :name: Style/Proc
  :department_name: Style
  :description: |-
    This cops checks for uses of Proc.new where Kernel#proc
    would be more appropriate.
  :examples_description: |
    ```ruby
    # bad
    p = Proc.new { |n| puts n }

    # good
    p = proc { |n| puts n }
    ```
  :configuration:
    Description: Use proc instead of Proc.new.
    StyleGuide: "#proc"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/RaiseArgs
  :department_name: Style
  :description: |-
    This cop checks the args passed to `fail` and `raise`. For exploded
    style (default), it recommends passing the exception class and message
    to `raise`, rather than construct an instance of the error. It will
    still allow passing just a message, or the construction of an error
    with more than one argument.

    The exploded style works identically, but with the addition that it
    will also suggest constructing error objects when the exception is
    passed multiple arguments.
  :examples_description: |
    ```ruby
    # bad
    raise StandardError.new("message")

    # good
    raise StandardError, "message"
    fail "message"
    raise MyCustomError.new(arg1, arg2, arg3)
    raise MyKwArgError.new(key1: val1, key2: val2)# bad
    raise StandardError, "message"
    raise RuntimeError, arg1, arg2, arg3

    # good
    raise StandardError.new("message")
    raise MyCustomError.new(arg1, arg2, arg3)
    fail "message"
    ```
  :configuration:
    Description: Checks the arguments passed to raise/fail.
    StyleGuide: "#exception-class-messages"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: exploded
    SupportedStyles:
    - compact
    - exploded
- :name: Style/RandomWithOffset
  :department_name: Style
  :description: |-
    This cop checks for the use of randomly generated numbers,
    added/subtracted with integer literals, as well as those with
    Integer#succ and Integer#pred methods. Prefer using ranges instead,
    as it clearly states the intentions.
  :examples_description: |
    ```ruby
    # bad
    rand(6) + 1
    1 + rand(6)
    rand(6) - 1
    1 - rand(6)
    rand(6).succ
    rand(6).pred
    Random.rand(6) + 1
    Kernel.rand(6) + 1
    rand(0..5) + 1

    # good
    rand(1..6)
    rand(1...7)
    ```
  :configuration:
    Description: Prefer to use ranges when generating random numbers instead of integers
      with offsets.
    StyleGuide: "#random-numbers"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/RedundantBegin
  :department_name: Style
  :description: |-
    This cop checks for redundant `begin` blocks.

    Currently it checks for code like this:
  :examples_description: |
    ```ruby

    # bad
    def redundant
      begin
        ala
        bala
      rescue StandardError => e
        something
      end
    end

    # good
    def preferred
      ala
      bala
    rescue StandardError => e
      something
    end

    # bad
    # When using Ruby 2.5 or later.
    do_something do
      begin
        something
      rescue => ex
        anything
      end
    end

    # good
    # In Ruby 2.5 or later, you can omit `begin` in `do-end` block.
    do_something do
      something
    rescue => ex
      anything
    end
    ```
  :configuration:
    Description: Don't use begin blocks when they are not needed.
    StyleGuide: "#begin-implicit"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/RedundantException
  :department_name: Style
  :description: |-
    This cop checks for RuntimeError as the argument of raise/fail.

    It checks for code like this:
  :examples_description: |
    ```ruby
    # Bad
    raise RuntimeError, 'message'

    # Bad
    raise RuntimeError.new('message')

    # Good
    raise 'message'
    ```
  :configuration:
    Description: Checks for an obsolete RuntimeException argument in raise/fail.
    StyleGuide: "#no-explicit-runtimeerror"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/RedundantFreeze
  :department_name: Style
  :description: This cop check for uses of Object#freeze on immutable objects.
  :examples_description: |
    ```ruby
    # bad
    CONST = 1.freeze

    # good
    CONST = 1
    ```
  :configuration:
    Description: Checks usages of Object#freeze on immutable objects.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/RedundantParentheses
  :department_name: Style
  :description: This cop checks for redundant parentheses.
  :examples_description: |
    ```ruby

    # bad
    (x) if ((y.z).nil?)

    # good
    x if y.z.nil?
    ```
  :configuration:
    Description: Checks for parentheses that seem not to serve any purpose.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/RedundantReturn
  :department_name: Style
  :description: This cop checks for redundant `return` expressions.
  :examples_description: |
    ```ruby
    # These bad cases should be extended to handle methods whose body is
    # if/else or a case expression with a default branch.

    # bad
    def test
      return something
    end

    # bad
    def test
      one
      two
      three
      return something
    end

    # good
    def test
      return something if something_else
    end

    # good
    def test
      if x
      elsif y
      else
      end
    end
    ```
  :configuration:
    Description: Don't use return where it's not required.
    StyleGuide: "#no-explicit-return"
    Enabled: true
  :configurable_attributes:
    AllowMultipleReturnValues: 'false'
- :name: Style/RedundantSelf
  :department_name: Style
  :description: |-
    This cop checks for redundant uses of `self`.

    The usage of `self` is only needed when:

    * Sending a message to same object with zero arguments in
      presence of a method name clash with an argument or a local
      variable.

    * Calling an attribute writer to prevent an local variable assignment.

    Note, with using explicit self you can only send messages with public or
    protected scope, you cannot send private messages this way.

    Note we allow uses of `self` with operators because it would be awkward
    otherwise.
  :examples_description: |
    ```ruby

    # bad
    def foo(bar)
      self.baz
    end

    # good
    def foo(bar)
      self.bar  # Resolves name clash with the argument.
    end

    def foo
      bar = 1
      self.bar  # Resolves name clash with the local variable.
    end

    def foo
      %w[x y z].select do |bar|
        self.bar == bar  # Resolves name clash with argument of the block.
      end
    end
    ```
  :configuration:
    Description: Don't use self where it's not needed.
    StyleGuide: "#no-self-unless-required"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/RedundantConditional
  :department_name: Style
  :description: This cop checks for redundant returning of true/false in conditionals.
  :examples_description: |
    ```ruby
    # bad
    x == y ? true : false

    # bad
    if x == y
      true
    else
      false
    end

    # good
    x == y

    # bad
    x == y ? false : true

    # good
    x != y
    ```
  :configuration:
    Description: Don't return true/false from a conditional.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/RegexpLiteral
  :department_name: Style
  :description: This cop enforces using // or %r around regular expressions.
  :examples_description: |
    ```ruby
    # bad
    snake_case = %r{^[\dA-Z_]+$}

    # bad
    regex = %r{
      foo
      (bar)
      (baz)
    }x

    # good
    snake_case = /^[\dA-Z_]+$/

    # good
    regex = /
      foo
      (bar)
      (baz)
    /x# bad
    snake_case = /^[\dA-Z_]+$/

    # bad
    regex = /
      foo
      (bar)
      (baz)
    /x

    # good
    snake_case = %r{^[\dA-Z_]+$}

    # good
    regex = %r{
      foo
      (bar)
      (baz)
    }x# bad
    snake_case = %r{^[\dA-Z_]+$}

    # bad
    regex = /
      foo
      (bar)
      (baz)
    /x

    # good
    snake_case = /^[\dA-Z_]+$/

    # good
    regex = %r{
      foo
      (bar)
      (baz)
    }x# If `false`, the cop will always recommend using `%r` if one or more
    # slashes are found in the regexp string.

    # bad
    x =~ /home\//

    # good
    x =~ %r{home/}# good
    x =~ /home\//
    ```
  :configuration:
    Description: Use / or %r around regular expressions.
    StyleGuide: "#percent-r"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: slashes
    SupportedStyles:
    - slashes
    - percent_r
    - mixed
    AllowInnerSlashes: 'false'
- :name: Style/RescueModifier
  :department_name: Style
  :description: This cop checks for uses of rescue in its modifier form.
  :examples_description: |
    ```ruby
    # bad
    some_method rescue handle_error

    # good
    begin
      some_method
    rescue
      handle_error
    end
    ```
  :configuration:
    Description: Avoid using rescue in its modifier form.
    StyleGuide: "#no-rescue-modifiers"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/RescueStandardError
  :department_name: Style
  :description: |-
    This cop checks for rescuing `StandardError`. There are two supported
    styles `implicit` and `explicit`. This cop will not register an offense
    if any error other than `StandardError` is specified.
  :examples_description: |
    ```ruby
    # `implicit` will enforce using `rescue` instead of
    # `rescue StandardError`.

    # bad
    begin
      foo
    rescue StandardError
      bar
    end

    # good
    begin
      foo
    rescue
      bar
    end

    # good
    begin
      foo
    rescue OtherError
      bar
    end

    # good
    begin
      foo
    rescue StandardError, SecurityError
      bar
    end# `explicit` will enforce using `rescue StandardError`
    # instead of `rescue`.

    # bad
    begin
      foo
    rescue
      bar
    end

    # good
    begin
      foo
    rescue StandardError
      bar
    end

    # good
    begin
      foo
    rescue OtherError
      bar
    end

    # good
    begin
      foo
    rescue StandardError, SecurityError
      bar
    end
    ```
  :configuration:
    Description: Avoid rescuing without specifying an error class.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: explicit
    SupportedStyles:
    - implicit
    - explicit
- :name: Style/ReturnNil
  :department_name: Style
  :description: |-
    This cop enforces consistency between 'return nil' and 'return'.

    Supported styles are: return, return_nil.
  :examples_description: |
    ```ruby
    # bad
    def foo(arg)
      return nil if arg
    end

    # good
    def foo(arg)
      return if arg
    end# bad
    def foo(arg)
      return if arg
    end

    # good
    def foo(arg)
      return nil if arg
    end
    ```
  :configuration:
    Description: Use return instead of return nil.
    Enabled: false
  :configurable_attributes:
    EnforcedStyle: return
    SupportedStyles:
    - return
    - return_nil
- :name: Style/SafeNavigation
  :department_name: Style
  :description: |-
    This cop transforms usages of a method call safeguarded by a non `nil`
    check for the variable whose method is being called to
    safe navigation (`&.`). If there is a method chain, all of the methods
    in the chain need to be checked for safety, and all of the methods will
    need to be changed to use safe navigation. We have limited the cop to
    not register an offense for method chains that exceed 2 methods.

    Configuration option: ConvertCodeThatCanStartToReturnNil
    The default for this is `false`. When configured to `true`, this will
    check for code in the format `!foo.nil? && foo.bar`. As it is written,
    the return of this code is limited to `false` and whatever the return
    of the method is. If this is converted to safe navigation,
    `foo&.bar` can start returning `nil` as well as what the method
    returns.
  :examples_description: |
    ```ruby
    # bad
    foo.bar if foo
    foo.bar.baz if foo
    foo.bar(param1, param2) if foo
    foo.bar { |e| e.something } if foo
    foo.bar(param) { |e| e.something } if foo

    foo.bar if !foo.nil?
    foo.bar unless !foo
    foo.bar unless foo.nil?

    foo && foo.bar
    foo && foo.bar.baz
    foo && foo.bar(param1, param2)
    foo && foo.bar { |e| e.something }
    foo && foo.bar(param) { |e| e.something }

    # good
    foo&.bar
    foo&.bar&.baz
    foo&.bar(param1, param2)
    foo&.bar { |e| e.something }
    foo&.bar(param) { |e| e.something }
    foo && foo.bar.baz.qux # method chain with more than 2 methods
    foo && foo.nil? # method that `nil` responds to

    # Method calls that do not use `.`
    foo && foo < bar
    foo < bar if foo

    # This could start returning `nil` as well as the return of the method
    foo.nil? || foo.bar
    !foo || foo.bar

    # Methods that are used on assignment, arithmetic operation or
    # comparison should not be converted to use safe navigation
    foo.baz = bar if foo
    foo.baz + bar if foo
    foo.bar > 2 if foo
    ```
  :configuration:
    Description: This cop transforms usages of a method call safeguarded by a check
      for the existence of the object to safe navigation (`&.`).
    Enabled: true
  :configurable_attributes:
    ConvertCodeThatCanStartToReturnNil: 'false'
    Whitelist:
    - present?
    - blank?
    - presence
    - try
- :name: Style/SelfAssignment
  :department_name: Style
  :description: This cop enforces the use the shorthand for self-assignment.
  :examples_description: |
    ```ruby

    # bad
    x = x + 1

    # good
    x += 1
    ```
  :configuration:
    Description: Checks for places where self-assignment shorthand should have been
      used.
    StyleGuide: "#self-assignment"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/Semicolon
  :department_name: Style
  :description: |-
    This cop checks for multiple expressions placed on the same line.
    It also checks for lines terminated with a semicolon.
  :examples_description: |
    ```ruby
    # bad
    foo = 1; bar = 2;
    baz = 3;

    # good
    foo = 1
    bar = 2
    baz = 3
    ```
  :configuration:
    Description: Don't use semicolons to terminate expressions.
    StyleGuide: "#no-semicolon"
    Enabled: true
  :configurable_attributes:
    AllowAsExpressionSeparator: 'false'
- :name: Style/Send
  :department_name: Style
  :description: This cop checks for the use of the send method.
  :examples_description: |
    ```ruby
    # bad
    Foo.send(:bar)
    quuz.send(:fred)

    # good
    Foo.__send__(:bar)
    quuz.public_send(:fred)
    ```
  :configuration:
    Description: Prefer `Object#__send__` or `Object#public_send` to `send`, as `send`
      may overlap with existing methods.
    StyleGuide: "#prefer-public-send"
    Enabled: false
  :configurable_attributes: {}
- :name: Style/SignalException
  :department_name: Style
  :description: This cop checks for uses of `fail` and `raise`.
  :examples_description: |
    ```ruby
    # The `only_raise` style enforces the sole use of `raise`.
    # bad
    begin
      fail
    rescue Exception
      # handle it
    end

    def watch_out
      fail
    rescue Exception
      # handle it
    end

    Kernel.fail

    # good
    begin
      raise
    rescue Exception
      # handle it
    end

    def watch_out
      raise
    rescue Exception
      # handle it
    end

    Kernel.raise# The `only_fail` style enforces the sole use of `fail`.
    # bad
    begin
      raise
    rescue Exception
      # handle it
    end

    def watch_out
      raise
    rescue Exception
      # handle it
    end

    Kernel.raise

    # good
    begin
      fail
    rescue Exception
      # handle it
    end

    def watch_out
      fail
    rescue Exception
      # handle it
    end

    Kernel.fail# The `semantic` style enforces the use of `fail` to signal an
    # exception, then will use `raise` to trigger an offense after
    # it has been rescued.
    # bad
    begin
      raise
    rescue Exception
      # handle it
    end

    def watch_out
      # Error thrown
    rescue Exception
      fail
    end

    Kernel.fail
    Kernel.raise

    # good
    begin
      fail
    rescue Exception
      # handle it
    end

    def watch_out
      fail
    rescue Exception
      raise 'Preferably with descriptive message'
    end

    explicit_receiver.fail
    explicit_receiver.raise
    ```
  :configuration:
    Description: Checks for proper usage of fail and raise.
    StyleGuide: "#prefer-raise-over-fail"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: only_raise
    SupportedStyles:
    - only_raise
    - only_fail
    - semantic
- :name: Style/SingleLineBlockParams
  :department_name: Style
  :description: |-
    This cop checks whether the block parameters of a single-line
    method accepting a block match the names specified via configuration.

    For instance one can configure `reduce`(`inject`) to use |a, e| as
    parameters.

    Configuration option: Methods
    Should be set to use this cop. Array of hashes, where each key is the
    method name and value - array of argument names.
  :examples_description: |
    ```ruby
    # bad
    foo.reduce { |c, d| c + d }
    foo.reduce { |_, _d| 1 }

    # good
    foo.reduce { |a, b| a + b }
    foo.reduce { |a, _b| a }
    foo.reduce { |a, (id, _)| a + id }
    foo.reduce { true }

    # good
    foo.reduce do |c, d|
      c + d
    end
    ```
  :configuration:
    Description: Enforces the names of some block params.
    Enabled: false
  :configurable_attributes:
    Methods:
    - reduce:
      - acc
      - elem
    - inject:
      - acc
      - elem
- :name: Style/SingleLineMethods
  :department_name: Style
  :description: |-
    This cop checks for single-line method definitions that contain a body.
    It will accept single-line methods with no body.
  :examples_description: |
    ```ruby
    # bad
    def some_method; body end
    def link_to(url); {:name => url}; end
    def @table.columns; super; end

    # good
    def no_op; end
    def self.resource_class=(klass); end
    def @table.columns; end
    ```
  :configuration:
    Description: Avoid single-line methods.
    StyleGuide: "#no-single-line-methods"
    Enabled: true
  :configurable_attributes:
    AllowIfMethodIsEmpty: 'true'
- :name: Style/SpecialGlobalVars
  :department_name: Style
  :description: This cop looks for uses of Perl-style global variables.
  :examples_description: |
    ```ruby
    # good
    puts $LOAD_PATH
    puts $LOADED_FEATURES
    puts $PROGRAM_NAME
    puts $ERROR_INFO
    puts $ERROR_POSITION
    puts $FIELD_SEPARATOR # or $FS
    puts $OUTPUT_FIELD_SEPARATOR # or $OFS
    puts $INPUT_RECORD_SEPARATOR # or $RS
    puts $OUTPUT_RECORD_SEPARATOR # or $ORS
    puts $INPUT_LINE_NUMBER # or $NR
    puts $LAST_READ_LINE
    puts $DEFAULT_OUTPUT
    puts $DEFAULT_INPUT
    puts $PROCESS_ID # or $PID
    puts $CHILD_STATUS
    puts $LAST_MATCH_INFO
    puts $IGNORECASE
    puts $ARGV # or ARGV
    puts $MATCH
    puts $PREMATCH
    puts $POSTMATCH
    puts $LAST_PAREN_MATCH# good
    puts $:
    puts $"
    puts $0
    puts $!
    puts $@
    puts $;
    puts $,
    puts $/
    puts $\
    puts $.
    puts $_
    puts $>
    puts $<
    puts $$
    puts $?
    puts $~
    puts $=
    puts $*
    puts $&
    puts $`
    puts $'
    puts $+
    ```
  :configuration:
    Description: Avoid Perl-style global variables.
    StyleGuide: "#no-cryptic-perlisms"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: use_english_names
    SupportedStyles:
    - use_perl_names
    - use_english_names
- :name: Style/StabbyLambdaParentheses
  :department_name: Style
  :description: |-
    Check for parentheses around stabby lambda arguments.
    There are two different styles. Defaults to `require_parentheses`.
  :examples_description: |
    ```ruby
    # bad
    ->a,b,c { a + b + c }

    # good
    ->(a,b,c) { a + b + c}# bad
    ->(a,b,c) { a + b + c }

    # good
    ->a,b,c { a + b + c}
    ```
  :configuration:
    Description: Check for the usage of parentheses around stabby lambda arguments.
    StyleGuide: "#stabby-lambda-with-args"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: require_parentheses
    SupportedStyles:
    - require_parentheses
    - require_no_parentheses
- :name: Style/StderrPuts
  :department_name: Style
  :description: |-
    This cop identifies places where `$stderr.puts` can be replaced by
    `warn`. The latter has the advantage of easily being disabled by,
    e.g. the -W0 interpreter flag, or setting $VERBOSE to nil.
  :examples_description: |
    ```ruby
    # bad
    $stderr.puts('hello')

    # good
    warn('hello')
    ```
  :configuration:
    Description: Use `warn` instead of `$stderr.puts`.
    StyleGuide: "#warn"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/StringHashKeys
  :department_name: Style
  :description: |-
    This cop checks for the use of strings as keys in hashes. The use of
    symbols is preferred instead.
  :examples_description: |
    ```ruby
    # bad
    { 'one' => 1, 'two' => 2, 'three' => 3 }

    # good
    { one: 1, two: 2, three: 3 }
    ```
  :configuration:
    Description: Prefer symbols instead of strings as hash keys.
    StyleGuide: "#symbols-as-keys"
    Enabled: false
  :configurable_attributes: {}
- :name: Style/StringLiterals
  :department_name: Style
  :description: Checks if uses of quotes match the configured preference.
  :examples_description: |
    ```ruby
    # bad
    "No special symbols"
    "No string interpolation"
    "Just text"

    # good
    'No special symbols'
    'No string interpolation'
    'Just text'
    "Wait! What's #{this}!"# bad
    'Just some text'
    'No special chars or interpolation'

    # good
    "Just some text"
    "No special chars or interpolation"
    "Every string in #{project} uses double_quotes"
    ```
  :configuration:
    Description: Checks if uses of quotes match the configured preference.
    StyleGuide: "#consistent-string-literals"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: single_quotes
    SupportedStyles:
    - single_quotes
    - double_quotes
    ConsistentQuotesInMultiline: 'false'
- :name: Style/StringLiteralsInInterpolation
  :department_name: Style
  :description: |-
    This cop checks that quotes inside the string interpolation
    match the configured preference.
  :examples_description: |
    ```ruby
    # bad
    result = "Tests #{success ? "PASS" : "FAIL"}"

    # good
    result = "Tests #{success ? 'PASS' : 'FAIL'}"# bad
    result = "Tests #{success ? 'PASS' : 'FAIL'}"

    # good
    result = "Tests #{success ? "PASS" : "FAIL"}"
    ```
  :configuration:
    Description: Checks if uses of quotes inside expressions in interpolated strings
      match the configured preference.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: single_quotes
    SupportedStyles:
    - single_quotes
    - double_quotes
- :name: Style/StringMethods
  :department_name: Style
  :description: |-
    This cop enforces the use of consistent method names
    from the String class.
  :examples_description: |
    ```ruby
    # bad
    'name'.intern
    'var'.unfavored_method

    # good
    'name'.to_sym
    'var'.preferred_method
    ```
  :configuration:
    Description: Checks if configured preferred methods are used over non-preferred.
    Enabled: false
  :configurable_attributes:
    PreferredMethods: '{"intern"=>"to_sym"}'
- :name: Style/StructInheritance
  :department_name: Style
  :description: This cop checks for inheritance from Struct.new.
  :examples_description: |
    ```ruby
    # bad
    class Person < Struct.new(:first_name, :last_name)
    end

    # good
    Person = Struct.new(:first_name, :last_name)
    ```
  :configuration:
    Description: Checks for inheritance from Struct.new.
    StyleGuide: "#no-extend-struct-new"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/SymbolArray
  :department_name: Style
  :description: |-
    This cop can check for array literals made up of symbols that are not
    using the %i() syntax.

    Alternatively, it checks for symbol arrays using the %i() syntax on
    projects which do not want to use that syntax.

    Configuration option: MinSize
    If set, arrays with fewer elements than this value will not trigger the
    cop. For example, a `MinSize of `3` will not enforce a style on an array
    of 2 or fewer elements.
  :examples_description: |
    ```ruby
    # good
    %i[foo bar baz]

    # bad
    [:foo, :bar, :baz]# good
    [:foo, :bar, :baz]

    # bad
    %i[foo bar baz]
    ```
  :configuration:
    Description: Use %i or %I for arrays of symbols.
    StyleGuide: "#percent-i"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: percent
    MinSize: '0'
    SupportedStyles:
    - percent
    - brackets
- :name: Style/SymbolLiteral
  :department_name: Style
  :description: This cop checks symbol literal syntax.
  :examples_description: |
    ```ruby

    # bad
    :"symbol"

    # good
    :symbol
    ```
  :configuration:
    Description: Use plain symbols instead of string symbols when possible.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/SymbolProc
  :department_name: Style
  :description: Use symbols as procs when possible.
  :examples_description: |
    ```ruby
    # bad
    something.map { |s| s.upcase }

    # good
    something.map(&:upcase)
    ```
  :configuration:
    Description: Use symbols as procs instead of blocks when possible.
    Enabled: true
  :configurable_attributes:
    IgnoredMethods:
    - respond_to
    - define_method
- :name: Style/TernaryParentheses
  :department_name: Style
  :description: |-
    This cop checks for the presence of parentheses around ternary
    conditions. It is configurable to enforce inclusion or omission of
    parentheses using `EnforcedStyle`. Omission is only enforced when
    removing the parentheses won't cause a different behavior.
  :examples_description: |
    ```ruby
    # bad
    foo = (bar?) ? a : b
    foo = (bar.baz?) ? a : b
    foo = (bar && baz) ? a : b

    # good
    foo = bar? ? a : b
    foo = bar.baz? ? a : b
    foo = bar && baz ? a : b# bad
    foo = bar? ? a : b
    foo = bar.baz? ? a : b
    foo = bar && baz ? a : b

    # good
    foo = (bar?) ? a : b
    foo = (bar.baz?) ? a : b
    foo = (bar && baz) ? a : b# bad
    foo = (bar?) ? a : b
    foo = (bar.baz?) ? a : b
    foo = bar && baz ? a : b

    # good
    foo = bar? ? a : b
    foo = bar.baz? ? a : b
    foo = (bar && baz) ? a : b
    ```
  :configuration:
    Description: Checks for use of parentheses around ternary conditions.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: require_no_parentheses
    SupportedStyles:
    - require_parentheses
    - require_no_parentheses
    - require_parentheses_when_complex
    AllowSafeAssignment: 'true'
- :name: Style/TrailingBodyOnClass
  :department_name: Style
  :description: This cop checks for trailing code after the class definition.
  :examples_description: |
    ```ruby
    # bad
    class Foo; def foo; end
    end

    # good
    class Foo
      def foo; end
    end
    ```
  :configuration:
    Description: Class body goes below class statement.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/TrailingBodyOnMethodDefinition
  :department_name: Style
  :description: This cop checks for trailing code after the method definition.
  :examples_description: |
    ```ruby
    # bad
    def some_method; do_stuff
    end

    def f(x); b = foo
      b[c: x]
    end

    # good
    def some_method
      do_stuff
    end

    def f(x)
      b = foo
      b[c: x]
    end
    ```
  :configuration:
    Description: Method body goes below definition.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/TrailingBodyOnModule
  :department_name: Style
  :description: This cop checks for trailing code after the module definition.
  :examples_description: |
    ```ruby
    # bad
    module Foo extend self
    end

    # good
    module Foo
      extend self
    end
    ```
  :configuration:
    Description: Module body goes below module statement.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/TrailingCommaInArguments
  :department_name: Style
  :description: This cop checks for trailing comma in argument lists.
  :examples_description: |
    ```ruby
    # bad
    method(1, 2,)

    # good
    method(
      1, 2,
      3,
    )

    # good
    method(
      1,
      2,
    )# bad
    method(1, 2,)

    # good
    method(
      1,
      2,
    )# bad
    method(1, 2,)

    # good
    method(
      1,
      2
    )
    ```
  :configuration:
    Description: Checks for trailing comma in argument lists.
    StyleGuide: "#no-trailing-params-comma"
    Enabled: true
  :configurable_attributes:
    EnforcedStyleForMultiline: no_comma
    SupportedStylesForMultiline:
    - comma
    - consistent_comma
    - no_comma
- :name: Style/TrailingCommaInArrayLiteral
  :department_name: Style
  :description: This cop checks for trailing comma in array literals.
  :examples_description: |
    ```ruby
    # bad
    a = [1, 2,]

    # good
    a = [
      1, 2,
      3,
    ]

    # good
    a = [
      1,
      2,
    ]# bad
    a = [1, 2,]

    # good
    a = [
      1,
      2,
    ]# bad
    a = [1, 2,]

    # good
    a = [
      1,
      2
    ]
    ```
  :configuration:
    Description: Checks for trailing comma in array literals.
    StyleGuide: "#no-trailing-array-commas"
    Enabled: true
  :configurable_attributes:
    EnforcedStyleForMultiline: no_comma
    SupportedStylesForMultiline:
    - comma
    - consistent_comma
    - no_comma
- :name: Style/TrailingCommaInHashLiteral
  :department_name: Style
  :description: This cop checks for trailing comma in hash literals.
  :examples_description: |
    ```ruby
    # bad
    a = { foo: 1, bar: 2, }

    # good
    a = {
      foo: 1, bar: 2,
      qux: 3,
    }

    # good
    a = {
      foo: 1,
      bar: 2,
    }# bad
    a = { foo: 1, bar: 2, }

    # good
    a = {
      foo: 1,
      bar: 2,
    }# bad
    a = { foo: 1, bar: 2, }

    # good
    a = {
      foo: 1,
      bar: 2
    }
    ```
  :configuration:
    Description: Checks for trailing comma in hash literals.
    Enabled: true
  :configurable_attributes:
    EnforcedStyleForMultiline: no_comma
    SupportedStylesForMultiline:
    - comma
    - consistent_comma
    - no_comma
- :name: Style/TrailingMethodEndStatement
  :department_name: Style
  :description: This cop checks for trailing code after the method definition.
  :examples_description: |
    ```ruby
    # bad
    def some_method
    do_stuff; end

    def do_this(x)
      baz.map { |b| b.this(x) } end

    def foo
      block do
        bar
      end end

    # good
    def some_method
      do_stuff
    end

    def do_this(x)
      baz.map { |b| b.this(x) }
    end

    def foo
      block do
        bar
      end
    end
    ```
  :configuration:
    Description: Checks for trailing end statement on line of method body.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/TrailingUnderscoreVariable
  :department_name: Style
  :description: This cop checks for extra underscores in variable assignment.
  :examples_description: |
    ```ruby
    # bad
    a, b, _ = foo()
    a, b, _, = foo()
    a, _, _ = foo()
    a, _, _, = foo()

    # good
    a, b, = foo()
    a, = foo()
    *a, b, _ = foo()
    # => We need to know to not include 2 variables in a
    a, *b, _ = foo()
    # => The correction `a, *b, = foo()` is a syntax error

    # good if AllowNamedUnderscoreVariables is true
    a, b, _something = foo()
    ```
  :configuration:
    Description: Checks for the usage of unneeded trailing underscores at the end
      of parallel variable assignment.
    Enabled: true
  :configurable_attributes:
    AllowNamedUnderscoreVariables: 'true'
- :name: Style/TrivialAccessors
  :department_name: Style
  :description: |-
    This cop looks for trivial reader/writer methods, that could
    have been created with the attr_* family of functions automatically.
  :examples_description: |
    ```ruby
    # bad
    def foo
      @foo
    end

    def bar=(val)
      @bar = val
    end

    def self.baz
      @baz
    end

    # good
    attr_reader :foo
    attr_writer :bar

    class << self
      attr_reader :baz
    end
    ```
  :configuration:
    Description: Prefer attr_* methods to trivial readers/writers.
    StyleGuide: "#attr_family"
    Enabled: true
  :configurable_attributes:
    ExactNameMatch: 'true'
    AllowPredicates: 'true'
    AllowDSLWriters: 'false'
    IgnoreClassMethods: 'false'
    Whitelist:
    - to_ary
    - to_a
    - to_c
    - to_enum
    - to_h
    - to_hash
    - to_i
    - to_int
    - to_io
    - to_open
    - to_path
    - to_proc
    - to_r
    - to_regexp
    - to_str
    - to_s
    - to_sym
- :name: Style/UnlessElse
  :department_name: Style
  :description: This cop looks for *unless* expressions with *else* clauses.
  :examples_description: |
    ```ruby
    # bad
    unless foo_bar.nil?
      # do something...
    else
      # do a different thing...
    end

    # good
    if foo_bar.present?
      # do something...
    else
      # do a different thing...
    end
    ```
  :configuration:
    Description: Do not use unless with else. Rewrite these with the positive case
      first.
    StyleGuide: "#no-else-with-unless"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/UnneededCapitalW
  :department_name: Style
  :description: This cop checks for usage of the %W() syntax when %w() would do.
  :examples_description: |
    ```ruby
    # bad
    %W(cat dog pig)
    %W[door wall floor]

    # good
    %w/swim run bike/
    %w[shirt pants shoes]
    %W(apple #{fruit} grape)
    ```
  :configuration:
    Description: Checks for %W when interpolation is not needed.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/UnneededInterpolation
  :department_name: Style
  :description: This cop checks for strings that are just an interpolated expression.
  :examples_description: |
    ```ruby

    # bad
    "#{@var}"

    # good
    @var.to_s

    # good if @var is already a String
    @var
    ```
  :configuration:
    Description: Checks for strings that are just an interpolated expression.
    Enabled: true
  :configurable_attributes: {}
- :name: Style/UnneededPercentQ
  :department_name: Style
  :description: This cop checks for usage of the %q/%Q syntax when '' or "" would
    do.
  :examples_description: ''
  :configuration:
    Description: Checks for %q/%Q when single quotes or double quotes would do.
    StyleGuide: "#percent-q"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/UnpackFirst
  :department_name: Style
  :description: |-
    This cop checks for accessing the first element of `String#unpack`
    which can be replaced with the shorter method `unpack1`.
  :examples_description: |
    ```ruby

    # bad
    'foo'.unpack('h*').first
    'foo'.unpack('h*')[0]
    'foo'.unpack('h*').slice(0)
    'foo'.unpack('h*').at(0)

    # good
    'foo'.unpack1('h*')
    ```
  :configuration:
    Description: Checks for accessing the first element of `String#unpack` instead
      of using `unpack1`
    Enabled: true
  :configurable_attributes: {}
- :name: Style/VariableInterpolation
  :department_name: Style
  :description: This cop checks for variable interpolation (like "#@ivar").
  :examples_description: |
    ```ruby
    # bad
    "His name is #$name"
    /check #$pattern/
    "Let's go to the #@store"

    # good
    "His name is #{$name}"
    /check #{$pattern}/
    "Let's go to the #{@store}"
    ```
  :configuration:
    Description: Don't interpolate global, instance and class variables directly in
      strings.
    StyleGuide: "#curlies-interpolate"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/WhenThen
  :department_name: Style
  :description: This cop checks for *when;* uses in *case* expressions.
  :examples_description: |
    ```ruby
    # bad
    case foo
    when 1; 'baz'
    when 2; 'bar'
    end

    # good
    case foo
    when 1 then 'baz'
    when 2 then 'bar'
    end
    ```
  :configuration:
    Description: Use when x then ... for one-line cases.
    StyleGuide: "#one-line-cases"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/WhileUntilDo
  :department_name: Style
  :description: Checks for uses of `do` in multi-line `while/until` statements.
  :examples_description: |
    ```ruby

    # bad
    while x.any? do
      do_something(x.pop)
    end

    # good
    while x.any?
      do_something(x.pop)
    end
    # bad
    until x.empty? do
      do_something(x.pop)
    end

    # good
    until x.empty?
      do_something(x.pop)
    end
    ```
  :configuration:
    Description: Checks for redundant do after while or until.
    StyleGuide: "#no-multiline-while-do"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/WhileUntilModifier
  :department_name: Style
  :description: |-
    Checks for while and until statements that would fit on one line
    if written as a modifier while/until. The maximum line length is
    configured in the `Metrics/LineLength` cop.
  :examples_description: |
    ```ruby
    # bad
    while x < 10
      x += 1
    end

    # good
    x += 1 while x < 10# bad
    until x > 10
      x += 1
    end

    # good
    x += 1 until x > 10
    ```
  :configuration:
    Description: Favor modifier while/until usage when you have a single-line body.
    StyleGuide: "#while-as-a-modifier"
    Enabled: true
  :configurable_attributes: {}
- :name: Style/WordArray
  :department_name: Style
  :description: |-
    This cop can check for array literals made up of word-like
    strings, that are not using the %w() syntax.

    Alternatively, it can check for uses of the %w() syntax, in projects
    which do not want to include that syntax.

    Configuration option: MinSize
    If set, arrays with fewer elements than this value will not trigger the
    cop. For example, a `MinSize` of `3` will not enforce a style on an
    array of 2 or fewer elements.
  :examples_description: |
    ```ruby
    # good
    %w[foo bar baz]

    # bad
    ['foo', 'bar', 'baz']# good
    ['foo', 'bar', 'baz']

    # bad
    %w[foo bar baz]
    ```
  :configuration:
    Description: Use %w or %W for arrays of words.
    StyleGuide: "#percent-w"
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: percent
    SupportedStyles:
    - percent
    - brackets
    MinSize: '0'
    WordRegex: "(?-mix:\\A[\\p{Word}\\n\\t]+\\z)"
- :name: Style/YodaCondition
  :department_name: Style
  :description: |-
    This cop checks for Yoda conditions, i.e. comparison operations where
    readability is reduced because the operands are not ordered the same
    way as they would be ordered in spoken English.
  :examples_description: |
    ```ruby
    # bad
    99 == foo
    "bar" != foo
    42 >= foo
    10 < bar

    # good
    foo == 99
    foo == "bar"
    foo <= 42
    bar > 10# bad
    99 == foo
    "bar" != foo

    # good
    99 >= foo
    3 < a && a < 5
    ```
  :configuration:
    Description: Do not use literals as the first operand of a comparison.
    Reference: https://en.wikipedia.org/wiki/Yoda_conditions
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: all_comparison_operators
    SupportedStyles:
    - all_comparison_operators
    - equality_operators_only
- :name: Style/ZeroLengthPredicate
  :department_name: Style
  :description: |-
    This cop checks for numeric comparisons that can be replaced
    by a predicate method, such as receiver.length == 0,
    receiver.length > 0, receiver.length != 0,
    receiver.length < 1 and receiver.size == 0 that can be
    replaced by receiver.empty? and !receiver.empty.
  :examples_description: |
    ```ruby
    # bad
    [1, 2, 3].length == 0
    0 == "foobar".length
    array.length < 1
    {a: 1, b: 2}.length != 0
    string.length > 0
    hash.size > 0

    # good
    [1, 2, 3].empty?
    "foobar".empty?
    array.empty?
    !{a: 1, b: 2}.empty?
    !string.empty?
    !hash.empty?
    ```
  :configuration:
    Description: 'Use #empty? when testing for objects of length 0.'
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/ActionFilter
  :department_name: Rails
  :description: |-
    This cop enforces the consistent use of action filter methods.

    The cop is configurable and can enforce the use of the older
    something_filter methods or the newer something_action methods.

    If the TargetRailsVersion is set to less than 4.0, the cop will enforce
    the use of filter methods.
  :examples_description: |
    ```ruby
    # bad
    after_filter :do_stuff
    append_around_filter :do_stuff
    skip_after_filter :do_stuff

    # good
    after_action :do_stuff
    append_around_action :do_stuff
    skip_after_action :do_stuff# bad
    after_action :do_stuff
    append_around_action :do_stuff
    skip_after_action :do_stuff

    # good
    after_filter :do_stuff
    append_around_filter :do_stuff
    skip_after_filter :do_stuff
    ```
  :configuration:
    Description: Enforces consistent use of action filter methods.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: action
    SupportedStyles:
    - action
    - filter
    Include:
    - app/controllers/**/*.rb
- :name: Rails/ActiveRecordAliases
  :department_name: Rails
  :description: |-
    Checks that ActiveRecord aliases are not used. The direct method names
    are more clear and easier to read.
  :examples_description: |
    ```ruby
    #bad
    Book.update_attributes!(author: 'Alice')

    #good
    Book.update!(author: 'Alice')
    ```
  :configuration:
    Description: 'Avoid Active Record aliases: Use `update` instead of `update_attributes`.
      Use `update!` instead of `update_attributes!`.'
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/ActiveSupportAliases
  :department_name: Rails
  :description: |-
    This cop checks that ActiveSupport aliases to core ruby methods
    are not used.
  :examples_description: |
    ```ruby
    # good
    'some_string'.start_with?('prefix')
    'some_string'.end_with?('suffix')
    [1, 2, 'a'] << 'b'
    [1, 2, 'a'].unshift('b')

    # bad
    'some_string'.starts_with?('prefix')
    'some_string'.ends_with?('suffix')
    [1, 2, 'a'].append('b')
    [1, 2, 'a'].prepend('b')
    ```
  :configuration:
    Description: 'Avoid ActiveSupport aliases of standard ruby methods: `String#starts_with?`,
      `String#ends_with?`, `Array#append`, `Array#prepend`.'
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/ApplicationJob
  :department_name: Rails
  :description: This cop checks that jobs subclass ApplicationJob with Rails 5.0.
  :examples_description: |
    ```ruby

    # good
    class Rails5Job < ApplicationJob
      # ...
    end

    # bad
    class Rails4Job < ActiveJob::Base
      # ...
    end
    ```
  :configuration:
    Description: Check that jobs subclass ApplicationJob.
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/ApplicationRecord
  :department_name: Rails
  :description: This cop checks that models subclass ApplicationRecord with Rails
    5.0.
  :examples_description: |
    ```ruby

    # good
    class Rails5Model < ApplicationRecord
      # ...
    end

    # bad
    class Rails4Model < ActiveRecord::Base
      # ...
    end
    ```
  :configuration:
    Description: Check that models subclass ApplicationRecord.
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/AssertNot
  :department_name: Rails
  :description: Use `assert_not` instead of `assert !`.
  :examples_description: |
    ```ruby
    # bad
    assert !x

    # good
    assert_not x
    ```
  :configuration:
    Description: Use `assert_not` instead of `assert !`.
    Enabled: true
  :configurable_attributes:
    Include:
    - "**/test/**/*"
- :name: Rails/Blank
  :department_name: Rails
  :description: |-
    This cops checks for code that can be changed to `blank?`.
    Settings:
      NilOrEmpty: Convert checks for `nil` or `empty?` to `blank?`
      NotPresent: Convert usages of not `present?` to `blank?`
      UnlessPresent: Convert usages of `unless` `present?` to `blank?`
  :examples_description: |
    ```ruby
    # NilOrEmpty: true
      # bad
      foo.nil? || foo.empty?
      foo == nil || foo.empty?

      # good
      foo.blank?

    # NotPresent: true
      # bad
      !foo.present?

      # good
      foo.blank?

    # UnlessPresent: true
      # bad
      something unless foo.present?
      unless foo.present?
        something
      end

      # good
      something if foo.blank?
      if foo.blank?
        something
      end
    ```
  :configuration:
    Description: Enforce using `blank?` and `present?`.
    Enabled: true
  :configurable_attributes:
    NilOrEmpty: 'true'
    NotPresent: 'true'
    UnlessPresent: 'true'
- :name: Rails/CreateTableWithTimestamps
  :department_name: Rails
  :description: |-
    This cop checks the migration for which timestamps are not included
    when creating a new table.
    In many cases, timestamps are useful information and should be added.
  :examples_description: |
    ```ruby
    # bad
    create_table :users

    # bad
    create_table :users do |t|
      t.string :name
      t.string :email
    end

    # good
    create_table :users do |t|
      t.string :name
      t.string :email

      t.timestamps
    end

    # good
    create_table :users do |t|
      t.string :name
      t.string :email

      t.datetime :created_at, default: -> { 'CURRENT_TIMESTAMP' }
    end

    # good
    create_table :users do |t|
      t.string :name
      t.string :email

      t.datetime :updated_at, default: -> { 'CURRENT_TIMESTAMP' }
    end
    ```
  :configuration:
    Description: Checks the migration for which timestamps are not included when creating
      a new table.
    Enabled: true
  :configurable_attributes:
    Include:
    - db/migrate/*.rb
- :name: Rails/Date
  :department_name: Rails
  :description: |-
    This cop checks for the correct use of Date methods,
    such as Date.today, Date.current etc.

    Using Date.today is dangerous, because it doesn't know anything about
    Rails time zone. You must use Time.zone.today instead.

    The cop also reports warnings when you are using 'to_time' method,
    because it doesn't know about Rails time zone either.

    Two styles are supported for this cop. When EnforcedStyle is 'strict'
    then the Date methods (today, current, yesterday, tomorrow)
    are prohibited and the usage of both 'to_time'
    and 'to_time_in_current_zone' is reported as warning.

    When EnforcedStyle is 'flexible' then only 'Date.today' is prohibited
    and only 'to_time' is reported as warning.
  :examples_description: |
    ```ruby
    # bad
    Date.current
    Date.yesterday
    Date.today
    date.to_time
    date.to_time_in_current_zone

    # good
    Time.zone.today
    Time.zone.today - 1.day# bad
    Date.today
    date.to_time

    # good
    Time.zone.today
    Time.zone.today - 1.day
    Date.current
    Date.yesterday
    date.to_time_in_current_zone
    ```
  :configuration:
    Description: Checks the correct usage of date aware methods, such as Date.today,
      Date.current etc.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: flexible
    SupportedStyles:
    - strict
    - flexible
- :name: Rails/DynamicFindBy
  :department_name: Rails
  :description: |-
    This cop checks dynamic `find_by_*` methods.
    Use `find_by` instead of dynamic method.
    See. https://github.com/bbatsov/rails-style-guide#find_by
  :examples_description: |
    ```ruby
    # bad
    User.find_by_name(name)

    # bad
    User.find_by_name_and_email(name)

    # bad
    User.find_by_email!(name)

    # good
    User.find_by(name: name)

    # good
    User.find_by(name: name, email: email)

    # good
    User.find_by!(email: email)
    ```
  :configuration:
    Description: Use `find_by` instead of dynamic `find_by_*`.
    StyleGuide: https://github.com/bbatsov/rails-style-guide#find_by
    Enabled: true
  :configurable_attributes:
    Whitelist:
    - find_by_sql
- :name: Rails/Delegate
  :department_name: Rails
  :description: |-
    This cop looks for delegations that could have been created
    automatically with the `delegate` method.

    Safe navigation `&.` is ignored because Rails' `allow_nil`
    option checks not just for nil but also delegates if nil
    responds to the delegated method.

    The `EnforceForPrefixed` option (defaulted to `true`) means that
    using the target object as a prefix of the method name
    without using the `delegate` method will be a violation.
    When set to `false`, this case is legal.
  :examples_description: |
    ```ruby
    # bad
    def bar
      foo.bar
    end

    # good
    delegate :bar, to: :foo

    # good
    def bar
      foo&.bar
    end

    # good
    private
    def bar
      foo.bar
    end

    # EnforceForPrefixed: true
    # bad
    def foo_bar
      foo.bar
    end

    # good
    delegate :bar, to: :foo, prefix: true

    # EnforceForPrefixed: false
    # good
    def foo_bar
      foo.bar
    end

    # good
    delegate :bar, to: :foo, prefix: true
    ```
  :configuration:
    Description: Prefer delegate method for delegations.
    Enabled: true
  :configurable_attributes:
    EnforceForPrefixed: 'true'
- :name: Rails/DelegateAllowBlank
  :department_name: Rails
  :description: |-
    This cop looks for delegations that pass :allow_blank as an option
    instead of :allow_nil. :allow_blank is not a valid option to pass
    to ActiveSupport#delegate.
  :examples_description: |
    ```ruby
    # bad
    delegate :foo, to: :bar, allow_blank: true

    # good
    delegate :foo, to: :bar, allow_nil: true
    ```
  :configuration:
    Description: Do not use allow_blank as an option to delegate.
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/EnumUniqueness
  :department_name: Rails
  :description: This cop looks for duplicate values in enum declarations.
  :examples_description: |
    ```ruby
    # bad
    enum status: { active: 0, archived: 0 }

    # good
    enum status: { active: 0, archived: 1 }

    # bad
    enum status: [:active, :archived, :active]

    # good
    enum status: [:active, :archived]
    ```
  :configuration:
    Description: Avoid duplicate integers in hash-syntax `enum` declaration.
    Enabled: true
  :configurable_attributes:
    Include:
    - app/models/**/*.rb
- :name: Rails/EnvironmentComparison
  :department_name: Rails
  :description: |-
    This cop checks that Rails.env is compared using `.production?`-like
    methods instead of equality against a string or symbol.
  :examples_description: |
    ```ruby
    # bad
    Rails.env == 'production'

    # bad, always returns false
    Rails.env == :test

    # good
    Rails.env.production?
    ```
  :configuration:
    Description: Favor `Rails.env.production?` over `Rails.env == 'production'`
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/Exit
  :department_name: Rails
  :description: |-
    This cop enforces that 'exit' calls are not used within a rails app.
    Valid options are instead to raise an error, break, return or some
    other form of stopping execution of current request.

    There are two obvious cases where 'exit' is particularly harmful:

    - Usage in library code for your application. Even though rails will
    rescue from a SystemExit and continue on, unit testing that library
    code will result in specs exiting (potentially silently if exit(0)
    is used.)
    - Usage in application code outside of the web process could result in
    the program exiting, which could result in the code failing to run and
    do its job.
  :examples_description: |
    ```ruby
    # bad
    exit(0)

    # good
    raise 'a bad error has happened'
    ```
  :configuration:
    Description: Favor `fail`, `break`, `return`, etc. over `exit` in application
      or library code outside of Rake files to avoid exits during unit testing or
      running in production.
    Enabled: true
  :configurable_attributes:
    Include:
    - app/**/*.rb
    - config/**/*.rb
    - lib/**/*.rb
    Exclude:
    - "/home/miguelsavignano/Developer/Projects/rubocop/lib/**/*.rake"
- :name: Rails/FilePath
  :department_name: Rails
  :description: |-
    This cop is used to identify usages of file path joining process
    to use `Rails.root.join` clause. This is to avoid bugs on operating
    system that don't use '/' as the path separator.
  :examples_description: |
    ```ruby
    # bad
    Rails.root.join('app/models/goober')
    File.join(Rails.root, 'app/models/goober')
    "#{Rails.root}/app/models/goober"

    # good
    Rails.root.join('app', 'models', 'goober')
    ```
  :configuration:
    Description: Use `Rails.root.join` for file path joining.
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/FindBy
  :department_name: Rails
  :description: |-
    This cop is used to identify usages of `where.first` and
    change them to use `find_by` instead.
  :examples_description: |
    ```ruby
    # bad
    User.where(name: 'Bruce').first
    User.where(name: 'Bruce').take

    # good
    User.find_by(name: 'Bruce')
    ```
  :configuration:
    Description: Prefer find_by over where.first.
    StyleGuide: https://github.com/bbatsov/rails-style-guide#find_by
    Enabled: true
  :configurable_attributes:
    Include:
    - app/models/**/*.rb
- :name: Rails/FindEach
  :department_name: Rails
  :description: |-
    This cop is used to identify usages of `all.each` and
    change them to use `all.find_each` instead.
  :examples_description: |
    ```ruby
    # bad
    User.all.each

    # good
    User.all.find_each
    ```
  :configuration:
    Description: Prefer all.find_each over all.find.
    StyleGuide: https://github.com/bbatsov/rails-style-guide#find-each
    Enabled: true
  :configurable_attributes:
    Include:
    - app/models/**/*.rb
- :name: Rails/HasAndBelongsToMany
  :department_name: Rails
  :description: This cop checks for the use of the has_and_belongs_to_many macro.
  :examples_description: |
    ```ruby
    # bad
    # has_and_belongs_to_many :ingredients

    # good
    # has_many :ingredients, through: :recipe_ingredients
    ```
  :configuration:
    Description: Prefer has_many :through to has_and_belongs_to_many.
    StyleGuide: https://github.com/bbatsov/rails-style-guide#has-many-through
    Enabled: true
  :configurable_attributes:
    Include:
    - app/models/**/*.rb
- :name: Rails/HasManyOrHasOneDependent
  :department_name: Rails
  :description: |-
    This cop looks for `has_many` or `has_one` associations that don't
    specify a `:dependent` option.
    It doesn't register an offense if `:through` option was specified.
  :examples_description: |
    ```ruby
    # bad
    class User < ActiveRecord::Base
      has_many :comments
      has_one :avatar
    end

    # good
    class User < ActiveRecord::Base
      has_many :comments, dependent: :restrict_with_exception
      has_one :avatar, dependent: :destroy
      has_many :patients, through: :appointments
    end
    ```
  :configuration:
    Description: Define the dependent option to the has_many and has_one associations.
    StyleGuide: https://github.com/bbatsov/rails-style-guide#has_many-has_one-dependent-option
    Enabled: true
  :configurable_attributes:
    Include:
    - app/models/**/*.rb
- :name: Rails/HttpPositionalArguments
  :department_name: Rails
  :description: |-
    This cop is used to identify usages of http methods like `get`, `post`,
    `put`, `patch` without the usage of keyword arguments in your tests and
    change them to use keyword args.  This cop only applies to Rails >= 5 .
    If you are running Rails < 5 you should disable the
    Rails/HttpPositionalArguments cop or set your TargetRailsVersion in your
    .rubocop.yml file to 4.0, etc.
  :examples_description: |
    ```ruby
    # bad
    get :new, { user_id: 1}

    # good
    get :new, params: { user_id: 1 }
    ```
  :configuration:
    Description: Use keyword arguments instead of positional arguments in http method
      calls.
    Enabled: true
  :configurable_attributes:
    Include:
    - spec/**/*
    - test/**/*
- :name: Rails/HttpStatus
  :department_name: Rails
  :description: Enforces use of symbolic or numeric value to define HTTP status.
  :examples_description: |
    ```ruby
    # bad
    render :foo, status: 200
    render json: { foo: 'bar' }, status: 200
    render plain: 'foo/bar', status: 304
    redirect_to root_url, status: 301

    # good
    render :foo, status: :ok
    render json: { foo: 'bar' }, status: :ok
    render plain: 'foo/bar', status: :not_modified
    redirect_to root_url, status: :moved_permanently# bad
    render :foo, status: :ok
    render json: { foo: 'bar' }, status: :not_found
    render plain: 'foo/bar', status: :not_modified
    redirect_to root_url, status: :moved_permanently

    # good
    render :foo, status: 200
    render json: { foo: 'bar' }, status: 404
    render plain: 'foo/bar', status: 304
    redirect_to root_url, status: 301
    ```
  :configuration:
    Description: Enforces use of symbolic or numeric value to define HTTP status.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: symbolic
    SupportedStyles:
    - numeric
    - symbolic
- :name: Rails/InverseOf
  :department_name: Rails
  :description: |-
    This cop looks for has_(one|many) and belongs_to associations where
    Active Record can't automatically determine the inverse association
    because of a scope or the options used. Using the blog with order scope
    example below, traversing the a Blog's association in both directions
    with `blog.posts.first.blog` would cause the `blog` to be loaded from
    the database twice.

    `:inverse_of` must be manually specified for Active Record to use the
    associated object in memory, or set to `false` to opt-out. Note that
    setting `nil` does not stop Active Record from trying to determine the
    inverse automatically, and is not considered a valid value for this.
  :examples_description: |
    ```ruby
    # good
    class Blog < ApplicationRecord
      has_many :posts
    end

    class Post < ApplicationRecord
      belongs_to :blog
    end# bad
    class Blog < ApplicationRecord
      has_many :posts, -> { order(published_at: :desc) }
    end

    class Post < ApplicationRecord
      belongs_to :blog
    end

    # good
    class Blog < ApplicationRecord
      has_many(:posts,
        -> { order(published_at: :desc) },
        inverse_of: :blog
      )
    end

    class Post < ApplicationRecord
      belongs_to :blog
    end

    # good
    class Blog < ApplicationRecord
      with_options inverse_of: :blog do
        has_many :posts, -> { order(published_at: :desc) }
      end
    end

    class Post < ApplicationRecord
      belongs_to :blog
    end

    # good
    # When you don't want to use the inverse association.
    class Blog < ApplicationRecord
      has_many(:posts,
        -> { order(published_at: :desc) },
        inverse_of: false
      )
    end# bad
    class Picture < ApplicationRecord
      belongs_to :imageable, polymorphic: true
    end

    class Employee < ApplicationRecord
      has_many :pictures, as: :imageable
    end

    class Product < ApplicationRecord
      has_many :pictures, as: :imageable
    end

    # good
    class Picture < ApplicationRecord
      belongs_to :imageable, polymorphic: true
    end

    class Employee < ApplicationRecord
      has_many :pictures, as: :imageable, inverse_of: :imageable
    end

    class Product < ApplicationRecord
      has_many :pictures, as: :imageable, inverse_of: :imageable
    end# bad
    # However, RuboCop can not detect this pattern...
    class Physician < ApplicationRecord
      has_many :appointments
      has_many :patients, through: :appointments
    end

    class Appointment < ApplicationRecord
      belongs_to :physician
      belongs_to :patient
    end

    class Patient < ApplicationRecord
      has_many :appointments
      has_many :physicians, through: :appointments
    end

    # good
    class Physician < ApplicationRecord
      has_many :appointments
      has_many :patients, through: :appointments
    end

    class Appointment < ApplicationRecord
      belongs_to :physician, inverse_of: :appointments
      belongs_to :patient, inverse_of: :appointments
    end

    class Patient < ApplicationRecord
      has_many :appointments
      has_many :physicians, through: :appointments
    end
    ```
  :configuration:
    Description: Checks for associations where the inverse cannot be determined automatically.
    Enabled: true
  :configurable_attributes:
    Include:
    - app/models/**/*.rb
- :name: Rails/LexicallyScopedActionFilter
  :department_name: Rails
  :description: |-
    This cop checks that methods specified in the filter's `only`
    or `except` options are explicitly defined in the class or module.

    You can specify methods of superclass or methods added by mixins
    on the filter, but these confuse developers. If you specify methods
    where are defined on another classes or modules, you should define
    the filter in that class or module.
  :examples_description: |
    ```ruby
    # bad
    class LoginController < ApplicationController
      before_action :require_login, only: %i[index settings logout]

      def index
      end
    end

    # good
    class LoginController < ApplicationController
      before_action :require_login, only: %i[index settings logout]

      def index
      end

      def settings
      end

      def logout
      end
    end# bad
    module FooMixin
      extend ActiveSupport::Concern

      included do
        before_action proc { authenticate }, only: :foo
      end
    end

    # good
    module FooMixin
      extend ActiveSupport::Concern

      included do
        before_action proc { authenticate }, only: :foo
      end

      def foo
        # something
      end
    end
    ```
  :configuration:
    Description: Checks that methods specified in the filter's `only` or `except`
      options are explicitly defined in the controller.
    StyleGuide: https://github.com/bbatsov/rails-style-guide#lexically-scoped-action-filter
    Enabled: true
  :configurable_attributes:
    Include:
    - app/controllers/**/*.rb
- :name: Rails/NotNullColumn
  :department_name: Rails
  :description: |-
    This cop checks for add_column call with NOT NULL constraint
    in migration file.
  :examples_description: |
    ```ruby
    # bad
    add_column :users, :name, :string, null: false
    add_reference :products, :category, null: false

    # good
    add_column :users, :name, :string, null: true
    add_column :users, :name, :string, null: false, default: ''
    add_reference :products, :category
    add_reference :products, :category, null: false, default: 1
    ```
  :configuration:
    Description: Do not add a NOT NULL column without a default value
    Enabled: true
  :configurable_attributes:
    Include:
    - db/migrate/*.rb
- :name: Rails/OutputSafety
  :department_name: Rails
  :description: |-
    This cop checks for the use of output safety calls like html_safe,
    raw, and safe_concat. These methods do not escape content. They
    simply return a SafeBuffer containing the content as is. Instead,
    use safe_join to join content and escape it and concat to
    concatenate content and escape it, ensuring its safety.
  :examples_description: |
    ```ruby
    user_content = "<b>hi</b>"

    # bad
    "<p>#{user_content}</p>".html_safe
    # => ActiveSupport::SafeBuffer "<p><b>hi</b></p>"

    # good
    content_tag(:p, user_content)
    # => ActiveSupport::SafeBuffer "<p>&lt;b&gt;hi&lt;/b&gt;</p>"

    # bad
    out = ""
    out << "<li>#{user_content}</li>"
    out << "<li>#{user_content}</li>"
    out.html_safe
    # => ActiveSupport::SafeBuffer "<li><b>hi</b></li><li><b>hi</b></li>"

    # good
    out = []
    out << content_tag(:li, user_content)
    out << content_tag(:li, user_content)
    safe_join(out)
    # => ActiveSupport::SafeBuffer
    #    "<li>&lt;b&gt;hi&lt;/b&gt;</li><li>&lt;b&gt;hi&lt;/b&gt;</li>"

    # bad
    out = "<h1>trusted content</h1>".html_safe
    out.safe_concat(user_content)
    # => ActiveSupport::SafeBuffer "<h1>trusted_content</h1><b>hi</b>"

    # good
    out = "<h1>trusted content</h1>".html_safe
    out.concat(user_content)
    # => ActiveSupport::SafeBuffer
    #    "<h1>trusted_content</h1>&lt;b&gt;hi&lt;/b&gt;"

    # safe, though maybe not good style
    out = "trusted content"
    result = out.concat(user_content)
    # => String "trusted content<b>hi</b>"
    # because when rendered in ERB the String will be escaped:
    # <%= result %>
    # => trusted content&lt;b&gt;hi&lt;/b&gt;

    # bad
    (user_content + " " + content_tag(:span, user_content)).html_safe
    # => ActiveSupport::SafeBuffer "<b>hi</b> <span><b>hi</b></span>"

    # good
    safe_join([user_content, " ", content_tag(:span, user_content)])
    # => ActiveSupport::SafeBuffer
    #    "&lt;b&gt;hi&lt;/b&gt; <span>&lt;b&gt;hi&lt;/b&gt;</span>"
    ```
  :configuration:
    Description: The use of `html_safe` or `raw` may be a security risk.
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/Output
  :department_name: Rails
  :description: This cop checks for the use of output calls like puts and print
  :examples_description: |
    ```ruby
    # bad
    puts 'A debug message'
    pp 'A debug message'
    print 'A debug message'

    # good
    Rails.logger.debug 'A debug message'
    ```
  :configuration:
    Description: Checks for calls to puts, print, etc.
    Enabled: true
  :configurable_attributes:
    Include:
    - app/**/*.rb
    - config/**/*.rb
    - db/**/*.rb
    - lib/**/*.rb
- :name: Rails/PluralizationGrammar
  :department_name: Rails
  :description: |-
    This cop checks for correct grammar when using ActiveSupport's
    core extensions to the numeric classes.
  :examples_description: |
    ```ruby
    # bad
    3.day.ago
    1.months.ago

    # good
    3.days.ago
    1.month.ago
    ```
  :configuration:
    Description: Checks for incorrect grammar when using methods like `3.day.ago`.
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/Presence
  :department_name: Rails
  :description: |-
    This cop checks code that can be written more easily using
    `Object#presence` defined by Active Support.
  :examples_description: |
    ```ruby
    # bad
    a.present? ? a : nil

    # bad
    !a.present? ? nil : a

    # bad
    a.blank? ? nil : a

    # bad
    !a.blank? ? a : nil

    # good
    a.presence# bad
    a.present? ? a : b

    # bad
    !a.present? ? b : a

    # bad
    a.blank? ? b : a

    # bad
    !a.blank? ? a : b

    # good
    a.presence || b
    ```
  :configuration:
    Description: Checks code that can be written more easily using `Object#presence`
      defined by Active Support.
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/Present
  :department_name: Rails
  :description: |-
    This cops checks for code that can be changed to `blank?`.
    Settings:
      NotNilAndNotEmpty: Convert checks for not `nil` and `not empty?`
                         to `present?`
      NotBlank: Convert usages of not `blank?` to `present?`
      UnlessBlank: Convert usages of `unless` `blank?` to `if` `present?`
  :examples_description: |
    ```ruby
    # NotNilAndNotEmpty: true
      # bad
      !foo.nil? && !foo.empty?
      foo != nil && !foo.empty?
      !foo.blank?

      # good
      foo.present?

    # NotBlank: true
      # bad
      !foo.blank?
      not foo.blank?

      # good
      foo.present?

    # UnlessBlank: true
      # bad
      something unless foo.blank?

      # good
      something if  foo.present?
    ```
  :configuration:
    Description: Enforce using `blank?` and `present?`.
    Enabled: true
  :configurable_attributes:
    NotNilAndNotEmpty: 'true'
    NotBlank: 'true'
    UnlessBlank: 'true'
- :name: Rails/ReadWriteAttribute
  :department_name: Rails
  :description: |-
    This cop checks for the use of the read_attribute or write_attribute
    methods, and recommends square brackets instead.

    If an attribute is missing from the instance (for example, when
    initialized by a partial `select`) then read_attribute will return nil,
    but square brackets will raise an ActiveModel::MissingAttributeError.

    Explicitly raising an error in this situation is preferable, and that
    is why rubocop recommends using square brackets.
  :examples_description: |
    ```ruby

    # bad
    x = read_attribute(:attr)
    write_attribute(:attr, val)

    # good
    x = self[:attr]
    self[:attr] = val
    ```
  :configuration:
    Description: Checks for read_attribute(:attr) and write_attribute(:attr, val).
    StyleGuide: https://github.com/bbatsov/rails-style-guide#read-attribute
    Enabled: true
  :configurable_attributes:
    Include:
    - app/models/**/*.rb
- :name: Rails/RedundantReceiverInWithOptions
  :department_name: Rails
  :description: |-
    This cop checks for redundant receiver in `with_options`.
    Receiver is implicit from Rails 4.2 or higher.
  :examples_description: |
    ```ruby
    # bad
    class Account < ApplicationRecord
      with_options dependent: :destroy do |assoc|
        assoc.has_many :customers
        assoc.has_many :products
        assoc.has_many :invoices
        assoc.has_many :expenses
      end
    end

    # good
    class Account < ApplicationRecord
      with_options dependent: :destroy do
        has_many :customers
        has_many :products
        has_many :invoices
        has_many :expenses
      end
    end# bad
    with_options options: false do |merger|
      merger.invoke(merger.something)
    end

    # good
    with_options options: false do
      invoke(something)
    end

    # good
    client = Client.new
    with_options options: false do |merger|
      client.invoke(merger.something, something)
    end

    # ok
    # When `with_options` includes a block, all scoping scenarios
    # cannot be evaluated. Thus, it is ok to include the explicit
    # receiver.
    with_options options: false do |merger|
      merger.invoke
      with_another_method do |another_receiver|
        merger.invoke(another_receiver)
      end
    end
    ```
  :configuration:
    Description: Checks for redundant receiver in `with_options`.
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/RefuteMethods
  :department_name: Rails
  :description: Use `assert_not` methods instead of `refute` methods.
  :examples_description: |
    ```ruby
    # bad
    refute false
    refute_empty [1, 2, 3]
    refute_equal true, false

    # good
    assert_not false
    assert_not_empty [1, 2, 3]
    assert_not_equal true, false
    ```
  :configuration:
    Description: Use `assert_not` methods instead of `refute` methods.
    Enabled: true
  :configurable_attributes:
    Include:
    - "**/test/**/*"
- :name: Rails/RequestReferer
  :department_name: Rails
  :description: |-
    This cop checks for consistent uses of `request.referer` or
    `request.referrer`, depending on the cop's configuration.
  :examples_description: |
    ```ruby
    # bad
    request.referrer

    # good
    request.referer# bad
    request.referer

    # good
    request.referrer
    ```
  :configuration:
    Description: Use consistent syntax for request.referer.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: referer
    SupportedStyles:
    - referer
    - referrer
- :name: Rails/ReversibleMigration
  :department_name: Rails
  :description: |-
    This cop checks whether the change method of the migration file is
    reversible.
  :examples_description: |
    ```ruby
    # bad
    def change
      change_table :users do |t|
        t.remove :name
      end
    end

    # good
    def change
      create_table :users do |t|
        t.string :name
      end
    end

    # good
    def change
      reversible do |dir|
        change_table :users do |t|
          dir.up do
            t.column :name, :string
          end

          dir.down do
            t.remove :name
          end
        end
      end
    end# drop_table

    # bad
    def change
      drop_table :users
    end

    # good
    def change
      drop_table :users do |t|
        t.string :name
      end
    end# change_column_default

    # bad
    def change
      change_column_default(:suppliers, :qualification, 'new')
    end

    # good
    def change
      change_column_default(:posts, :state, from: nil, to: "draft")
    end# remove_column

    # bad
    def change
      remove_column(:suppliers, :qualification)
    end

    # good
    def change
      remove_column(:suppliers, :qualification, :string)
    end# remove_foreign_key

    # bad
    def change
      remove_foreign_key :accounts, column: :owner_id
    end

    # good
    def change
      remove_foreign_key :accounts, :branches
    end# change_table

    # bad
    def change
      change_table :users do |t|
        t.remove :name
        t.change_default :authorized, 1
        t.change :price, :string
      end
    end

    # good
    def change
      change_table :users do |t|
        t.string :name
      end
    end

    # good
    def change
      reversible do |dir|
        change_table :users do |t|
          dir.up do
            t.change :price, :string
          end

          dir.down do
            t.change :price, :integer
          end
        end
      end
    end
    ```
  :configuration:
    Description: Checks whether the change method of the migration file is reversible.
    StyleGuide: https://github.com/bbatsov/rails-style-guide#reversible-migration
    Reference: http://api.rubyonrails.org/classes/ActiveRecord/Migration/CommandRecorder.html
    Enabled: true
  :configurable_attributes:
    Include:
    - db/migrate/*.rb
- :name: Rails/RelativeDateConstant
  :department_name: Rails
  :description: |-
    This cop checks whether constant value isn't relative date.
    Because the relative date will be evaluated only once.
  :examples_description: |
    ```ruby
    # bad
    class SomeClass
      EXPIRED_AT = 1.week.since
    end

    # good
    class SomeClass
      def self.expired_at
        1.week.since
      end
    end
    ```
  :configuration:
    Description: Do not assign relative date to constants.
    Enabled: true
  :configurable_attributes: {}
- :name: Rails/SafeNavigation
  :department_name: Rails
  :description: |-
    This cop converts usages of `try!` to `&.`. It can also be configured
    to convert `try`. It will convert code to use safe navigation if the
    target Ruby version is set to 2.3+
  :examples_description: |
    ```ruby
    # ConvertTry: false
      # bad
      foo.try!(:bar)
      foo.try!(:bar, baz)
      foo.try!(:bar) { |e| e.baz }

      foo.try!(:[], 0)

      # good
      foo.try(:bar)
      foo.try(:bar, baz)
      foo.try(:bar) { |e| e.baz }

      foo&.bar
      foo&.bar(baz)
      foo&.bar { |e| e.baz }

    # ConvertTry: true
      # bad
      foo.try!(:bar)
      foo.try!(:bar, baz)
      foo.try!(:bar) { |e| e.baz }
      foo.try(:bar)
      foo.try(:bar, baz)
      foo.try(:bar) { |e| e.baz }

      # good
      foo&.bar
      foo&.bar(baz)
      foo&.bar { |e| e.baz }
    ```
  :configuration:
    Description: Use Ruby's safe navigation operator (`&.`) instead of `try!`
    Enabled: true
  :configurable_attributes:
    ConvertTry: 'false'
- :name: Rails/SaveBang
  :department_name: Rails
  :description: |-
    This cop identifies possible cases where Active Record save! or related
    should be used instead of save because the model might have failed to
    save and an exception is better than unhandled failure.

    This will ignore calls that return a boolean for success if the result
    is assigned to a variable or used as the condition in an if/unless
    statement.  It will also ignore calls that return a model assigned to a
    variable that has a call to `persisted?`. Finally, it will ignore any
    call with more than 2 arguments as that is likely not an Active Record
    call or a Model.update(id, attributes) call.
  :examples_description: |
    ```ruby

    # bad
    user.save
    user.update(name: 'Joe')
    user.find_or_create_by(name: 'Joe')
    user.destroy

    # good
    unless user.save
      # ...
    end
    user.save!
    user.update!(name: 'Joe')
    user.find_or_create_by!(name: 'Joe')
    user.destroy!

    user = User.find_or_create_by(name: 'Joe')
    unless user.persisted?
      # ...
    end
    ```
  :configuration:
    Description: Identifies possible cases where Active Record save! or related should
      be used.
    StyleGuide: https://github.com/bbatsov/rails-style-guide#save-bang
    Enabled: false
  :configurable_attributes: {}
- :name: Rails/ScopeArgs
  :department_name: Rails
  :description: |-
    This cop checks for scope calls where it was passed
    a method (usually a scope) instead of a lambda/proc.
  :examples_description: |
    ```ruby

    # bad
    scope :something, where(something: true)

    # good
    scope :something, -> { where(something: true) }
    ```
  :configuration:
    Description: Checks the arguments of ActiveRecord scopes.
    Enabled: true
  :configurable_attributes:
    Include:
    - app/models/**/*.rb
- :name: Rails/SkipsModelValidations
  :department_name: Rails
  :description: |-
    This cop checks for the use of methods which skip
    validations which are listed in
    http://guides.rubyonrails.org/active_record_validations.html#skipping-validations
  :examples_description: |
    ```ruby
    # bad
    Article.first.decrement!(:view_count)
    DiscussionBoard.decrement_counter(:post_count, 5)
    Article.first.increment!(:view_count)
    DiscussionBoard.increment_counter(:post_count, 5)
    person.toggle :active
    product.touch
    Billing.update_all("category = 'authorized', author = 'David'")
    user.update_attribute(:website, 'example.com')
    user.update_columns(last_request_at: Time.current)
    Post.update_counters 5, comment_count: -1, action_count: 1

    # good
    user.update(website: 'example.com')
    FileUtils.touch('file')
    ```
  :configuration:
    Description: Use methods that skips model validations with caution. See reference
      for more information.
    Reference: http://guides.rubyonrails.org/active_record_validations.html#skipping-validations
    Enabled: true
  :configurable_attributes:
    Blacklist:
    - decrement!
    - decrement_counter
    - increment!
    - increment_counter
    - toggle!
    - touch
    - update_all
    - update_attribute
    - update_column
    - update_columns
    - update_counters
- :name: Rails/TimeZone
  :department_name: Rails
  :description: |-
    This cop checks for the use of Time methods without zone.

    Built on top of Ruby on Rails style guide (https://github.com/bbatsov/rails-style-guide#time)
    and the article http://danilenko.org/2012/7/6/rails_timezones/ .

    Two styles are supported for this cop. When EnforcedStyle is 'strict'
    then only use of Time.zone is allowed.

    When EnforcedStyle is 'flexible' then it's also allowed
    to use Time.in_time_zone.
  :examples_description: |
    ```ruby
    # `strict` means that `Time` should be used with `zone`.

    # bad
    Time.now
    Time.parse('2015-03-02 19:05:37')

    # bad
    Time.current
    Time.at(timestamp).in_time_zone

    # good
    Time.zone.now
    Time.zone.parse('2015-03-02 19:05:37')# `flexible` allows usage of `in_time_zone` instead of `zone`.

    # bad
    Time.now
    Time.parse('2015-03-02 19:05:37')

    # good
    Time.zone.now
    Time.zone.parse('2015-03-02 19:05:37')

    # good
    Time.current
    Time.at(timestamp).in_time_zone
    ```
  :configuration:
    Description: Checks the correct usage of time zone aware methods.
    StyleGuide: https://github.com/bbatsov/rails-style-guide#time
    Reference: http://danilenko.org/2012/7/6/rails_timezones
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: flexible
    SupportedStyles:
    - strict
    - flexible
- :name: Rails/UniqBeforePluck
  :department_name: Rails
  :description: |-
    Prefer the use of uniq (or distinct), before pluck instead of after.

    The use of uniq before pluck is preferred because it executes within
    the database.

    This cop has two different enforcement modes. When the EnforcedStyle
    is conservative (the default) then only calls to pluck on a constant
    (i.e. a model class) before uniq are added as offenses.

    When the EnforcedStyle is aggressive then all calls to pluck before
    uniq are added as offenses. This may lead to false positives as the cop
    cannot distinguish between calls to pluck on an ActiveRecord::Relation
    vs a call to pluck on an ActiveRecord::Associations::CollectionProxy.

    Autocorrect is disabled by default for this cop since it may generate
    false positives.
  :examples_description: |
    ```ruby
    # bad
    Model.pluck(:id).uniq

    # good
    Model.uniq.pluck(:id)# bad
    # this will return a Relation that pluck is called on
    Model.where(cond: true).pluck(:id).uniq

    # bad
    # an association on an instance will return a CollectionProxy
    instance.assoc.pluck(:id).uniq

    # bad
    Model.pluck(:id).uniq

    # good
    Model.uniq.pluck(:id)
    ```
  :configuration:
    Description: Prefer the use of uniq or distinct before pluck.
    Enabled: true
  :configurable_attributes:
    EnforcedStyle: conservative
    SupportedStyles:
    - conservative
    - aggressive
    AutoCorrect: 'false'
- :name: Rails/UnknownEnv
  :department_name: Rails
  :description: |-
    This cop checks that environments called with `Rails.env` predicates
    exist.
  :examples_description: |
    ```ruby
    # bad
    Rails.env.proudction?

    # good
    Rails.env.production?
    ```
  :configuration:
    Description: Use correct environment name.
    Enabled: true
  :configurable_attributes:
    Environments:
    - development
    - test
    - production
- :name: Rails/Validation
  :department_name: Rails
  :description: This cop checks for the use of old-style attribute validation macros.
  :examples_description: |
    ```ruby
    # bad
    validates_acceptance_of :foo
    validates_confirmation_of :foo
    validates_exclusion_of :foo
    validates_format_of :foo
    validates_inclusion_of :foo
    validates_length_of :foo
    validates_numericality_of :foo
    validates_presence_of :foo
    validates_size_of :foo
    validates_uniqueness_of :foo

    # good
    validates :foo, acceptance: true
    validates :foo, confirmation: true
    validates :foo, exclusion: true
    validates :foo, format: true
    validates :foo, inclusion: true
    validates :foo, length: true
    validates :foo, numericality: true
    validates :foo, presence: true
    validates :foo, size: true
    validates :foo, uniqueness: true
    ```
  :configuration:
    Description: Use validates :attribute, hash of validations.
    Enabled: true
  :configurable_attributes:
    Include:
    - app/models/**/*.rb
- :name: Security/Eval
  :department_name: Security
  :description: This cop checks for the use of `Kernel#eval` and `Binding#eval`.
  :examples_description: |
    ```ruby

    # bad

    eval(something)
    binding.eval(something)
    ```
  :configuration:
    Description: The use of eval represents a serious security risk.
    Enabled: true
  :configurable_attributes: {}
- :name: Security/JSONLoad
  :department_name: Security
  :description: |-
    This cop checks for the use of JSON class methods which have potential
    security issues.

    Autocorrect is disabled by default because it's potentially dangerous.
    If using a stream, like `JSON.load(open('file'))`, it will need to call
    `#read` manually, like `JSON.parse(open('file').read)`.
    If reading single values (rather than proper JSON objects), like
    `JSON.load('false')`, it will need to pass the `quirks_mode: true`
    option, like `JSON.parse('false', quirks_mode: true)`.
    Other similar issues may apply.
  :examples_description: |
    ```ruby
    # always offense
    JSON.load("{}")
    JSON.restore("{}")

    # no offense
    JSON.parse("{}")
    ```
  :configuration:
    Description: Prefer usage of `JSON.parse` over `JSON.load` due to potential security
      issues. See reference for more information.
    Reference: http://ruby-doc.org/stdlib-2.3.0/libdoc/json/rdoc/JSON.html#method-i-load
    Enabled: true
  :configurable_attributes:
    AutoCorrect: 'false'
- :name: Security/MarshalLoad
  :department_name: Security
  :description: |-
    This cop checks for the use of Marshal class methods which have
    potential security issues leading to remote code execution when
    loading from an untrusted source.
  :examples_description: |
    ```ruby
    # bad
    Marshal.load("{}")
    Marshal.restore("{}")

    # good
    Marshal.dump("{}")

    # okish - deep copy hack
    Marshal.load(Marshal.dump({}))
    ```
  :configuration:
    Description: Avoid using of `Marshal.load` or `Marshal.restore` due to potential
      security issues. See reference for more information.
    Reference: http://ruby-doc.org/core-2.3.3/Marshal.html#module-Marshal-label-Security+considerations
    Enabled: true
  :configurable_attributes: {}
- :name: Security/Open
  :department_name: Security
  :description: |-
    This cop checks for the use of `Kernel#open`.
    `Kernel#open` enables not only file access but also process invocation
    by prefixing a pipe symbol (e.g., `open("| ls")`).  So, it may lead to
    a serious security risk by using variable input to the argument of
    `Kernel#open`.  It would be better to use `File.open` or `IO.popen`
    explicitly.
  :examples_description: |
    ```ruby
    # bad
    open(something)

    # good
    File.open(something)
    IO.popen(something)
    ```
  :configuration:
    Description: The use of Kernel#open represents a serious security risk.
    Enabled: true
  :configurable_attributes: {}
- :name: Security/YAMLLoad
  :department_name: Security
  :description: |-
    This cop checks for the use of YAML class methods which have
    potential security issues leading to remote code execution when
    loading from an untrusted source.
  :examples_description: |
    ```ruby
    # bad
    YAML.load("--- foo")

    # good
    YAML.safe_load("--- foo")
    YAML.dump("foo")
    ```
  :configuration:
    Description: Prefer usage of `YAML.safe_load` over `YAML.load` due to potential
      security issues. See reference for more information.
    Reference: https://ruby-doc.org/stdlib-2.3.3/libdoc/yaml/rdoc/YAML.html#module-YAML-label-Security
    Enabled: true
  :configurable_attributes: {}
- :name: InternalAffairs/NodeDestructuring
  :department_name: InternalAffairs
  :description: |-
    Checks that node destructuring is done either using the node
    extensions or using a splat.
  :examples_description: |
    ```ruby

    # bad
    receiver, method_name, arguments = send_node.children

    # good
    receiver, method_name, arguments = *send_node
    # bad
    _receiver, method_name, _arguments = send_node.children

    # good
    method_name = send_node.method_name
    ```
  :configuration:
    Enabled: true
  :configurable_attributes: {}
- :name: InternalAffairs/NodeTypePredicate
  :department_name: InternalAffairs
  :description: Checks that node types are checked using the predicate helpers.
  :examples_description: |
    ```ruby

    # bad
    node.type == :send

    # good
    node.send_type?
    ```
  :configuration:
    Enabled: true
  :configurable_attributes: {}
- :name: InternalAffairs/OffenseLocationKeyword
  :department_name: InternalAffairs
  :description: |-
    Checks for potential uses of the location keywords which can be used as
    shortcut arguments to `#add_offense`.
  :examples_description: |
    ```ruby

    # bad
    add_offense(node, location: node.loc.selector)

    # good
    add_offense(node, location: :selector)
    ```
  :configuration:
    Enabled: true
  :configurable_attributes: {}
- :name: InternalAffairs/RedundantMessageArgument
  :department_name: InternalAffairs
  :description: |-
    Checks for redundant message arguments to `#add_offense`. This method
    will automatically use `#message` or `MSG` (in that order of priority)
    if they are defined.
  :examples_description: |
    ```ruby

    # bad
    add_offense(node, message: MSG)
    add_offense(node, message: message)
    add_offense(node, message: message(node))

    # good
    add_offense(node)
    add_offense(node, message: CUSTOM_MSG)
    add_offense(node, message: message(other_node))
    ```
  :configuration:
    Enabled: true
  :configurable_attributes: {}
- :name: InternalAffairs/RedundantLocationArgument
  :department_name: InternalAffairs
  :description: |-
    Checks for redundant `location` argument to `#add_offense`. `location`
    argument has a default value of `:expression` and this method will
    automatically use it.
  :examples_description: |
    ```ruby

    # bad
    add_offense(node, location: :expression)

    # good
    add_offense(node)
    add_offense(node, location: :selector)
    ```
  :configuration:
    Enabled: true
  :configurable_attributes: {}
- :name: InternalAffairs/UselessMessageAssertion
  :department_name: InternalAffairs
  :description: Checks that cops are not tested using `described_class::MSG`.
  :examples_description: |
    ```ruby

    # bad
    expect(cop.messages).to eq([described_class::MSG])

    # good
    expect(cop.messages).to eq(['Do not write bad code like that.'])
    ```
  :configuration:
    Enabled: true
  :configurable_attributes: {}
- :name: Test/ClassMustBeAModuleCop
  :department_name: Test
  :description: ''
  :examples_description: ''
  :configuration:
    Enabled: true
  :configurable_attributes: {}
- :name: Test/ModuleMustBeAClassCop
  :department_name: Test
  :description: ''
  :examples_description: ''
  :configuration:
    Enabled: true
  :configurable_attributes: {}
